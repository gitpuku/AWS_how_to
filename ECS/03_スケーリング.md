# ECS オートスケーリング設定手順書

## 1. オートスケーリングの概要

### 1.1 オートスケーリングのフロー

ECS におけるオートスケーリングは、以下のような流れで実行されます。

**オートスケーリングのフロー:**

```
ECSコンテナ
  ↓ (CPU/メモリ使用状況)
CloudWatch Metrics
  ↓ (データ収集)
CloudWatch Alarm
  ↓ (条件監視・閾値判定)
アラーム通知
  ↓ (通知)
ECS Service
  ↓ (実行)
オートスケーリング
```

**フローの詳細:**

1. ECS コンテナの CPU・メモリ使用状況がデータとして収集される
2. 収集されたデータは CloudWatch Metrics に保存される
3. CloudWatch Alarm が設定された条件に基づいてメトリクスを監視
4. 一定の条件(閾値)を満たした場合、アラームが通知を送信
5. ECS サービスが通知を受け取り、オートスケーリングを実行

> **Note:** ステップスケーリングもターゲット追跡スケーリングも、基本的に同じフローで動作します。違いは CloudWatch Alarm の条件設定部分にあります。

---

## 2. アプリケーション構成

### 2.1 システム構成図

```
ユーザー/ブラウザ
  |
  | HTTP Request
  ↓
Application Load Balancer (Port: 8080)
  |
  | リクエスト分配
  ↓
Target Group
  ├─→ ECS Task 1 (Spring Boot API - 暗号化処理)
  ├─→ ECS Task 2 (Spring Boot API - 暗号化処理)
  └─→ ECS Task 3 (Spring Boot API - 暗号化処理)
```

**構成要素:**

- **ユーザー/クライアント**: ブラウザから API を呼び出し
- **Application Load Balancer**: 複数のコンテナにリクエストを分配
- **Target Group**: オートスケールされたタスクを登録・管理
- **ECS Task**: Spring Boot で作成された Web API を提供
  - 暗号化処理により意図的に CPU 負荷を発生させる

### 2.2 ロードバランサーの内部構成

```
クライアント
  |
  | HTTP:8080
  ↓
┌─────────────────────────────────┐
│ Application Load Balancer       │
│                                 │
│  Listener (HTTP:8080)           │
│    ↓                            │
│  Target Group                   │
│    ├─→ Task 1                   │
│    ├─→ Task 2                   │
│    └─→ Task 3                   │
└─────────────────────────────────┘
```

---

## 3. 全体アーキテクチャ

### 3.1 詳細構成図

```
┌──────────────────────────────────────────────────────────────────┐
│ VPC: my-workspace-vpc                                            │
│                                                                  │
│  ユーザー/クライアント                                           │
│    ↓ HTTP Request                                               │
│  Security Group (Port: 8080)                                    │
│    ↓                                                            │
│  Application Load Balancer (my-app-autoscaling-lb)             │
│    ↓                                                            │
│  Target Group (my-app-autoscaling-tg)                          │
│    ↓                                                            │
│  Security Group (ECS Service用)                                 │
│    ↓                                                            │
│  ┌────────────────────────────────────────────────────┐        │
│  │ ECS Cluster: my-app-cluster                        │        │
│  │                                                     │        │
│  │  ECS Service (my-app-autoscaling-service)          │        │
│  │    ├─→ Task (Fargate) ←─ Task Definition          │        │
│  │    ├─→ Task (Fargate) ←─ Task Definition          │        │
│  │    └─→ Task (Fargate) ←─ Task Definition          │        │
│  │           ↓ (イメージ取得)                           │        │
│  │    ECR Repository (my-app-encryptor)                │        │
│  └────────────────────────────────────────────────────┘        │
│                                                                  │
│  Subnet: public1-a, public1-b                                   │
└──────────────────────────────────────────────────────────────────┘

【オートスケーリング監視】
ECS Service
  ↓
CloudWatch (CPU/Memory監視)
  ↓
CloudWatch Alarm
  ↓
Scaling Policy (Target Tracking)
  ↓
ECS Service (スケール実行)
```

---

## 4. 必要な AWS リソース一覧

### 4.1 ECS リソース

| リソース        | 名称                         | 備考                   |
| --------------- | ---------------------------- | ---------------------- |
| ECS Cluster     | `my-app-cluster`             | 既存のクラスターを使用 |
| ECS Service     | `my-app-autoscaling-service` | **新規作成**           |
| Task Definition | `my-app-encryptor`           | **新規作成**           |
| ECR Repository  | `my-app-encryptor`           | **新規作成**           |

### 4.2 CloudWatch

| リソース       | 名称                        | 備考                                                                       |
| -------------- | --------------------------- | -------------------------------------------------------------------------- |
| Scaling Policy | `my-app-autoscaling-policy` | **新規作成**<br/>Target Tracking Scaling Policy<br/>CPU/メモリの閾値を設定 |

### 4.3 ネットワークリソース

| リソース                    | 名称                                | 備考                                  |
| --------------------------- | ----------------------------------- | ------------------------------------- |
| VPC                         | `my-workspace-vpc`                  | 既存の VPC を使用                     |
| Subnet (AZ-a)               | `my-workspace-subnet-app-public1-a` | 既存のパブリックサブネットを使用      |
| Subnet (AZ-b)               | `my-workspace-subnet-app-public1-b` | 既存のパブリックサブネットを使用      |
| Security Group (ALB 用)     | `my-app-autoscaling-lb-sg`          | **新規作成**<br/>Port 8080 を許可     |
| Security Group (Service 用) | `my-app-autoscaling-service-sg`     | **新規作成**<br/>ALB からの通信を許可 |

### 4.4 IAM ロール

| リソース            | 名称                   | 備考               |
| ------------------- | ---------------------- | ------------------ |
| Task Execution Role | `ecsTaskExecutionRole` | 既存のロールを使用 |

### 4.5 ロードバランサー

| リソース                  | 名称                     | 備考             |
| ------------------------- | ------------------------ | ---------------- |
| Application Load Balancer | `my-app-autoscaling-alb` | **新規作成**     |
| Target Group              | `my-app-autoscaling-tg`  | **新規作成**     |
| Listener                  | HTTP:8080                | ALB 作成時に設定 |

---

## 5. 作業の流れ

### 5.1 各ステップの概要

1. **ECR リポジトリ作成**

   - Docker イメージを保存するリポジトリを作成

2. **Docker イメージビルド・プッシュ**

   - Spring Boot アプリケーションをコンテナ化
   - ECR にプッシュ

3. **Security Group 作成**

   - ALB 用: Port 8080 を許可
   - ECS Service 用: ALB からの通信を許可

4. **Target Group 作成**

   - ヘルスチェック設定を含む

5. **Application Load Balancer 作成**

   - リスナー設定(HTTP:8080)
   - Target Group との紐付け

6. **Task Definition 作成**

   - コンテナ定義
   - リソース設定(CPU/Memory)

7. **ECS Service 作成**

   - Desired count 設定
   - ネットワーク設定
   - Load Balancer との統合

8. **Auto Scaling 設定**

   - Target Tracking Scaling Policy の設定
   - CPU 使用率の閾値設定

9. **動作確認**
   - 負荷テストツールでリクエスト送信
   - スケールアウト/インの確認

---

## 6. Web API サーバーの準備

### 6.1 概要

負荷テスト用の Web API サーバーを作成します。このサーバーは、ECS タスクとして動作する Spring Boot アプリケーションで API エンドポイントを提供します。

**アプリケーションの特徴:**

- **言語**: Java + Spring Boot
- **機能**: 文字列の暗号化処理（10 万回のループ）
- **目的**: 意図的に CPU 負荷を発生させてオートスケーリングを検証
- **エンドポイント**: `GET /api/encryptor`

### 6.2 ソースコードの取得

#### 6.2.1 GitHub リポジトリ

ソースコードは以下の GitHub リポジトリで公開されています：

```
https://github.com/kentny/ecs-learning-course
```

#### 6.2.2 クローン/ダウンロード方法

```bash
git clone https://github.com/kentny/ecs-learning-course.git
cd ecs-learning-course
```

> **Note:** ブランチは `main` を使用してください。

### 6.3 ディレクトリ構造の確認

クローン後、`autoscaling-section` ディレクトリに移動します：

```bash
cd autoscaling-section
ls -la
```

**ディレクトリ構成:**

```
autoscaling-section/
├── docker-compose.yml      # Docker Compose設定ファイル
├── encryptor/              # Spring Bootアプリケーション
│   ├── src/
│   ├── Dockerfile
│   ├── build.gradle
│   └── ...
└── k6/                     # 負荷テストツール（後述）
    └── LoadTest.js
```

### 6.4 ソースコードの確認

#### 6.4.1 VS Code でプロジェクトを開く

```bash
code encryptor/
```

または、VS Code のメニューから：

1. `File` → `Open`
2. `autoscaling-section/encryptor/` を選択
3. 信頼確認ダイアログで「Yes」を選択

#### 6.4.2 API コントローラーの確認

[src/main/java/com/example/encryptor/EncryptorController.java](ecs-learning-course/autoscaling-section/encryptor/src/main/java/com/example/encryptor/controller/EncryptorController.java) を開きます。

**主要なコード:**

```java

@RestController
@RequestMapping("/api/encryptor")
public class EncryptorController {
    @GetMapping
    String get() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        SecretKey key = KeyGenerator.getInstance("AES").generateKey();
        Cipher cipher = Cipher.getInstance("AES");

        for (int i=0; i<100000; i++) {
            byte[] data = new byte[256];
            cipher.init(Cipher.ENCRYPT_MODE, key);
            cipher.doFinal(data);
        }

        return "Finish!";
    }
}
```

**処理の説明:**

- **エンドポイント**: `/api/encryptor`
- **メソッド**: GET
- **処理内容**: 暗号化処理を 10 万回ループ実行（意図的に CPU 負荷を高める）
- **レスポンス**: "Finish!" という文字列を返却

### 6.5 Dockerfile の確認

[encryptor/Dockerfile](ecs-learning-course/autoscaling-section/encryptor/Dockerfile) を開いて内容を確認します。

**Dockerfile（マルチステージビルド）:**

```dockerfile
FROM gradle:jdk21 AS build
WORKDIR /app
COPY . /app
RUN chmod +x ./gradlew && \
    ./gradlew build


FROM openjdk:21
COPY --from=build /app/build/libs/encryptor-0.0.1-SNAPSHOT.jar ./encryptor.jar
CMD [ "java", "-jar", "encryptor.jar" ]
```

**ポイント:**

1. **ビルドステージ**: Gradle を使用して Java アプリケーションをビルド
2. **実行ステージ**: ビルドされた JAR ファイルを実行環境にコピーして起動
3. **chmod +x**: Gradlew に実行権限を付与（環境によっては Permission Error が発生するため）

### 6.6 Docker Compose の確認

`autoscaling-section` ディレクトリに戻り、[docker-compose.yml](ecs-learning-course/autoscaling-section/docker-compose.yml) を確認します。

**docker-compose.yml:**

```yaml
version: "3.9"
services:
  encryptor:
    container_name: encryptor
    build: ./encryptor
    ports:
      - "8080:8080"
    healthcheck:
      test:
        ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
      start_period: 3s
      interval: 2s
      timeout: 3s
      retries: 10

  k6:
    container_name: k6
    image: grafana/k6
    entrypoint: k6 run
    command: LoadTest.js
    working_dir: /workspace
    volumes:
      - ./k6:/workspace
    depends_on:
      encryptor:
        condition: service_healthy
```

**設定内容:**

**encryptor サービス:**

- **container_name**: コンテナ名を `encryptor` に設定
- **build**: `./encryptor` ディレクトリの Dockerfile を使用してビルド
- **ports**: ホストの 8080 番ポートとコンテナの 8080 番ポートをマッピング
- **healthcheck**: ヘルスチェック設定
  - Spring Boot Actuator の `/actuator/health` エンドポイントを使用
  - `start_period: 3s` - 起動後 3 秒待機してからチェック開始
  - `interval: 2s` - 2 秒ごとにヘルスチェックを実行
  - `timeout: 3s` - タイムアウト 3 秒
  - `retries: 10` - 10 回リトライ

**k6 サービス（負荷テスト用）:**

- **container_name**: コンテナ名を `k6` に設定
- **image**: Grafana の公式 k6 イメージを使用
- **command**: `LoadTest.js` スクリプトを実行
- **volumes**: ローカルの `./k6` ディレクトリをマウント
- **depends_on**: `encryptor` サービスが healthy になってから起動

### 6.7 ローカル環境での動作確認

#### 6.7.1 アプリケーションの起動

`autoscaling-section` ディレクトリで以下のコマンドを実行します：

```bash
docker compose up encryptor
```

**起動確認:**

- Spring のロゴが表示されれば起動成功
- 初回起動時はビルドに時間がかかります

**出力例:**

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.x.x)

... Started EncryptorApplication in X.XXX seconds
```

#### 6.7.2 API の動作確認

ブラウザまたは curl で以下の URL にアクセスします：

```
http://localhost:8080/api/encryptor
```

**curl コマンドの場合:**

```bash
curl http://localhost:8080/api/encryptor
```

**期待されるレスポンス:**

```
Finish!
```

このレスポンスが返ってくれば、Web API の動作確認は完了です。

#### 6.7.3 アプリケーションの停止

ターミナルで `Ctrl + C` を押してアプリケーションを停止します。

または、別のターミナルで：

```bash
docker compose down
```

---

## 7. 負荷テストツール（k6）の設定

### 7.1 k6 の概要

オートスケーリングを実験するためには、サーバーに意図的に負荷をかけてコンテナ数が増減する様子を確認する必要があります。手動でブラウザから何度も API を呼び出すのは現実的ではないため、自動的に大量のリクエストを送信する負荷テストツールを使用します。

**負荷テストツールの選択肢:**

| ツール名 | 特徴                                                 |
| -------- | ---------------------------------------------------- |
| **k6**   | シンプルで使いやすい、オープンソース（**今回採用**） |
| JMeter   | Java 製、高機能だが設定が複雑                        |
| Gatling  | Scala 製、高性能                                     |
| Locust   | Python 製、分散負荷テストに強い                      |

**k6 の特徴:**

- Grafana Labs が提供するオープンソースツール
- JavaScript でテストシナリオを記述
- シンプルで学習コストが低い
- Docker イメージが公式提供されている
- 今回のような簡単な負荷テストに最適

### 7.2 LoadTest.js の確認と解説

#### 7.2.1 ファイルの場所

`autoscaling-section/k6/LoadTest.js` を開きます。

**VSCode での操作:**

1. エクスプローラーで `autoscaling-section` → `k6` を展開
2. `LoadTest.js` をクリックして開く

#### 7.2.2 LoadTest.js の内容

```javascript
import http from "k6/http";
import { sleep } from "k6";

export const options = {
  vus: 10,
  duration: "300s",
};

export default function () {
  http.get("http://encryptor:8080/api/encryptor");
  sleep(1);
}
```

#### 7.2.3 コードの詳細解説

**1. インポート部分:**

```javascript
import http from "k6/http";
import { sleep } from "k6";
```

- `k6/http`: HTTP リクエストを送信するためのモジュール
- `k6`: sleep（待機）などの基本機能を含むコアモジュール

**2. オプション設定:**

```javascript
export const options = {
  vus: 10,
  duration: "300s",
};
```

| パラメータ | 意味          | 設定値 | 説明                                     |
| ---------- | ------------- | ------ | ---------------------------------------- |
| `vus`      | Virtual Users | `10`   | 同時実行する仮想ユーザー数（同時接続数） |
| `duration` | Duration      | `300s` | テスト実行時間（300 秒 = 5 分間）        |

**負荷の計算:**

- 10 ユーザー × 1 秒間隔 = **約 10 RPS (Requests Per Second)**
- 300 秒間で合計 **約 3,000 リクエスト** が送信される

> **Note:** これらのパラメータは、今回のオートスケーリング検証に必要な負荷を与えられるよう事前に調整されています。

**3. テスト実行部分:**

```javascript
export default function () {
  http.get("http://encryptor:8080/api/encryptor");
  sleep(1);
}
```

- `http.get()`: 指定した URL に対して HTTP GET リクエストを送信
- `sleep(1)`: 1 秒間待機
- この関数が各仮想ユーザーごとに繰り返し実行される

#### 7.2.4 URL の説明

```javascript
http.get("http://encryptor:8080/api/encryptor");
```

**ドメイン名が `encryptor` である理由:**

Docker Compose では、同じ Compose ファイル内で定義されたサービスは、**サービス名で相互に通信できる**仕組みになっています。

**仕組みの詳細:**

1. `docker compose up` を実行すると、専用のブリッジネットワークが自動作成される
2. 各サービス（コンテナ）は同じネットワークに配置される
3. Docker の内部 DNS により、サービス名（`encryptor`）がコンテナの IP アドレスに自動解決される
4. k6 コンテナから `http://encryptor:8080` にアクセスすると、encryptor コンテナにルーティングされる

> **重要:** AWS ECS にデプロイした後は、Docker Compose を使用しないため、この URL を ALB のエンドポイントに変更する必要があります（後述）。

### 7.3 docker-compose.yml の k6 サービス詳細解説

#### 7.3.1 k6 サービスの設定

[docker-compose.yml](ecs-learning-course/autoscaling-section/docker-compose.yml) の k6 サービス部分を詳しく確認します。

```yaml
k6:
  container_name: k6
  image: grafana/k6
  entrypoint: k6 run
  command: LoadTest.js
  working_dir: /workspace
  volumes:
    - ./k6:/workspace
  depends_on:
    encryptor:
      condition: service_healthy
```

#### 7.3.2 各設定項目の詳細

**1. container_name**

```yaml
container_name: k6
```

- コンテナ名を `k6` に設定
- `docker ps` で確認する際に識別しやすくなる

**2. image**

```yaml
image: grafana/k6
```

- Grafana Labs が公式提供する k6 の Docker イメージを使用
- 自分で Dockerfile を作成する必要がない

**3. entrypoint（エントリーポイントの上書き）**

```yaml
entrypoint: k6 run
```

**エントリーポイントとは:**

Docker イメージには、デフォルトで実行されるコマンド（エントリーポイント）が定義されていることがあります。

**エントリーポイントの動作:**

```bash
# grafana/k6 イメージのデフォルトエントリーポイント: "k6"
docker run grafana/k6 version
# 実際に実行されるコマンド: k6 version
```

**上書きの理由:**

- デフォルトのエントリーポイントは `k6` のみ
- 今回は `k6 run` コマンドを実行したい
- `entrypoint: k6 run` で上書きすることで、後続の `command` が引数として渡される

**エントリーポイントの確認方法:**

```bash
docker image inspect grafana/k6
```

出力結果の中に以下のような記述があります：

```json
"Entrypoint": [
    "k6"
]
```

**4. command**

```yaml
command: LoadTest.js
```

- エントリーポイントに渡される引数
- 最終的に実行されるコマンド: `k6 run LoadTest.js`

**5. working_dir**

```yaml
working_dir: /workspace
```

- コンテナ起動時の作業ディレクトリを `/workspace` に設定
- このディレクトリ内で `LoadTest.js` が探索される

**6. volumes（バインドマウント）**

```yaml
volumes:
  - ./k6:/workspace
```

**バインドマウントとは:**

ホスト側のディレクトリとコンテナ側のディレクトリを同期させる仕組みです。

```
┌─────────────────┐      同期      ┌────────────────────┐
│ ホスト          │ ←──────────→  │ コンテナ            │
│ ./k6/           │               │ /workspace/        │
│ LoadTest.js     │               │ LoadTest.js        │
└─────────────────┘               └────────────────────┘
```

**効果:**

- ホスト側の `./k6/LoadTest.js` がコンテナ内の `/workspace/LoadTest.js` として見える
- ファイルを編集すると即座にコンテナ側に反映される
- コンテナを再ビルドする必要がない

**7. depends_on（サービス依存関係）**

```yaml
depends_on:
  encryptor:
    condition: service_healthy
```

**基本的な depends_on:**

```yaml
depends_on:
  - encryptor
```

これだけでも `encryptor` サービスが**起動してから** `k6` サービスが起動します。

**問題点:**

- 起動開始しただけで、まだ準備ができていない可能性がある
- Spring Boot の起動には数秒かかる
- k6 がリクエストを送っても、まだ API が応答できない

**condition の追加:**

```yaml
condition: service_healthy
```

- `encryptor` サービスが **healthy（健全）状態** になるまで待機
- ヘルスチェックが成功してから k6 が起動する

### 7.4 ヘルスチェックの仕組み

#### 7.4.1 encryptor サービスのヘルスチェック設定

```yaml
encryptor:
  # ... 省略 ...
  healthcheck:
    test:
      ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
    start_period: 3s
    interval: 2s
    timeout: 3s
    retries: 10
```

#### 7.4.2 ヘルスチェックの動作フロー

```
コンテナ起動
  ↓
start_period: 3秒待機
  ↓
ヘルスチェック実行 (curl -f .../actuator/health)
  ├─ 成功 → Healthy状態 → k6サービス起動
  └─ 失敗
      ├─ リトライ回数10回未満？
      │   └─ Yes → interval: 2秒待機 → ヘルスチェック再実行
      └─ リトライ回数10回以上 → Unhealthy状態
```

#### 7.4.3 各パラメータの詳細

**test コマンド:**

```yaml
test: ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
```

**分解して説明:**

1. `CMD-SHELL`: シェルコマンドを実行することを宣言
2. `curl -f http://localhost:8080/actuator/health`: 自分自身の health エンドポイントにリクエスト
3. `||`: 前のコマンドが失敗した場合に次を実行（OR 演算子）
4. `exit 1`: エラーコード 1 で終了（ヘルスチェック失敗を明示）

**curl コマンドの詳細:**

- `-f`: HTTP エラー時に失敗扱いにする（デフォルトでは HTTP エラーでも成功扱い）
- `http://localhost:8080/actuator/health`: Spring Boot Actuator のヘルスチェックエンドポイント
- コンテナ内から自分自身（localhost）にアクセス

**Spring Boot Actuator とは:**

Spring Boot の監視・管理機能を提供するモジュールで、以下のようなエンドポイントが自動生成されます：

- `/actuator/health`: アプリケーションの健全性チェック
- `/actuator/metrics`: メトリクス情報
- `/actuator/info`: アプリケーション情報

**レスポンス例:**

```json
{
  "status": "UP"
}
```

**パラメータ設定:**

| パラメータ     | 設定値 | 意味                                            |
| -------------- | ------ | ----------------------------------------------- |
| `start_period` | `3s`   | コンテナ起動後、ヘルスチェック開始まで 3 秒待機 |
| `interval`     | `2s`   | ヘルスチェックを 2 秒間隔で実行                 |
| `timeout`      | `3s`   | 1 回のヘルスチェックのタイムアウト時間          |
| `retries`      | `10`   | 失敗時に 10 回までリトライ                      |

**タイムライン例:**

```
0秒: コンテナ起動
3秒: 1回目のヘルスチェック → 失敗（まだSpring Boot起動中）
5秒: 2回目のヘルスチェック → 失敗
7秒: 3回目のヘルスチェック → 成功 → Healthy状態に
7秒: k6サービスが起動開始
```

### 7.5 ローカルでの負荷テスト実行

#### 7.5.1 Docker Compose の起動

`autoscaling-section` ディレクトリで以下のコマンドを実行します：

```bash
docker compose up
```

> **Note:** `-d`（デタッチモード）オプションは付けずに、ログをリアルタイムで確認します。

#### 7.5.2 起動プロセスの確認

**起動順序:**

```
1. ユーザー: docker compose up を実行
     ↓
2. Docker Compose: encryptorコンテナを起動
     ↓
3. encryptorコンテナ: Spring Boot起動中...
     ↓
4. ヘルスチェック: curl /actuator/health (繰り返し実行)
     ↓
5. encryptorコンテナ: Healthy状態になる
     ↓
6. Docker Compose: k6コンテナを起動
     ↓
7. k6コンテナ: 負荷テスト開始
     ↓
8. 300秒間繰り返し:
   - k6 → encryptor: GET /api/encryptor
   - encryptor → k6: レスポンス
```

#### 7.5.3 コンソール出力の確認

**1. Spring Boot の起動:**

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.x.x)

... Started EncryptorApplication in X.XXX seconds
```

**2. k6 の起動:**

```
          /\      |‾‾| /‾‾/   /‾‾/
     /\  /  \     |  |/  /   /  /
    /  \/    \    |     (   /   ‾‾\
   /          \   |  |\  \ |  (‾)  |
  / __________ \  |__| \__\ \_____/ .io

  execution: local
     script: LoadTest.js
     output: -

  scenarios: (100.00%) 1 scenario, 10 max VUs, 5m30s max duration (incl. graceful stop):
           * default: 10 looping VUs for 5m0s (gracefulStop: 30s)
```

**3. リアルタイムログ（約 1 秒ごとに更新）:**

```
running (0m05.0s), 10/10 VUs, 50 complete and 0 interrupted iterations
default ✓ [======>                               ] 10 VUs  0m05.0s/5m0s

running (0m10.0s), 10/10 VUs, 100 complete and 0 interrupted iterations
default ✓ [=========>                            ] 10 VUs  0m10.0s/5m0s
```

**ログの読み方:**

- `10/10 VUs`: 10 個の仮想ユーザーすべてが実行中
- `50 complete`: 50 回のリクエストが完了
- `0 interrupted`: 中断されたリクエストは 0 件
- プログレスバーで進行状況を表示

#### 7.5.4 負荷テストの停止

300 秒待つのは時間がかかるため、動作確認後は停止します。

**停止方法:**

```bash
Ctrl + C
```

または、別のターミナルで：

```bash
docker compose down
```

#### 7.5.5 テスト完了時の出力例

もし 300 秒間実行し続けた場合、以下のようなサマリーが表示されます：

```
     ✓ status was 200

     checks.........................: 100.00% ✓ 3000       ✗ 0
     data_received..................: 456 kB  1.5 kB/s
     data_sent......................: 270 kB  900 B/s
     http_req_blocked...............: avg=1.2ms   min=0s     med=1ms    max=50ms   p(90)=2ms    p(95)=3ms
     http_req_connecting............: avg=800µs   min=0s     med=600µs  max=30ms   p(90)=1.5ms  p(95)=2ms
     http_req_duration..............: avg=125ms   min=80ms   med=120ms  max=250ms  p(90)=150ms  p(95)=180ms
     http_req_failed................: 0.00%   ✓ 0          ✗ 3000
     http_req_receiving.............: avg=200µs   min=50µs   med=180µs  max=2ms    p(90)=300µs  p(95)=400µs
     http_req_sending...............: avg=100µs   min=30µs   med=90µs   max=1ms    p(90)=150µs  p(95)=200µs
     http_req_tls_handshaking.......: avg=0s      min=0s     med=0s     max=0s     p(90)=0s     p(95)=0s
     http_req_waiting...............: avg=124ms   min=79ms   med=119ms  max=249ms  p(90)=149ms  p(95)=179ms
     http_reqs......................: 3000    10/s
     iteration_duration.............: avg=1.12s   min=1.08s  med=1.12s  max=1.25s  p(90)=1.15s  p(95)=1.18s
     iterations.....................: 3000    10/s
     vus............................: 10      min=10       max=10
     vus_max........................: 10      min=10       max=10
```

**重要な指標:**

- `http_reqs`: 総リクエスト数（3000 回）
- `http_req_failed`: 失敗率（0%が理想）
- `http_req_duration`: レスポンスタイム（今回は暗号化処理により約 125ms）

---

## 8. ECR リポジトリの作成

### 8.1 概要

Docker イメージを保存するための ECR（Elastic Container Registry）リポジトリを作成します。このリポジトリに Spring Boot アプリケーションのコンテナイメージをプッシュし、ECS タスクがそこからイメージを取得します。

### 8.2 ECR リポジトリの作成手順

#### 8.2.1 ECR サービスへの移動

1. AWS マネジメントコンソールにログイン
2. 検索欄に「**ECR**」と入力
3. 検索結果から「**Elastic Container Registry**」を選択

#### 8.2.2 リポジトリの作成

1. 左側のメニューから「**リポジトリ**」をクリック
2. 「**リポジトリを作成**」ボタンをクリック

#### 8.2.3 リポジトリの設定

**可視性設定:**

- 「**プライベート**」を選択（デフォルト）

**リポジトリ名:**

```
my-app-encryptor
```

**その他の設定:**

- タグのイミュータビリティ: 無効（デフォルト）
- イメージスキャン設定: 無効（デフォルト）
- 暗号化設定: AES-256（デフォルト）

#### 8.2.4 リポジトリの作成実行

画面下部の「**リポジトリを作成**」ボタンをクリックします。

**確認:**

```
✓ リポジトリ "my-app-encryptor" が正常に作成されました
```

このメッセージが表示されれば、リポジトリの作成は完了です。

---

## 9. Docker イメージのビルドとプッシュ

### 9.1 概要

作成した ECR リポジトリに対して、Spring Boot アプリケーションの Docker イメージをビルドしてプッシュします。

### 9.2 プッシュコマンドの表示

#### 9.2.1 リポジトリの詳細画面へ移動

1. リポジトリ一覧から「**my-app-encryptor**」をクリック
2. 現時点では「**イメージがありません**」と表示されているはず

#### 9.2.2 プッシュコマンドの確認

画面右上の「**プッシュコマンドの表示**」ボタンをクリックします。

**表示される内容:**

- macOS/Linux 用のコマンド
- Windows 用のコマンド

それぞれのタブで、4 つのステップが表示されます：

1. **認証トークンを取得**（Docker クライアントを ECR レジストリに対して認証）
2. **Docker イメージをビルド**
3. **イメージにタグ付け**
4. **イメージをプッシュ**

### 9.3 ターミナルでの作業準備

#### 9.3.1 作業ディレクトリへの移動

ターミナルを開き、以下のディレクトリに移動します：

```bash
cd ecs-learning-course/autoscaling-section/encryptor
```

**確認:**

```bash
ls -la
```

**期待される出力:**

```
Dockerfile
build.gradle
src/
...
```

Dockerfile が存在することを確認してください。

### 9.4 各コマンドの実行

#### 9.4.1 ステップ 1: Docker ログイン

**コマンドの説明:**

ECR リポジトリに対してイメージをプッシュするための認証を行います。

**実行:**

プッシュコマンド画面の「**ステップ 1**」のコマンドをコピーして実行します。

**コマンド例（リージョン: us-west-2 の場合）:**

```bash
aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin <AWS_ACCOUNT_ID>.dkr.ecr.us-west-2.amazonaws.com
```

> **Note:** `<AWS_ACCOUNT_ID>` は自動的にあなたのアカウント ID に置き換わります。

**期待される出力:**

```
Login Succeeded
```

このメッセージが表示されれば、認証成功です。

#### 9.4.2 ステップ 2: Docker イメージのビルド

**コマンドの説明:**

Dockerfile を使用して Docker イメージをビルドします。

**実行:**

プッシュコマンド画面の「**ステップ 2**」のコマンドをコピーして実行します。

**コマンド例:**

```bash
docker build -t my-app-encryptor .
```

**ビルドプロセス:**

```
[+] Building 120.5s (15/15) FINISHED
 => [internal] load build definition from Dockerfile
 => [internal] load .dockerignore
 => [build 1/4] FROM docker.io/library/gradle:jdk21
 => [build 2/4] WORKDIR /app
 => [build 3/4] COPY . /app
 => [build 4/4] RUN chmod +x ./gradlew && ./gradlew build
 => [stage-1 1/2] FROM docker.io/library/openjdk:21
 => [stage-1 2/2] COPY --from=build /app/build/libs/encryptor-0.0.1-SNAPSHOT.jar ./encryptor.jar
 => exporting to image
 => => writing image sha256:xxxxx...
 => => naming to docker.io/library/my-app-encryptor
```

**所要時間:**

- 初回: 約 2〜5 分（依存関係のダウンロードとビルド）
- 2 回目以降: キャッシュにより短縮される

**確認:**

```bash
docker image ls
```

**期待される出力:**

```
REPOSITORY          TAG       IMAGE ID       CREATED          SIZE
my-app-encryptor    latest    xxxxxxxxxxxxx  10 seconds ago   500MB
```

#### 9.4.3 ステップ 3: イメージにタグ付け

**コマンドの説明:**

ビルドしたイメージに ECR リポジトリ用のタグを付けます。

**実行:**

プッシュコマンド画面の「**ステップ 3**」のコマンドをコピーして実行します。

**コマンド例:**

```bash
docker tag my-app-encryptor:latest <AWS_ACCOUNT_ID>.dkr.ecr.us-west-2.amazonaws.com/my-app-encryptor:latest
```

**確認:**

```bash
docker images | grep my-app-encryptor
```

**期待される出力:**

```
my-app-encryptor                                          latest    xxxxxxxxxxxxx   2 minutes ago   500MB
<AWS_ACCOUNT_ID>.dkr.ecr.us-west-2.amazonaws.com/my-app-encryptor   latest    xxxxxxxxxxxxx   2 minutes ago   500MB
```

同じイメージ ID に対して 2 つのタグが付いていることを確認できます。

#### 9.4.4 ステップ 4: イメージをプッシュ

**コマンドの説明:**

タグ付けしたイメージを ECR リポジトリにプッシュします。

**実行:**

プッシュコマンド画面の「**ステップ 4**」のコマンドをコピーして実行します。

**コマンド例:**

```bash
docker push <AWS_ACCOUNT_ID>.dkr.ecr.us-west-2.amazonaws.com/my-app-encryptor:latest
```

**プッシュプロセス:**

```
The push refers to repository [<AWS_ACCOUNT_ID>.dkr.ecr.us-west-2.amazonaws.com/my-app-encryptor]
5f70bf18a086: Pushed
8d3ac3489996: Pushed
9b9b7f3d56a0: Pushed
f1b5933fe4b5: Pushed
latest: digest: sha256:xxxxx... size: 1234
```

**所要時間:**

- ネットワーク速度により約 1〜3 分

### 9.5 プッシュの確認

#### 9.5.1 AWS コンソールでの確認

1. ECR の「**リポジトリ**」画面に戻る
2. 「**my-app-encryptor**」リポジトリをクリック
3. 画面を更新（F5 キー）

**確認内容:**

| 項目       | 値                      |
| ---------- | ----------------------- |
| イメージタグ | `latest`                |
| プッシュ日時 | 現在時刻                |
| イメージサイズ | 約 500MB                |
| 脆弱性      | スキャン設定に応じて表示 |

イメージが 1 つ表示されていれば、プッシュ成功です。

#### 9.5.2 イメージ URI の確認

後で使用するため、イメージ URI をメモしておきます。

**URI の取得方法:**

1. イメージ一覧で「**latest**」タグの行を確認
2. 「**URI**」列の「コピー」アイコンをクリック

**URI の形式:**

```
<AWS_ACCOUNT_ID>.dkr.ecr.us-west-2.amazonaws.com/my-app-encryptor:latest
```

---

## 10. ECS タスク定義の作成

### 10.1 概要

ECS タスク定義は、コンテナの設定を定義するテンプレートです。ここでは、使用するイメージ、CPU・メモリのリソース配分、ポートマッピングなどを設定します。

### 10.2 タスク定義の作成手順

#### 10.2.1 ECS サービスへの移動

1. AWS マネジメントコンソールの検索欄に「**ECS**」と入力
2. 「**Elastic Container Service**」を選択

#### 10.2.2 タスク定義の作成開始

1. 左側のメニューから「**タスク定義**」をクリック
2. 「**新しいタスク定義の作成**」ボタンをクリック

### 10.3 タスク定義の設定

#### 10.3.1 基本設定

**タスク定義ファミリー:**

```
my-app-encryptor
```

**説明（オプション）:**

```
Spring Boot暗号化APIのタスク定義
```

#### 10.3.2 インフラストラクチャ要件

**起動タイプ:**

- **AWS Fargate** を選択

**オペレーティングシステム/アーキテクチャ:**

- OS: **Linux**
- アーキテクチャ: **X86_64**

**タスクサイズ:**

| リソース | 設定値    | 説明                     |
| -------- | --------- | ------------------------ |
| CPU      | **0.25 vCPU** | 最小サイズ（コスト最適化） |
| メモリ   | **1 GB**      | 安定動作のため 1GB を選択 |

> **Note:** CPU を 0.25 vCPU にすると、選択可能なメモリは 0.5GB、1GB、2GB です。今回は 1GB を選択します。

#### 10.3.3 タスクロール

**タスク実行ロール:**

- 「**ecsTaskExecutionRole**」を選択

> **Important:** このロールが存在しない場合は、以下の手順で作成してください。

**ecsTaskExecutionRole が存在しない場合の作成手順:**

1. IAM コンソールを開く
2. 「**ロール**」→「**ロールを作成**」
3. 信頼されたエンティティ: **Elastic Container Service**
4. ユースケース: **Elastic Container Service Task**
5. ポリシー: **AmazonECSTaskExecutionRolePolicy**
6. ロール名: `ecsTaskExecutionRole`

**ecsTaskExecutionRole の権限確認:**

このロールには以下のポリシーがアタッチされている必要があります：

- **AmazonECSTaskExecutionRolePolicy**（AWS 管理ポリシー）

**ポリシーの内容:**

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ecr:GetAuthorizationToken",
        "ecr:BatchCheckLayerAvailability",
        "ecr:GetDownloadUrlForLayer",
        "ecr:BatchGetImage",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "*"
    }
  ]
}
```

**タスクロール:**

- 空白のまま（今回は不要）

> **Note:** タスクロールは、コンテナ内のアプリケーションが AWS サービスにアクセスする際に必要です。今回のアプリケーションは AWS サービスを使用しないため不要です。

### 10.4 コンテナの設定

#### 10.4.1 コンテナの追加

**コンテナ名:**

```
encryptor
```

**イメージ URI:**

先ほどコピーした ECR イメージの URI を貼り付けます。

```
<AWS_ACCOUNT_ID>.dkr.ecr.us-west-2.amazonaws.com/my-app-encryptor:latest
```

**重要なポートの設定:**

| 項目                     | 設定値       |
| ------------------------ | ------------ |
| コンテナポート           | **8080**     |
| プロトコル               | **TCP**      |
| ポート名（オプション）   | http         |
| アプリケーションプロトコル | **HTTP**     |

#### 10.4.2 環境変数（オプション）

今回は環境変数の設定は不要です。

#### 10.4.3 リソース制限

タスクレベルで設定済みのため、個別のコンテナレベルでは設定不要です。

#### 10.4.4 ヘルスチェック（オプション）

ここでは設定せず、後でロードバランサーのターゲットグループ側で設定します。

### 10.5 ログ収集の設定

#### 10.5.1 ログ設定の有効化

「**ログ収集を使用する**」にチェックを入れます。

**ログドライバー:**

- **awslogs**（デフォルト）

**ログ設定:**

以下が自動的に設定されます：

```
awslogs-group: /ecs/my-app-encryptor
awslogs-region: us-west-2
awslogs-stream-prefix: ecs
```

> **Note:** CloudWatch Logs にログが自動的に送信されます。ロググループが存在しない場合は自動作成されます。

### 10.6 タスク定義の作成完了

#### 10.6.1 設定の確認

画面下部までスクロールし、以下を確認します：

- ストレージ: デフォルト（20GB の一時ストレージ）
- モニタリングとロギング: ログ収集が有効
- タグ: 任意（設定不要）

#### 10.6.2 作成の実行

「**作成**」ボタンをクリックします。

**確認メッセージ:**

```
✓ タスク定義 "my-app-encryptor:1" が正常に作成されました
```

**リビジョン番号:**

- 初回作成: **リビジョン 1**
- 以降、更新するたびにリビジョン番号が増加

---

## 11. ロードバランサーの作成

### 11.1 概要

Application Load Balancer（ALB）を作成し、複数の ECS タスクにトラフィックを分散します。オートスケーリング時に増減するタスクを自動的にターゲットとして管理します。

### 11.2 作成の流れ

1. **セキュリティグループ（ALB 用）の作成**
2. **ターゲットグループの作成**
3. **Application Load Balancer の作成**

### 11.3 ALB 用セキュリティグループの作成

#### 11.3.1 セキュリティグループサービスへの移動

1. AWS マネジメントコンソールの検索欄に「**セキュリティグループ**」と入力
2. 「**EC2 の機能 - セキュリティグループ**」を選択

または：

1. 「**EC2**」で検索
2. 左側メニューの「**ネットワーク & セキュリティ**」→「**セキュリティグループ**」

#### 11.3.2 セキュリティグループの作成

「**セキュリティグループを作成**」ボタンをクリックします。

#### 11.3.3 基本設定

**セキュリティグループ名:**

```
my-app-autoscaling-alb-sg
```

**説明:**

```
my-app-autoscaling-alb-sg
```

> **Note:** 本来はより説明的な内容を記述すべきですが、今回は名前と同じものを設定します。

**VPC:**

```
my-workspace-vpc
```

#### 11.3.4 インバウンドルールの設定

「**インバウンドルールを追加**」をクリックします。

**ルール設定:**

| 項目   | 設定値                  | 説明                                       |
| ------ | ----------------------- | ------------------------------------------ |
| タイプ | **カスタム TCP**        | -                                          |
| ポート | **8080**                | Spring Boot のポート                       |
| ソース | **0.0.0.0/0** (Anywhere IPv4) | すべての IPv4 アドレスからのアクセスを許可 |

**セキュリティ上の注意:**

> **Warning:** 本番環境では、特定の IP アドレス範囲のみを許可することを推奨します。例えば、自分の端末の IP アドレスのみを許可するなど。

**本番環境での推奨設定例:**

```
ソース: マイIP（自動検出）
```

または：

```
ソース: <your-ip-address>/32
```

#### 11.3.5 アウトバウンドルールの設定

デフォルトのままでOKです。

**デフォルト設定:**

| タイプ      | プロトコル | ポート範囲 | 送信先      |
| ----------- | ---------- | ---------- | ----------- |
| すべての通信 | すべて     | すべて     | 0.0.0.0/0   |

#### 11.3.6 作成の実行

「**セキュリティグループを作成**」ボタンをクリックします。

**確認:**

```
✓ セキュリティグループ "my-app-autoscaling-alb-sg" (sg-xxxxx) が正常に作成されました
```

### 11.4 ターゲットグループの作成

#### 11.4.1 ターゲットグループサービスへの移動

1. AWS マネジメントコンソールの検索欄に「**ターゲットグループ**」と入力
2. 「**EC2 の機能 - ターゲットグループ**」を選択

または：

1. 左側メニューの「**ロードバランシング**」→「**ターゲットグループ**」

#### 11.4.2 ターゲットグループの作成開始

「**ターゲットグループの作成**」ボタンをクリックします。

#### 11.4.3 基本的な設定

**ターゲットタイプの選択:**

- **IP アドレス** を選択

> **Note:** ECS Fargate のタスクは動的に IP アドレスが割り当てられるため、「IP アドレス」タイプを選択します。

**ターゲットグループ名:**

```
my-app-autoscaling-tg
```

**プロトコル:**

- **HTTP**

**ポート:**

```
8080
```

**IP アドレスタイプ:**

- **IPv4**

**VPC:**

```
my-workspace-vpc
```

**プロトコルバージョン:**

- **HTTP1**

#### 11.4.4 ヘルスチェックの設定

**ヘルスチェックプロトコル:**

- **HTTP**

**ヘルスチェックパス:**

```
/actuator/health
```

> **Important:** Spring Boot Actuator のヘルスチェックエンドポイントを使用します。このエンドポイントは、アプリケーションが正常に動作しているかを確認します。

**詳細設定（デフォルトのまま）:**

| 項目                   | 設定値 | 説明                               |
| ---------------------- | ------ | ---------------------------------- |
| 正常のしきい値         | 5      | 連続 5 回成功で Healthy と判定     |
| 非正常のしきい値       | 2      | 連続 2 回失敗で Unhealthy と判定   |
| タイムアウト           | 5 秒   | ヘルスチェックのタイムアウト時間   |
| 間隔                   | 30 秒  | ヘルスチェックの実行間隔           |
| 成功コード             | 200    | HTTP ステータスコード 200 で成功   |

#### 11.4.5 ターゲットの登録

「**次へ**」をクリックして、ターゲット登録画面に進みます。

**重要:**

現時点では ECS タスクがまだ起動していないため、ターゲットを登録しません。

- 「**使用可能なインスタンス**」は空のまま
- 何も選択せずに次へ進む

#### 11.4.6 作成の実行

「**ターゲットグループの作成**」ボタンをクリックします。

**確認:**

```
✓ ターゲットグループ "my-app-autoscaling-tg" が正常に作成されました
```

**ターゲットグループの状態:**

- **登録済みターゲット**: 0
- **ヘルスステータス**: ターゲットなし

> **Note:** ECS サービス作成時に、タスクが自動的にこのターゲットグループに登録されます。

### 11.5 Application Load Balancer の作成

#### 11.5.1 ロードバランサーサービスへの移動

1. AWS マネジメントコンソールの検索欄に「**ロードバランサー**」と入力
2. 「**EC2 の機能 - ロードバランサー**」を選択

または：

1. 左側メニューの「**ロードバランシング**」→「**ロードバランサー**」

#### 11.5.2 ロードバランサーの作成開始

1. 「**ロードバランサーの作成**」ボタンをクリック
2. 「**Application Load Balancer**」の「**作成**」ボタンをクリック

#### 11.5.3 基本的な設定

**ロードバランサー名:**

```
my-app-autoscaling-alb
```

**スキーム:**

- **インターネット向け** を選択

> **Note:** 外部（インターネット）からアクセス可能な ALB を作成します。

**IP アドレスタイプ:**

- **IPv4**

#### 11.5.4 ネットワークマッピング

**VPC:**

```
my-workspace-vpc
```

**アベイラビリティゾーン:**

少なくとも 2 つの AZ を選択する必要があります。

| アベイラビリティゾーン | サブネット                            |
| ---------------------- | ------------------------------------- |
| **us-west-2a**         | `my-workspace-subnet-app-public1-a` |
| **us-west-2b**         | `my-workspace-subnet-app-public1-b` |

> **Important:** 必ず**パブリックサブネット**を選択してください。インターネット向け ALB はパブリックサブネットに配置する必要があります。

#### 11.5.5 セキュリティグループの設定

**デフォルトセキュリティグループの削除:**

- デフォルトで選択されている `default` セキュリティグループのチェックを外す

**作成したセキュリティグループの選択:**

1. ドロップダウンから「**my-app-autoscaling-alb-sg**」を選択
2. または、更新アイコン（🔄）をクリックして最新のリストを取得

#### 11.5.6 リスナーとルーティング

**リスナーの設定:**

| 項目           | 設定値                   |
| -------------- | ------------------------ |
| プロトコル     | **HTTP**                 |
| ポート         | **8080**                 |
| デフォルトアクション | ターゲットグループに転送 |
| ターゲットグループ | `my-app-autoscaling-tg` |

**設定手順:**

1. デフォルトで HTTP:80 のリスナーが設定されている場合、ポートを **8080** に変更
2. 「**デフォルトアクション**」で「**ターゲットグループに転送**」を選択
3. ターゲットグループのドロップダウンから「**my-app-autoscaling-tg**」を選択

> **Note:** リスナーは、指定されたポートで受信したリクエストを監視し、ターゲットグループにルーティングします。

#### 11.5.7 その他の設定

以下の項目はデフォルトのままで問題ありません：

- **モニタリング**: 有効（CloudWatch メトリクス）
- **アクセスログ**: 無効（必要に応じて有効化）
- **削除保護**: 無効

#### 11.5.8 作成の実行

画面下部の「**ロードバランサーの作成**」ボタンをクリックします。

**確認メッセージ:**

```
✓ ロードバランサー "my-app-autoscaling-alb" が正常に作成されました
```

**プロビジョニング:**

```
状態: プロビジョニング中
```

ロードバランサーの作成には数分かかります。

**確認方法:**

1. ロードバランサー一覧画面で `my-app-autoscaling-alb` を確認
2. 「**状態**」列が「**アクティブ**」になるまで待機（約 2〜3 分）

#### 11.5.9 DNS 名の確認

**ALB の DNS 名:**

ロードバランサーの詳細画面で「**DNS 名**」を確認します。

**形式:**

```
my-app-autoscaling-alb-xxxxxxxxxx.us-west-2.elb.amazonaws.com
```

> **Note:** この DNS 名を使用して ALB にアクセスします。後で動作確認時に使用するため、メモしておいてください。

---

## 12. ECS サービスの作成

### 12.1 概要

ECS サービスは、指定された数のタスクを常時実行し、ロードバランサーと統合してトラフィックを分散します。オートスケーリングの基盤となる重要なコンポーネントです。

### 12.2 サービス作成前の準備確認

以下のリソースが作成済みであることを確認してください：

- ✓ ECR リポジトリ: `my-app-encryptor`
- ✓ Docker イメージ: ECR にプッシュ済み
- ✓ タスク定義: `my-app-encryptor:1`
- ✓ Application Load Balancer: `my-app-autoscaling-alb`（状態: アクティブ）
- ✓ ターゲットグループ: `my-app-autoscaling-tg`
- ✓ セキュリティグループ（ALB 用）: `my-app-autoscaling-alb-sg`

### 12.3 ECS サービスの作成手順

#### 12.3.1 クラスターへの移動

1. ECS コンソールの左側メニューから「**クラスター**」をクリック
2. 既存のクラスター「**my-app-cluster**」をクリック

#### 12.3.2 サービスの作成開始

1. 「**サービス**」タブを確認（現時点では空のはず）
2. 「**作成**」ボタンをクリック

### 12.4 環境設定

#### 12.4.1 コンピューティング設定

**起動タイプ:**

- **起動タイプ** を選択（容量プロバイダーではない）
- 起動タイプ: **FARGATE**

#### 12.4.2 デプロイ設定

**アプリケーションタイプ:**

- **サービス** を選択

> **Note:** オートスケーリングを使用する場合は「サービス」を選択します。

**タスク定義:**

| 項目           | 設定値               |
| -------------- | -------------------- |
| ファミリー     | `my-app-encryptor`   |
| リビジョン     | **1**（最新）        |

**サービス名:**

```
my-app-autoscaling-service
```

**サービスタイプ:**

- **レプリカ** を選択

**必要なタスク:**

```
1
```

> **Note:** 初期状態では 1 タスクのみ起動します。オートスケーリング設定後に自動的に増減します。

#### 12.4.3 デプロイオプション

デフォルトのままでOKです。

| 項目                 | 設定値               |
| -------------------- | -------------------- |
| デプロイタイプ       | ローリングアップデート |
| 最小ヘルシーパーセント | 100                  |
| 最大パーセント       | 200                  |

### 12.5 ネットワーキング設定

#### 12.5.1 VPC とサブネット

**VPC:**

```
my-workspace-vpc
```

**サブネット:**

**重要:** パブリックサブネットのみを選択してください。

選択するサブネット:
- ✓ `my-workspace-subnet-app-public1-a`
- ✓ `my-workspace-subnet-app-public1-b`

選択しないサブネット:
- ✗ プライベートサブネット

**パブリックサブネットを選択する理由:**

1. **ECR へのアクセス**: ECS タスクは ECR からイメージをダウンロードする必要があります
2. **ECR のエンドポイント**: ECR はパブリックなエンドポイントを持ちます
3. **パブリック IP**: パブリックサブネット + パブリック IP により、外部（ECR）との通信が可能になります

> **Note (高度な設定):** NAT Gateway や VPC エンドポイントを使用すれば、プライベートサブネットからでも ECR にアクセス可能ですが、今回は説明を簡略化するためパブリックサブネットを使用します。

#### 12.5.2 セキュリティグループの作成

**新しいセキュリティグループの作成:**

- 「**新しいセキュリティグループを作成する**」を選択

**セキュリティグループ名:**

```
my-app-autoscaling-service-sg
```

**説明:**

```
my-app-autoscaling-service-sg
```

**インバウンドルール（仮設定）:**

| 項目   | 設定値                        |
| ------ | ----------------------------- |
| タイプ | **カスタム TCP**              |
| ポート | **8080**                      |
| ソース | **0.0.0.0/0** (Anywhere IPv4) |

> **Warning:** この設定は一時的なものです。後ほど、ALB からのトラフィックのみを許可するように変更します。

**アウトバウンドルール:**

デフォルトのまま（すべての送信先を許可）。

#### 12.5.3 パブリック IP

**パブリック IP の割り当て:**

- **オン** にする

**パブリック IP が必要な理由:**

1. **ECR へのアクセス**: タスクが ECR からイメージをプルするため
2. **インターネットゲートウェイ**: パブリックサブネット + パブリック IP により、インターネットゲートウェイ経由で ECR にアクセス
3. **ログ送信**: CloudWatch Logs へのログ送信にも必要

**構成図:**

```
ECS Task (Public Subnet)
  ↓ (Public IP経由)
Internet Gateway
  ↓
ECR (パブリックエンドポイント)
```

> **Note (高度な設定):** NAT Gateway を使用すれば、プライベートサブネット + パブリック IP なしでも外部にアクセス可能ですが、追加コストがかかります。

### 12.6 ロードバランシング設定

#### 12.6.1 ロードバランサーの選択

**ロードバランサータイプ:**

- **Application Load Balancer** を選択

**既存のロードバランサーを使用:**

- **既存のロードバランサーを使用する** を選択

**ロードバランサーの選択:**

ドロップダウンから以下を選択します：

```
my-app-autoscaling-alb
```

> **Note:** 事前に作成した ALB を使用します。

#### 12.6.2 リスナーの設定

**コンテナの選択:**

自動的に以下が選択されているはずです：

```
encryptor 8080:8080
```

**リスナーの選択:**

- **既存のリスナーを使用する** を選択

| 項目       | 設定値   |
| ---------- | -------- |
| プロトコル | **HTTP** |
| ポート     | **8080** |

> **Note:** ALB 作成時に設定したリスナーが自動的に選択されます。

#### 12.6.3 ターゲットグループの設定

**ターゲットグループの選択:**

- **既存のターゲットグループを使用する** を選択

**ターゲットグループ名:**

ドロップダウンから以下を選択します：

```
my-app-autoscaling-tg
```

**ヘルスチェック設定の確認:**

以下が自動的に表示されます：

| 項目                 | 設定値             |
| -------------------- | ------------------ |
| ヘルスチェックパス   | `/actuator/health` |
| ヘルスチェック猶予期間 | 0 秒               |

**ヘルスチェック猶予期間:**

デフォルトの **0 秒** のままでOKです。

> **Note:** ヘルスチェック猶予期間は、タスク起動後、ヘルスチェックの失敗を無視する期間です。今回は Spring Boot の起動が比較的速いため、0 秒で問題ありません。

### 12.7 サービスコネクトとサービス検出

これらの機能は今回使用しません。

- **サービスコネクト**: オフ
- **サービス検出**: オフ

### 12.8 オートスケーリング設定（後で設定）

この段階ではオートスケーリングを設定しません。

- 「**オートスケーリングを使用しない**」を選択

> **Note:** サービス作成後、別途オートスケーリングを設定します。

### 12.9 サービスの作成実行

#### 12.9.1 設定の確認

画面下部までスクロールし、以下を確認します：

- ✓ タスク定義: `my-app-encryptor:1`
- ✓ サービス名: `my-app-autoscaling-service`
- ✓ 必要なタスク: 1
- ✓ VPC: `my-workspace-vpc`
- ✓ サブネット: パブリックサブネット 2 つ
- ✓ ロードバランサー: `my-app-autoscaling-alb`
- ✓ ターゲットグループ: `my-app-autoscaling-tg`

#### 12.9.2 作成ボタンのクリック

「**作成**」ボタンをクリックします。

**確認メッセージ:**

```
✓ サービス "my-app-autoscaling-service" が正常に作成されました
```

### 12.10 サービスの起動確認

#### 12.10.1 サービスステータスの確認

サービス詳細画面で以下を確認します：

**デプロイメント:**

```
状態: 進行中 → 完了
```

**タスク:**

```
実行中のタスク数: 0 → 1
```

#### 12.10.2 タスクの起動プロセス

タスクが起動するまでのフロー：

```
1. PROVISIONING (プロビジョニング中)
   ↓
2. PENDING (保留中) - ENIの割り当て、IPアドレスの割り当て
   ↓
3. ACTIVATING (アクティベーション中) - コンテナの起動開始
   ↓
4. RUNNING (実行中) - コンテナ起動完了
```

所要時間: 約 2〜3 分

#### 12.10.3 タスクの詳細確認

1. 「**タスク**」タブをクリック
2. 実行中のタスクをクリック

**確認項目:**

| 項目                 | 確認内容                 |
| -------------------- | ------------------------ |
| **タスクステータス** | `RUNNING`                |
| **ヘルスステータス** | `HEALTHY`                |
| **パブリック IP**    | 割り当てられた IP を確認 |
| **プライベート IP**  | 割り当てられた IP を確認 |

#### 12.10.4 ログの確認

**CloudWatch Logs での確認:**

1. タスク詳細画面で「**ログ**」タブをクリック
2. または、CloudWatch コンソールから `/ecs/my-app-encryptor` ロググループを開く

**期待されるログ:**

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.x.x)

... Started EncryptorApplication in X.XXX seconds (process running for Y.YYY)
```

この出力が確認できれば、Spring Boot アプリケーションが正常に起動しています。

---

## 13. セキュリティグループの修正

### 13.1 概要

現在、ECS サービスのセキュリティグループは、すべての IP アドレスからのアクセスを許可する設定になっています。これをより安全な設定に変更し、**ALB からのトラフィックのみ**を許可するようにします。

### 13.2 修正が必要な理由

**現在の設定の問題点:**

```
インターネット (0.0.0.0/0)
  ↓ (直接アクセス可能)
ECS Task
```

- 誰でも直接 ECS タスクにアクセス可能
- ALB を経由せずにタスクに到達できてしまう
- セキュリティリスクが高い

**修正後の理想的な構成:**

```
インターネット
  ↓
ALB (my-app-autoscaling-alb-sg)
  ↓ (ALBからのみ許可)
ECS Task (my-app-autoscaling-service-sg)
```

- ALB 経由でのみアクセス可能
- セキュリティグループによる制御
- より安全な構成

### 13.3 セキュリティグループの修正手順

#### 13.3.1 セキュリティグループの確認

1. EC2 コンソールの左側メニューから「**セキュリティグループ**」をクリック
2. `my-app-autoscaling-service-sg` を検索して選択

#### 13.3.2 現在のインバウンドルールの確認

**インバウンドルール**タブで以下が設定されているはずです：

| タイプ       | プロトコル | ポート範囲 | ソース      | 説明 |
| ------------ | ---------- | ---------- | ----------- | ---- |
| カスタム TCP | TCP        | 8080       | 0.0.0.0/0   | -    |

#### 13.3.3 インバウンドルールの編集

1. 「**インバウンドルールを編集**」ボタンをクリック
2. 既存のルール（0.0.0.0/0）の「**削除**」ボタンをクリック
3. 「**ルールを追加**」ボタンをクリック

#### 13.3.4 新しいルールの設定

**新しいインバウンドルール:**

| 項目   | 設定値                           |
| ------ | -------------------------------- |
| タイプ | **カスタム TCP**                 |
| ポート | **8080**                         |
| ソース | **カスタム**                     |
| ソース値 | `my-app-autoscaling-alb-sg` を選択 |

**ソース値の入力方法:**

テキストボックスに「sg-」と入力すると、利用可能なセキュリティグループが表示されます。

または：

1. セキュリティグループ ID を直接入力
2. 例: `sg-0123456789abcdef0`

**説明（オプション）:**

```
Allow traffic from ALB only
```

#### 13.3.5 ルールの保存

「**ルールを保存**」ボタンをクリックします。

**確認メッセージ:**

```
✓ セキュリティグループのルールが正常に更新されました
```

### 13.4 修正内容の確認

#### 13.4.1 更新後のインバウンドルール

| タイプ       | プロトコル | ポート範囲 | ソース                              | 説明                      |
| ------------ | ---------- | ---------- | ----------------------------------- | ------------------------- |
| カスタム TCP | TCP        | 8080       | sg-xxxxx (my-app-autoscaling-alb-sg) | Allow traffic from ALB only |

#### 13.4.2 セキュリティ構成の確認

**修正後のトラフィックフロー:**

```
┌──────────────┐
│ インターネット │
└──────┬───────┘
       │ HTTP:8080
       ↓
┌──────────────────────────────┐
│ ALB                          │
│ SG: my-app-autoscaling-alb-sg │
│ (0.0.0.0/0からポート8080許可) │
└──────┬───────────────────────┘
       │ HTTP:8080
       │ (ALBのSGからのみ許可)
       ↓
┌─────────────────────────────────┐
│ ECS Task                        │
│ SG: my-app-autoscaling-service-sg│
│ (ALBからのみポート8080許可)      │
└─────────────────────────────────┘
```

**セキュリティの改善点:**

- ✓ 直接的な外部アクセスをブロック
- ✓ ALB 経由のトラフィックのみ許可
- ✓ セキュリティグループによる制御
- ✓ ネットワークレベルでの保護

---

### 12.7 サービスの自動スケーリング設定

サービスの作成を続けて、自動スケーリングの設定を行います。

#### 12.7.1 自動スケーリングの有効化

**サービスの自動スケーリング:**

画面を下にスクロールして、**サービスの自動スケーリング** セクションに移動します。

- **サービスの自動スケーリングの使用** をチェック ✓

#### 12.7.2 タスク数の設定

自動スケーリングを有効にすると、タスクの最小数と最大数を設定できます。

**タスクの最小数:**

```
1
```

- これはタスクの下限値です
- オートスケーリングでどんなに負荷が低くなっても、この数より少なくなることはありません
- 最低1個はタスクが動いている状態を保証します

**タスクの最大数:**

```
4
```

- これはタスクの上限値です
- どんなに負荷が高くなっても、この数を超えてスケールアウトすることはありません

#### 12.7.3 スケーリングポリシーのタイプ選択

**スケーリングポリシーのタイプ:**

2つのオプションがあります：

| オプション         | 説明                                                               |
| ------------------ | ------------------------------------------------------------------ |
| ターゲット追跡     | 指定したメトリクスの目標値を維持するように自動的にスケールする     |
| ステップスケーリング | メトリクスの値に応じて、段階的にスケール量を細かく制御できる       |

今回は **ターゲット追跡** を選択します。

> **💡 推奨:** 基本的には「ターゲット追跡」を選択することをおすすめします。シンプルで設定しやすく、多くのユースケースに対応できます。

> **📝 補足:** 「ステップスケーリング」は、CPU使用率に応じて「50%なら1個増やす」「70%なら3個増やす」といった細かい段階的な設定が可能です。より高度な制御が必要な場合に使用します。

#### 12.7.4 ターゲット追跡スケーリングポリシーの設定

**ポリシー名:**

```
my-app-autoscaling-policy
```

**サービスメトリクス:**

3つのオプションから選択できます：

| メトリクス                      | 説明                                                     |
| ------------------------------- | -------------------------------------------------------- |
| ECSServiceAverageCPUUtilization | CPU使用率に基づいてスケーリング                          |
| ECSServiceAverageMemoryUtilization | メモリ使用率に基づいてスケーリング                    |
| ALBRequestCountPerTarget        | 1つのタスクあたりのリクエスト数に基づいてスケーリング    |

今回は **ECSServiceAverageCPUUtilization** を選択します。

> **📝 補足:** ALBRequestCountPerTargetは、コンテナの数を増やすことでリクエストが分散され、1タスクあたりのリクエスト数を下げるアプローチです。

**ターゲット値:**

```
50
```

- CPU使用率を50%に維持するようにスケーリングします
- CPU使用率が50%を超えるとスケールアウト(増加)
- CPU使用率が50%を下回るとスケールイン(減少)

#### 12.7.5 クールダウン期間の設定

**スケールアウトクールダウン期間:**

```
15
```

単位: 秒

**スケールインクールダウン期間:**

```
15
```

単位: 秒

> **📝 クールダウン期間とは:**
> スケーリングアクションの実行後、次のスケーリングアクションを開始するまでの待機時間です。頻繁なスケーリングを防ぎ、システムを安定させるために使用します。

#### 12.7.6 スケールインの制御

**スケールインをオフにする:**

このオプションは **チェックしません** (オフのまま)

**スケールインをオフにする機能について:**

| 設定         | 動作                                                           |
| ------------ | -------------------------------------------------------------- |
| チェックなし | スケールアウト・スケールイン両方が有効(通常の自動スケーリング) |
| チェックあり | スケールアウトのみ有効(タスクは増えるが減らない)               |

**ユースケース:**

- **チェックなし(推奨):** コストと性能のバランスを取る。負荷に応じて柔軟にスケール
- **チェックあり:** コスト度外視で性能重視。一度増やしたタスクは減らさず、突発的な負荷に備える

> **⚠️ 注意:** スケールインをオフにすると、負荷が下がってもタスク数が減らないため、コストが高止まりします。リクエストを確実にさばける状態を維持したい場合にのみ使用してください。

#### 12.7.7 その他の設定

**ボリューム・タグ:**

デフォルトのまま(設定なし)でOKです。

#### 12.7.8 サービスの作成

すべての設定が完了したら、画面下部の **作成** ボタンをクリックします。

**デプロイの進行状況:**

- 「デプロイが進行中です」というメッセージが表示されます
- サービスの作成とタスクの起動が開始されます
- しばらく待ちます(数分程度)

**確認ポイント:**

画面上で以下の進行状況を確認できます：
- サービスの作成状況
- タスクの起動状況  
- デプロイの進捗

---

## 13. サービスの動作確認

### 13.1 デプロイ完了の確認

デプロイが完了すると、サービスのステータスが **デプロイ済み** になります。

#### 13.1.1 サービスの詳細確認

作成したサービス `my-app-autoscaling-service` をクリックして詳細画面に入ります。

**確認項目:**

- デプロイ: **デプロイ済み** になっていることを確認
- 実行中のタスク数: **1** になっていることを確認

#### 13.1.2 タスクの確認

サービス詳細画面で **タスク** タブをクリックします。

**確認内容:**

- タスクが1個起動している状態を確認
- ステータスが **RUNNING** になっていることを確認
- パブリックIPアドレスが割り当てられていることを確認

### 13.2 パブリックIPによる直接アクセステスト

#### 13.2.1 パブリックIPでのアクセス（失敗パターン）

タスクに割り当てられた **パブリックIP** をコピーし、ブラウザでアクセスしてみます。

**アクセス方法:**

1. タスクをクリック
2. パブリックIPをコピー
3. ブラウザの新しいタブで開く

**結果:**

ずっと読み込み中（グルグル）の状態が続き、アクセスできません。

**理由:**

- ブラウザでアクセスする場合、デフォルトで **80番ポート** に対してアクセスします
- しかし、サービスのセキュリティグループでは **8080番ポート** のみを許可しています
- そのため、80番ポートへのアクセスはブロックされます

#### 13.2.2 ポート指定でのアクセス（404エラー）

URLの末尾に `:8080` を追加してアクセスします。

**アクセスURL:**

```
http://<パブリックIP>:8080
```

**結果:**

```
Whitelabel Error Page
```

404エラーが表示されます。

**理由:**

- これは Spring Boot が出力しているエラーページです
- エンドポイント（パス）が指定されていないため、404エラーになります

#### 13.2.3 正しいエンドポイントでのアクセス（成功）

APIエンドポイント `/api/encryptor` を追加してアクセスします。

**アクセスURL:**

```
http://<パブリックIP>:8080/api/encryptor
```

**結果:**

```
finished
```

正常にレスポンスが返ってくることを確認できました。

### 13.3 セキュリティグループの改善

現在の設定では、全てのIPアドレスから直接アクセスできてしまいます。これをALB経由のアクセスのみに制限し、よりセキュアな構成にします。

#### 13.3.1 現在の構成の問題点

**現在の状態:**

```
┌─────────────────┐
│  インターネット  │
└────────┬────────┘
         │
    全てのIP許可
         │
    ┌────▼────────────────┐
    │  ECS Task           │
    │  (8080ポート開放)   │
    └─────────────────────┘
```

**問題:**

- セキュリティグループのインバウンドルールが `0.0.0.0/0`（全てのIP）を許可
- パブリックIPを知っていれば誰でも直接アクセス可能
- ALBを経由せずに直接タスクにアクセスできてしまう

#### 13.3.2 理想的な構成

**改善後の状態:**

```
┌─────────────────┐
│  インターネット  │
└────────┬────────┘
         │
    ┌────▼────────────────┐
    │  ALB                │
    │  (SG: ALB用SG)      │
    └────┬────────────────┘
         │
    ALBのSGからのみ許可
         │
    ┌────▼────────────────┐
    │  ECS Task           │
    │  (SG: Task用SG)     │
    └─────────────────────┘
```

**改善点:**

- ALB経由のトラフィックのみを許可
- 直接的なパブリックアクセスをブロック
- セキュリティグループ間の連携で制御

#### 13.3.3 セキュリティグループの編集

**EC2 > セキュリティグループ に移動:**

1. AWSマネジメントコンソールで **EC2** サービスを開く
2. 左側メニューから **セキュリティグループ** を選択
3. `my-app-autoscaling-service-sg` を選択（サービスにアタッチされているSG）
4. **インバウンドルール** タブを選択
5. **インバウンドルールを編集** をクリック

#### 13.3.4 インバウンドルールの変更

**既存ルールの削除:**

現在のルール（全てのIPアドレスを許可しているルール）を削除します：

1. 既存のルールの右側にある **削除** (×) ボタンをクリック
2. 全てのルールを削除

**新しいルールの追加:**

1. **ルールを追加** をクリック

2. 以下の設定を入力：

| 項目       | 設定値                              |
| ---------- | ----------------------------------- |
| タイプ     | カスタムTCP                          |
| ポート範囲 | 8080                                |
| ソース     | カスタム                            |
| ソースの値 | `my-app-autoscaling-alb-sg` を選択  |

**ソースの設定方法:**

- ソースの入力欄をクリック
- **セキュリティグループ** オプションを選択（CIDRではなく）
- ドロップダウンから `my-app-autoscaling-alb-sg` を選択
  - これはALBにアタッチされているセキュリティグループです

3. **ルールを保存** をクリック

> **💡 セキュリティグループをソースに指定:**
> セキュリティグループは、IPアドレスだけでなく、別のセキュリティグループをソースとして指定できます。これにより、「特定のセキュリティグループを持つリソースからのアクセスのみを許可」という設定が可能になります。

#### 13.3.5 変更後のルール確認

**インバウンドルール:**

| タイプ      | プロトコル | ポート範囲 | ソース                          | 説明 |
| ----------- | ---------- | ---------- | ------------------------------- | ---- |
| カスタムTCP | TCP        | 8080       | sg-xxxxx (my-app-autoscaling-alb-sg) | -    |

### 13.4 セキュリティ改善の動作確認

#### 13.4.1 パブリックIP経由のアクセス（ブロックされる）

先ほど成功していたパブリックIPでのアクセスを再度試してみます。

**アクセスURL:**

```
http://<パブリックIP>:8080/api/encryptor
```

**結果:**

ずっと読み込み中（グルグル）の状態が続き、アクセスできなくなります。

**理由:**

- セキュリティグループの変更により、ALBのセキュリティグループからのアクセスのみが許可されるようになりました
- ブラウザから直接パブリックIPにアクセスする場合、ALBを経由していないためブロックされます
- これが正しい動作です ✓

#### 13.4.2 ALB経由でのアクセス（成功）

ALBのDNS名を使ってアクセスします。

**ALBのDNS名の確認:**

1. **EC2 > ロードバランサー** に移動
2. `my-app-autoscaling-alb` を選択
3. 詳細タブの **DNS名** をコピー

例:
```
my-app-autoscaling-alb-1234567890.ap-northeast-1.elb.amazonaws.com
```

**アクセスURL:**

```
http://<ALBのDNS名>:8080/api/encryptor
```

例:
```
http://my-app-autoscaling-alb-1234567890.ap-northeast-1.elb.amazonaws.com:8080/api/encryptor
```

**結果:**

```
finished
```

正常にレスポンスが返ってきます。✓

#### 13.4.3 セキュリティ改善の確認

**改善内容まとめ:**

| アクセス経路               | 変更前 | 変更後   |
| -------------------------- | ------ | -------- |
| パブリックIP経由（直接）   | ✓ 可能 | ✗ ブロック |
| ALB経由                    | ✓ 可能 | ✓ 可能   |

**セキュリティ上の利点:**

- ✓ 直接的な外部アクセスを完全にブロック
- ✓ ALB経由のトラフィックのみを許可
- ✓ ALBの機能（ヘルスチェック、ログ記録、WAF連携など）を確実に利用
- ✓ DDoS攻撃などのリスクを軽減

**アーキテクチャ図（改善後）:**

```
      インターネット
           │
           ▼
    ┌──────────────┐
    │     ALB      │
    │ (80/443)     │
    └──────┬───────┘
           │ ALB-SG経由のみ許可
           ▼
    ┌──────────────┐
    │  ECS Task    │
    │  (8080)      │
    └──────────────┘
    
    直接アクセス ✗ ブロック
```

---

## 14. オートスケーリング設定の詳細確認

### 14.1 サービスの自動スケーリング設定の確認

作成したサービスのオートスケーリング設定を詳しく見ていきます。

#### 14.1.1 サービス更新画面へ移動

1. **ECS > クラスター** から `my-app-autoscaling-cluster` を選択
2. **サービス** タブから `my-app-autoscaling-service` を選択
3. 右上の **サービスを更新** ボタンをクリック

#### 14.1.2 クールダウン期間の詳細説明

画面を下にスクロールして、**サービスの自動スケーリング** セクションを確認します。

以前の設定で入力した以下の項目が表示されています：

**クールダウン期間とは:**

スケーリングアクションの実行後、次のスケーリング評価を行うまでの待機時間です。頻繁なスケーリングを防ぎ、システムを安定させる役割があります。

##### スケールアウトクールダウン期間

**設定値:** `15` 秒

**動作:**

- スケールアウト（タスク増加）を実行した後、15秒間はクールダウン期間となる
- この期間中は新たなスケールアウトが実行されない
- スケールアウトしたタスクが起動・安定化するまでの時間を確保

**意味:**

```
スケールアウト実行
     ↓
  [15秒待機] ← クールダウン期間
     ↓
再評価 → 必要なら再度スケールアウト
```

**設定のポイント:**

| 設定     | メリット                               | デメリット                                 |
| -------- | -------------------------------------- | ------------------------------------------ |
| 長くする | 過度なスケールアウトを防ぐ             | 突発的な負荷への対応が遅くなる             |
| 短くする | 負荷の急増に素早く対応できる           | 無駄にタスクが増えすぎる可能性がある       |

##### スケールインクールダウン期間

**設定値:** `15` 秒

**動作:**

- スケールイン（タスク減少）を実行した後、15秒間はクールダウン期間となる
- この期間中は新たなスケールインが実行されない
- スケールイン後のシステムの安定化を待つ

**設定のポイント:**

| 設定     | メリット                               | デメリット                                 |
| -------- | -------------------------------------- | ------------------------------------------ |
| 長くする | 過度なスケールインを防ぐ               | 不要なタスクが長時間残り、コストがかかる   |
| 短くする | すぐにタスクを減らし、コストを削減     | スケールインが早すぎて負荷に対応できない   |

> **💡 調整の考え方:**
> クールダウン期間は、アプリケーションの特性や負荷パターンに応じて調整が必要です。短すぎると頻繁なスケーリングが発生し、長すぎると柔軟性が失われます。実際の運用データを見ながら最適値を見つけていきましょう。

#### 14.1.3 設定確認後の操作

設定内容を確認したら、**キャンセル** をクリックして元の画面に戻ります。

### 14.2 オートスケーリングポリシーの確認

作成されたオートスケーリングポリシーの詳細を確認します。

#### 14.2.1 ポリシー設定の確認

**サービス詳細画面で:**

1. **設定とネットワーク** タブをクリック
2. 画面を下にスクロールして **オートスケーリング** セクションへ移動

**表示される情報:**

| 項目         | 設定値                              |
| ------------ | ----------------------------------- |
| ポリシー名   | my-app-autoscaling-policy           |
| メトリクス   | ECSServiceAverageCPUUtilization     |
| ターゲット値 | 50                                  |
| 説明         | Average CPU Utilization を 50% で追跡 |

### 14.3 CloudWatch アラームの確認

オートスケーリングに使用されるCloudWatchアラームを確認します。

#### 14.3.1 アラーム画面への移動

オートスケーリングセクションの **アラーム** リンクをクリックします。

CloudWatchのアラーム画面が開きます。

#### 14.3.2 アラームの種類

オートスケーリングポリシーを作成すると、自動的に **2つのアラーム** が作成されます：

| アラーム     | 用途                                   |
| ------------ | -------------------------------------- |
| 1つ目        | スケールアウト用（タスクを増やす）     |
| 2つ目        | スケールイン用（タスクを減らす）       |

左側のアラーム一覧に、2つのアラームが表示されているはずです。

#### 14.3.3 スケールイン用アラームの確認

**アラーム状態:**

デプロイ直後は **データ不足** や **OK** の状態です。

時間が経過すると、負荷がかかっていない場合は **アラーム** 状態になります。

**アラームをクリックして詳細を確認:**

**閾値の設定:**

```
15分以内の15データポイントで
CPUUtilization が 45% 未満
```

**グラフの見方:**

- **青い線:** CPUUtilization（CPU使用率の実測値）
- **赤い線:** 閾値（45%）

**動作:**

- CPU使用率が45%を下回っている状態が15分間続くと、アラームが発火
- アラームが発火すると、スケールイン（タスク減少）が実行される

> **📝 補足:** ターゲット値は50%と設定しましたが、閾値は45%になっています。これはECS側で自動的にバッファーを設けているためです。

**アラーム状態の意味:**

サーバーに負荷がかかっておらず、CPU使用率が低い状態が続いているため、スケールイン可能な状態であることを示しています。

#### 14.3.4 スケールアウト用アラームの確認

もう1つのアラームをクリックして詳細を確認します。

**アラーム状態:**

通常は **OK** の状態です。

**閾値の設定:**

```
3分以内の3データポイントで
CPUUtilization が 50% 超過
```

**動作:**

- CPU使用率が50%を超えている状態が3分間続くと、アラームが発火
- アラームが発火すると、スケールアウト（タスク増加）が実行される

**OK状態の意味:**

CPU使用率が50%を超えていないため、タスクを増やす必要がない状態です。

#### 14.3.5 2つのアラームの比較

| 項目             | スケールイン用           | スケールアウト用        |
| ---------------- | ------------------------ | ----------------------- |
| **目的**         | タスクを減らす           | タスクを増やす          |
| **観測期間**     | 15分間                   | 3分間                   |
| **データポイント** | 15ポイント              | 3ポイント               |
| **閾値**         | 45% 未満                 | 50% 超過                |
| **条件の厳しさ** | 厳しい（長時間観測）     | 緩い（短時間で反応）    |

**設計思想:**

```
スケールアウト: 素早く反応
  └─ 負荷が高まったらすぐにタスクを増やす（3分で判断）
  └─ コストはかかるが、性能を優先

スケールイン: 慎重に判断
  └─ 負荷が低い状態が続いてからタスクを減らす（15分で判断）
  └─ 性能を保ちながら、コストを削減
```

> **💡 なぜこの設計？**
> - **スケールアウト優先:** サーバーが多い方が安全。多少コストがかかっても、パフォーマンスを優先
> - **スケールイン慎重:** 頻繁にタスクが増減すると不安定。本当に不要になってから減らす

#### 14.3.6 アラームの編集について

CloudWatchアラームの詳細画面には **"Not editable"**（編集不可）と表示されています。

**理由:**

- これらのアラームはECSのオートスケーリングによって自動管理されています
- 手動で編集すると、オートスケーリングが正常に動作しなくなる可能性があります

**ベストプラクティス:**

- ✓ ECSのオートスケーリング設定から変更する
- ✗ CloudWatchアラームを直接編集しない

---

## 15. オートスケーリングの動作テスト

K6を使って意図的にサーバーに負荷をかけ、スケールアウトのアラームを発火させて、実際にタスクが増えるかを確認します。

### 15.1 負荷テスト用スクリプトの準備

#### 15.1.1 スクリプトファイルの場所

以前ダウンロードした `ecs-learning-course` リポジトリ内のスクリプトを使用します。

**ディレクトリパス:**

```
ecs-learning-course/
  └─ autoscaling-section/
       └─ k6/
            └─ LoadTest.js
```

#### 15.1.2 LoadTest.js の内容確認

`LoadTest.js` を開くと、以下のような内容になっています：

```javascript
import http from "k6/http";
import { sleep } from "k6";

export const options = {
  vus: 10,
  duration: "300s",
};

export default function () {
  http.get("http://encryptor:8080/api/encryptor");
  sleep(1);
}
```

**スクリプトの説明:**

| 設定項目   | 値       | 説明                                         |
| ---------- | -------- | -------------------------------------------- |
| vus        | 10       | Virtual Users（仮想ユーザー数）= 同時リクエスト数 |
| duration   | 300s     | テスト実行時間 = 5分間                       |
| sleep      | 1秒      | 各リクエスト間の待機時間                     |

**現在の問題:**

- 10行目のURL `http://encryptor:8080/api/encryptor` はローカル環境用
- AWS上のサービスに対してテストするには、ALBのDNS名に変更する必要がある

#### 15.1.3 スクリプトの編集

**ALBのDNS名を取得:**

1. **EC2 > ロードバランサー** に移動
2. `my-app-autoscaling-alb` を選択
3. 詳細タブの **DNS名** をコピー

例:
```
my-app-autoscaling-alb-1234567890.ap-northeast-1.elb.amazonaws.com
```

**LoadTest.js の10行目を編集:**

変更前:
```javascript
http.get("http://encryptor:8080/api/encryptor");
```

変更後:
```javascript
http.get("http://<ALBのDNS名>:8080/api/encrypt");
```

例:
```javascript
http.get("http://my-app-autoscaling-alb-1234567890.ap-northeast-1.elb.amazonaws.com:8080/api/encrypt");
```

> **⚠️ 注意:** ポート番号 `:8080` とエンドポイント `/api/encrypt` はそのまま残してください。

**ファイルを保存します。**

### 15.2 負荷テストの実行

#### 15.2.1 Docker Compose を使った実行

K6はDocker Composeを使って実行できます。

**ターミナルを開いて、autoscaling-section ディレクトリに移動:**

```powershell
cd <ダウンロードしたパス>\ecs-learning-course\autoscaling-section
```

**Docker Compose でK6サービスを起動:**

```powershell
docker-compose up k6
```

**実行内容:**

- `docker-compose.yml` に定義されている `k6` サービスが起動します
- `depends_on` により、Spring Bootのコンテナ（encryptor）も起動しますが、問題ありません
- K6が300秒（5分間）の負荷テストを開始します

**実行結果の例:**

```
k6_1  | 
k6_1  |      execution: local
k6_1  |         script: /scripts/LoadTest.js
k6_1  |         output: -
k6_1  |  
k6_1  |      scenarios: (100.00%) 1 scenario, 10 max VUs
k6_1  |                * default: 10 looping VUs for 5m0s
```

テストが開始されました。このまま300秒（5分間）実行されます。

### 15.3 CloudWatch でのモニタリング

#### 15.3.1 CPU使用率の監視

負荷テストの実行中、CloudWatchでCPU使用率を監視します。

**CloudWatch > アラーム に移動:**

1. スケールアウト用のアラームをクリック
2. グラフが表示されます
3. 定期的に画面右上の **更新ボタン（🔄）** をクリックして最新データを確認

**グラフの見方:**

- **青い線:** 実際のCPU使用率
- **赤い線:** 閾値（50%）

#### 15.3.2 CPU使用率の上昇を確認

**1分後:**

グラフにCPU使用率の上昇が見られるようになります。

```
CPU使用率: 徐々に上昇 → 例: 20%程度
```

**さらに待つと:**

CPU使用率が急激に上昇します。

```
CPU使用率: 急上昇 → 例: 96%程度
```

**この時点では:**

- CPU使用率は50%を超えている
- ただし、アラームはまだ **発火していない**

**理由:**

スケールアウトアラームの条件は「3分間50%を超えた状態が続く」です。まだ条件を満たしていません。

#### 15.3.3 スケールインアラームの状態変化

スケールインアラームの状態を確認すると、**アラーム → OK** に変化しています。

**理由:**

- スケールインの条件は「15分間45%を下回る」
- 現在CPU使用率が上昇しているため、条件を満たさなくなった
- したがって、アラーム状態からOK状態に変化

### 15.4 スケールアウトの確認

#### 15.4.1 アラームの発火

さらに数分待つと、スケールアウト用のアラームが **アラーム状態** になります。

**条件達成:**

```
3分間、CPU使用率が50%を超えた状態を維持
  ↓
スケールアウトアラームが発火
  ↓
タスク増加のイベントがトリガーされる
```

#### 15.4.2 ECSタスクの増加確認

**ECS > クラスター > my-app-autoscaling-cluster に移動:**

1. `my-app-autoscaling-service` を選択
2. **デプロイ** セクションを確認

**デプロイの状態:**

| ステータス | 件数 |
| ---------- | ---- |
| 完了済み   | 1    |
| 進行中     | 1    |

新しいデプロイが進行中であることがわかります。

#### 15.4.3 タスク一覧の確認

**タスク** タブをクリックします。

**タスクの状態:**

| タスク | ステータス | 開始時刻      |
| ------ | ---------- | ------------- |
| 1      | 実行中     | 10時間前      |
| 2      | 実行中     | 2秒前         |

**確認ポイント:**

- ✓ タスクが **2個** に増えています
- ✓ 新しいタスクが追加されたことが開始時刻から確認できます
- ✓ オートスケーリングが正常に動作しています

### 15.5 ターゲットグループの確認

タスクが増えると、ALBのターゲットグループに登録されるターゲットも増加します。

#### 15.5.1 ターゲットグループへの移動

**サービス詳細画面で:**

1. 下にスクロールして **ロードバランサーを表示** をクリック
2. ALBの詳細画面が開きます
3. 下の方の **ターゲットグループ** セクションへ移動
4. `my-app-autoscaling-tg` をクリック

#### 15.5.2 登録済みターゲットの確認

**ターゲット** タブで **登録済みのターゲット** を確認します。

**ターゲット一覧:**

| ターゲット       | ポート | ステータス | ヘルスステータス |
| ---------------- | ------ | ---------- | ---------------- |
| 10.0.1.100       | 8080   | healthy    | Healthy          |
| 10.0.2.150       | 8080   | healthy    | Healthy          |

**確認ポイント:**

- ✓ ターゲット数が **2個** に増えています
- ✓ IPアドレスが異なる2つのタスクが登録されています
- ✓ 両方とも **Healthy** ステータスです

### 15.6 負荷テスト完了後の確認

#### 15.6.1 テスト結果の確認

K6の実行が完了すると、ターミナルにレポートが表示されます。

**レポート例:**

```
     ✓ status was 200

     checks.........................: 100.00% ✓ 933       ✗ 0
     data_received..................: 186 kB  621 B/s
     data_sent......................: 112 kB  373 B/s
     http_req_blocked...............: avg=1.2ms    min=0s       med=0s      max=112ms   p(90)=0s      p(95)=0s
     http_req_connecting............: avg=1.1ms    min=0s       med=0s      max=109ms   p(90)=0s      p(95)=0s
     http_req_duration..............: avg=103.2ms  min=50.1ms   med=95.2ms  max=301.2ms p(90)=150.3ms p(95)=180.5ms
     http_req_failed................: 0.00%   ✓ 0         ✗ 933
     http_req_receiving.............: avg=1.1ms    min=0s       med=0s      max=15.2ms  p(90)=2.1ms   p(95)=3.2ms
     http_req_sending...............: avg=0.5ms    min=0s       med=0s      max=8.1ms   p(90)=0s      p(95)=1.1ms
     http_req_waiting...............: avg=101.6ms  min=49.2ms   med=94.1ms  max=298.3ms p(90)=148.1ms p(95)=178.2ms
     http_reqs......................: 933     3.11/s
     iteration_duration.............: avg=1.1s     min=1.05s    med=1.09s   max=1.4s    p(90)=1.15s   p(95)=1.18s
     iterations.....................: 933     3.11/s
     vus............................: 10      min=10      max=10
     vus_max........................: 10      min=10      max=10
```

**重要な指標:**

| 項目                | 値          | 説明                           |
| ------------------- | ----------- | ------------------------------ |
| http_reqs           | 933         | 送信された総リクエスト数       |
| http_req_failed     | 0.00%       | 失敗したリクエストの割合（0%） |
| checks              | 100.00% ✓   | 全てのチェックが成功           |

**結果:**

- ✓ 933回のリクエストが送信されました
- ✓ 失敗したリクエストは **0件** でした
- ✓ 全てのリクエストが正常に処理されました

#### 15.6.2 CPU使用率の低下

テスト終了後、CloudWatchでCPU使用率を確認します。

**CloudWatch > アラーム に戻る:**

1. スケールアウト用のアラームを確認
2. 更新ボタンをクリック

**グラフの変化:**

```
CPU使用率: 急降下 → ほぼ0%に近い値
```

**アラームの状態:**

| アラーム         | 状態変化               |
| ---------------- | ---------------------- |
| スケールアウト用 | アラーム → **OK**      |
| スケールイン用   | OK → （まだOKのまま）  |

### 15.7 スケールインの確認

#### 15.7.1 スケールイン待機

テスト終了後、CPU使用率は低いままですが、すぐにはスケールインは実行されません。

**理由:**

- スケールインの条件: 「15分間45%を下回る」
- まだ15分経過していないため、条件を満たしていない
- アラームはまだOK状態のまま

#### 15.7.2 15分後の確認

約15分放置した後、再度確認します。

**CloudWatch アラームの確認:**

スケールイン用のアラームが **OK → アラーム状態** に変化しています。

**条件達成:**

```
15分間、CPU使用率が45%を下回った状態を維持
  ↓
スケールインアラームが発火
  ↓
タスク減少のイベントがトリガーされる
```

#### 15.7.3 タスク数の確認

**ECS > サービス > タスク タブを確認:**

**タスクの状態:**

| タスク | ステータス | 開始時刻 |
| ------ | ---------- | -------- |
| 1      | 実行中     | 10時間前 |

**確認ポイント:**

- ✓ タスク数が **1個** に戻っています
- ✓ スケールインが正常に動作しました
- ✓ 最小タスク数（1個）まで減少しました

### 15.8 オートスケーリング動作のまとめ

**テスト全体の流れ:**

```
1. 初期状態: タスク1個、CPU使用率低い
     ↓
2. K6で負荷テスト開始（5分間）
     ↓
3. CPU使用率が急上昇（50%超え）
     ↓
4. 3分間維持 → スケールアウトアラーム発火
     ↓
5. タスクが2個に増加（スケールアウト成功）
     ↓
6. 負荷テスト終了、CPU使用率低下
     ↓
7. 15分間維持 → スケールインアラーム発火
     ↓
8. タスクが1個に減少（スケールイン成功）
```

**オートスケーリングの動作確認完了:**

- ✓ スケールアウト: CPU使用率50%超えで3分後にタスク増加
- ✓ スケールイン: CPU使用率45%未満で15分後にタスク減少
- ✓ ターゲットグループも自動的に更新
- ✓ 全リクエストが正常に処理（失敗0件）

**ECS Auto Scaling の特徴:**

| 特徴               | 内容                                                       |
| ------------------ | ---------------------------------------------------------- |
| スケールアウト優先 | 素早く反応（3分）してパフォーマンスを維持                 |
| スケールイン慎重   | ゆっくり判断（15分）して安定性を確保                       |
| 自動調整           | CloudWatchメトリクスに基づいて自動的にタスク数を調整       |
| 範囲設定           | 最小数と最大数の範囲内でスケーリング                       |

---

## 16. まとめ

### 16.1 本セクションで学んだこと

このセクションでは、ECS Service Auto Scalingについて以下を学習しました：

**1. Auto Scalingの基礎:**
- ターゲット追跡スケーリングポリシー
- スケールアウトとスケールインの違い
- クールダウン期間の役割

**2. 実装した内容:**
- Application Load Balancer（ALB）の作成
- ターゲットグループの設定
- ECSサービスの作成（Auto Scaling有効）
- セキュリティグループの最適化

**3. 動作確認:**
- K6を使った負荷テスト
- CloudWatchアラームの監視
- スケールアウト/スケールインの実際の動作確認

### 16.2 Auto Scalingのベストプラクティス

**設定のポイント:**

1. **最小数・最大数の設定:**
   - 最小数: サービスの可用性を保証する最低限の数
   - 最大数: コスト上限とシステム容量を考慮

2. **メトリクスの選択:**
   - CPU使用率: 汎用的、最も一般的
   - メモリ使用率: メモリ集約型アプリケーション向け
   - リクエスト数: トラフィックベースの制御

3. **クールダウン期間:**
   - 短すぎる: 頻繁なスケーリング、不安定
   - 長すぎる: 負荷変化への対応遅延
   - 推奨: アプリケーションの起動時間 + バッファー

4. **セキュリティ:**
   - ALB経由のアクセスのみ許可
   - セキュリティグループで適切に制御
   - パブリックアクセスは制限

### 16.3 運用上の注意点

**コスト管理:**
- スケールアウトはコスト増加につながる
- 最大数を適切に設定してコスト上限を管理
- CloudWatch Billing Alertsの設定を推奨

**モニタリング:**
- CloudWatchメトリクスを定期的に確認
- アラーム履歴から動作パターンを分析
- 必要に応じてターゲット値やクールダウン期間を調整

**テスト:**
- 本番環境適用前に十分な負荷テストを実施
- 想定される最大負荷での動作確認
- スケールアウト/インの所要時間を計測

---

## 17. リソースの削除（後始末）

このセクションで作成したAWSリソースを削除します。放置すると課金が発生するため、必ず削除しましょう。

> **⚠️ 重要:** リソースを削除しないと、使用していない間も課金が継続されます。特にロードバランサーは高額なので、必ず削除してください。

### 17.1 削除するリソースの一覧

| リソース           | 課金の有無         | 優先度 |
| ------------------ | ------------------ | ------ |
| ECSサービス        | タスク実行中は課金 | 高     |
| ECRリポジトリ      | イメージ容量で課金 | 中     |
| Application Load Balancer | 存在するだけで課金 | **最高** |
| ターゲットグループ | 課金されない       | 低     |
| セキュリティグループ | 課金されない     | 低     |

### 17.2 ECSサービスの削除

#### 17.2.1 CloudFormation経由での削除

ECSサービスはCloudFormation経由で削除します。

> **💡 なぜCloudFormation経由？**
> サービス作成時にCloudFormationスタックが自動的に作成されています。CloudFormation経由で削除することで、関連リソースを漏れなく、きれいに削除できます。

#### 17.2.2 削除手順

**1. CloudFormation コンソールを開く:**

AWSマネジメントコンソールから **CloudFormation** サービスを開きます。

**2. スタックの特定:**

スタック一覧から以下の名前のスタックを探します：

```
V2:Service-my-app-autoscaling-service-my-app-autoscaling-cluster
```

または、名前に以下が含まれるスタック：
- `V2:Service-`
- `my-app-autoscaling-service`
- `my-app-autoscaling-cluster`

**3. スタックの削除:**

1. 該当するスタックを選択（チェックボックスにチェック）
2. 右上の **削除** ボタンをクリック
3. 確認ダイアログで **削除** をクリック

**4. 削除の待機:**

削除には約3〜5分かかります。

**ステータスの変化:**

```
削除中 (DELETE_IN_PROGRESS)
  ↓
  [3〜5分待機]
  ↓
削除済み (DELETE_COMPLETE)
```

**5. 削除完了の確認:**

削除が完了すると、スタックは一覧から消えます。

削除済みスタックを確認するには：
1. スタック一覧の上部にあるフィルターで **削除済み** を選択
2. 先ほどのスタックが **削除済み** ステータスで表示されます

#### 17.2.3 ECSサービスの削除確認

**ECS > クラスター に移動:**

1. `my-app-autoscaling-cluster` を選択
2. **サービス** タブを確認
3. サービスが **0個** になっていることを確認 ✓

### 17.3 ECRリポジトリの削除

#### 17.3.1 課金について

ECRリポジトリは、保存しているDockerイメージの容量に応じて課金されます。

**課金対象:** イメージの保存容量（GB/月）

#### 17.3.2 削除手順

**1. ECR コンソールを開く:**

**ECR > リポジトリ** に移動します。

**2. リポジトリの選択:**

以下のリポジトリを探します：

```
my-app-encryptor
```

**3. リポジトリの削除:**

1. `my-app-encryptor` を選択（チェックボックスにチェック）
2. 右上の **削除** ボタンをクリック
3. 確認ダイアログで `delete` と入力
4. **削除** をクリック

> **📝 補足:** このリポジトリを残しておきたい場合は、削除しなくても構いません。ただし、イメージの容量に応じて課金が発生し続けます。

### 17.4 Application Load Balancer の削除

#### 17.4.1 課金について

ロードバランサーは **存在するだけで課金** されます。

**課金額:** 約 $0.0225/時間（約$16〜$20/月）+ データ処理料金

> **⚠️ 最優先で削除:** ロードバランサーは高額な課金対象です。使用していない場合は必ず削除してください。

#### 17.4.2 削除手順

**1. EC2 > ロードバランサー に移動:**

左側メニューから **ロードバランサー** を選択します。

**2. ロードバランサーの選択:**

以下のロードバランサーを探します：

```
my-app-autoscaling-alb
```

**3. ロードバランサーの削除:**

1. `my-app-autoscaling-alb` を選択（チェックボックスにチェック）
2. 右上の **アクション** → **ロードバランサーの削除** をクリック
3. 確認ダイアログで `confirm` と入力
4. **削除** をクリック

**4. 削除完了:**

```
ロードバランサーが正常に削除されました
```

というメッセージが表示されます。

### 17.5 ターゲットグループの削除（任意）

#### 17.5.1 課金について

ターゲットグループは **存在するだけでは課金されません**。

**削除の判断:**
- 削除しても問題ありません
- 残しておいても課金は発生しません（通常）

> **📝 注意:** 課金ポリシーは変更される可能性があるため、最新の情報を確認してください。

#### 17.5.2 削除手順（任意）

削除する場合は、以下の手順で削除できます：

**1. EC2 > ターゲットグループ に移動:**

左側メニューから **ターゲットグループ** を選択します。

**2. ターゲットグループの選択:**

```
my-app-autoscaling-tg
```

**3. ターゲットグループの削除:**

1. `my-app-autoscaling-tg` を選択
2. 右上の **アクション** → **削除** をクリック
3. 確認ダイアログで **はい、削除します** をクリック

### 17.6 セキュリティグループの削除（任意）

#### 17.6.1 課金について

セキュリティグループは **存在するだけでは課金されません**。

**削除の判断:**
- 削除しても問題ありません
- 残しておいても課金は発生しません（通常）

> **📝 注意:** 課金ポリシーは変更される可能性があるため、最新の情報を確認してください。

#### 17.6.2 作成したセキュリティグループ

このセクションで作成したセキュリティグループ：

- `my-app-autoscaling-alb-sg` （ALB用）
- `my-app-autoscaling-service-sg` （ECSサービス用）

#### 17.6.3 削除手順（任意）

削除する場合は、以下の手順で削除できます：

**1. EC2 > セキュリティグループ に移動:**

左側メニューから **セキュリティグループ** を選択します。

**2. セキュリティグループの選択:**

以下のセキュリティグループを探します：
- `my-app-autoscaling-alb-sg`
- `my-app-autoscaling-service-sg`

**3. セキュリティグループの削除:**

1. 削除するセキュリティグループを選択
2. 右上の **アクション** → **セキュリティグループを削除** をクリック
3. 確認ダイアログで **削除** をクリック

> **⚠️ 注意:** セキュリティグループは、他のリソース（EC2インスタンス、ENIなど）に関連付けられている場合は削除できません。その場合は、関連リソースを先に削除してください。

### 17.7 削除確認チェックリスト

以下のリソースが削除されたことを確認してください：

**必須（課金対象）:**

- [ ] ECSサービス（CloudFormation経由で削除）
- [ ] Application Load Balancer
- [ ] ECRリポジトリ（必要に応じて）

**任意（通常は課金されない）:**

- [ ] ターゲットグループ
- [ ] セキュリティグループ

### 17.8 課金の確認

削除後、以下の方法で課金が発生していないことを確認できます：

**1. Cost Explorer で確認:**

1. **請求とコスト管理** コンソールを開く
2. **Cost Explorer** を選択
3. サービス別のコストを確認

**2. 請求アラートの設定:**

今後のために、請求アラートを設定しておくことを推奨します：

1. **請求とコスト管理** > **予算** を開く
2. 予算を作成し、一定額を超えたらアラートを受け取るように設定

---

## 18. 総まとめ

### 18.1 本ドキュメントで学んだこと

このドキュメントでは、ECS Service Auto Scalingについて、基礎から実践まで詳しく学習しました。

**学習内容:**

1. **Auto Scalingの基礎概念**
   - スケールアウトとスケールインの違い
   - ターゲット追跡スケーリングポリシー
   - クールダウン期間の役割

2. **インフラ構築**
   - Application Load Balancer（ALB）の作成
   - ターゲットグループの設定
   - セキュリティグループの設計と実装

3. **ECS Service の作成**
   - Auto Scaling有効化
   - 最小/最大タスク数の設定
   - CloudWatchアラームの自動作成

4. **動作確認とテスト**
   - K6を使った負荷テスト
   - CloudWatchでのモニタリング
   - スケールアウト/スケールインの実際の動作確認

5. **リソース管理**
   - 適切なリソース削除
   - コスト管理の重要性

### 18.2 実践で得られたスキル

- ✓ ECS Auto Scalingの設計と実装
- ✓ ALBとECSの統合
- ✓ セキュリティグループによるネットワーク制御
- ✓ CloudWatchアラームの理解と活用
- ✓ 負荷テストの実施と結果分析
- ✓ AWSリソースのコスト管理

### 18.3 次のステップ

このセクションで学んだ内容を基に、さらに発展的な学習が可能です：

**推奨する次のステップ:**

1. **CI/CDパイプラインの構築**
   - CodePipeline、CodeBuild、CodeDeployの活用
   - 自動デプロイの実装

2. **より高度なAuto Scaling**
   - ステップスケーリングポリシーの活用
   - 複数のメトリクスを組み合わせた制御
   - スケジュールベースのスケーリング

3. **マイクロサービスアーキテクチャ**
   - 複数サービスの連携
   - Service Discoveryの活用
   - サービス間通信の最適化

4. **可観測性の向上**
   - X-Rayによる分散トレーシング
   - Container Insightsの活用
   - ログ集約と分析

5. **セキュリティの強化**
   - Secrets Managerでの機密情報管理
   - IAMロールの最小権限化
   - VPCエンドポイントの活用

---

以上で、ECS Service Auto Scalingに関する講義は完了です。

お疲れさまでした！
