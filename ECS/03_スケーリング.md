# ECS オートスケーリング設定手順書

## 1. オートスケーリングの概要

### 1.1 オートスケーリングのフロー

ECS におけるオートスケーリングは、以下のような流れで実行されます。

**オートスケーリングのフロー:**

```
ECSコンテナ
  ↓ (CPU/メモリ使用状況)
CloudWatch Metrics
  ↓ (データ収集)
CloudWatch Alarm
  ↓ (条件監視・閾値判定)
アラーム通知
  ↓ (通知)
ECS Service
  ↓ (実行)
オートスケーリング
```

**フローの詳細:**

1. ECS コンテナの CPU・メモリ使用状況がデータとして収集される
2. 収集されたデータは CloudWatch Metrics に保存される
3. CloudWatch Alarm が設定された条件に基づいてメトリクスを監視
4. 一定の条件(閾値)を満たした場合、アラームが通知を送信
5. ECS サービスが通知を受け取り、オートスケーリングを実行

> **Note:** ステップスケーリングもターゲット追跡スケーリングも、基本的に同じフローで動作します。違いは CloudWatch Alarm の条件設定部分にあります。

---

## 2. アプリケーション構成

### 2.1 システム構成図

```
ユーザー/ブラウザ
  |
  | HTTP Request
  ↓
Application Load Balancer (Port: 8080)
  |
  | リクエスト分配
  ↓
Target Group
  ├─→ ECS Task 1 (Spring Boot API - 暗号化処理)
  ├─→ ECS Task 2 (Spring Boot API - 暗号化処理)
  └─→ ECS Task 3 (Spring Boot API - 暗号化処理)
```

**構成要素:**

- **ユーザー/クライアント**: ブラウザから API を呼び出し
- **Application Load Balancer**: 複数のコンテナにリクエストを分配
- **Target Group**: オートスケールされたタスクを登録・管理
- **ECS Task**: Spring Boot で作成された Web API を提供
  - 暗号化処理により意図的に CPU 負荷を発生させる

### 2.2 ロードバランサーの内部構成

```
クライアント
  |
  | HTTP:8080
  ↓
┌─────────────────────────────────┐
│ Application Load Balancer       │
│                                 │
│  Listener (HTTP:8080)           │
│    ↓                            │
│  Target Group                   │
│    ├─→ Task 1                   │
│    ├─→ Task 2                   │
│    └─→ Task 3                   │
└─────────────────────────────────┘
```

---

## 3. 全体アーキテクチャ

### 3.1 詳細構成図

```
┌──────────────────────────────────────────────────────────────────┐
│ VPC: my-workspace-vpc                                            │
│                                                                  │
│  ユーザー/クライアント                                           │
│    ↓ HTTP Request                                               │
│  Security Group (Port: 8080)                                    │
│    ↓                                                            │
│  Application Load Balancer (my-app-autoscaling-lb)             │
│    ↓                                                            │
│  Target Group (my-app-autoscaling-tg)                          │
│    ↓                                                            │
│  Security Group (ECS Service用)                                 │
│    ↓                                                            │
│  ┌────────────────────────────────────────────────────┐        │
│  │ ECS Cluster: my-app-cluster                        │        │
│  │                                                     │        │
│  │  ECS Service (my-app-autoscaling-service)          │        │
│  │    ├─→ Task (Fargate) ←─ Task Definition          │        │
│  │    ├─→ Task (Fargate) ←─ Task Definition          │        │
│  │    └─→ Task (Fargate) ←─ Task Definition          │        │
│  │           ↓ (イメージ取得)                           │        │
│  │    ECR Repository (my-app-encryptor)                │        │
│  └────────────────────────────────────────────────────┘        │
│                                                                  │
│  Subnet: public1-a, public1-b                                   │
└──────────────────────────────────────────────────────────────────┘

【オートスケーリング監視】
ECS Service
  ↓
CloudWatch (CPU/Memory監視)
  ↓
CloudWatch Alarm
  ↓
Scaling Policy (Target Tracking)
  ↓
ECS Service (スケール実行)
```

---

## 4. 必要な AWS リソース一覧

### 4.1 ECS リソース

| リソース        | 名称                         | 備考                   |
| --------------- | ---------------------------- | ---------------------- |
| ECS Cluster     | `my-app-cluster`             | 既存のクラスターを使用 |
| ECS Service     | `my-app-autoscaling-service` | **新規作成**           |
| Task Definition | `my-app-encryptor`           | **新規作成**           |
| ECR Repository  | `my-app-encryptor`           | **新規作成**           |

### 4.2 CloudWatch

| リソース       | 名称                        | 備考                                                                       |
| -------------- | --------------------------- | -------------------------------------------------------------------------- |
| Scaling Policy | `my-app-autoscaling-policy` | **新規作成**<br/>Target Tracking Scaling Policy<br/>CPU/メモリの閾値を設定 |

### 4.3 ネットワークリソース

| リソース                    | 名称                                | 備考                                  |
| --------------------------- | ----------------------------------- | ------------------------------------- |
| VPC                         | `my-workspace-vpc`                  | 既存の VPC を使用                     |
| Subnet (AZ-a)               | `my-workspace-subnet-app-public1-a` | 既存のパブリックサブネットを使用      |
| Subnet (AZ-b)               | `my-workspace-subnet-app-public1-b` | 既存のパブリックサブネットを使用      |
| Security Group (ALB 用)     | `my-app-autoscaling-lb-sg`          | **新規作成**<br/>Port 8080 を許可     |
| Security Group (Service 用) | `my-app-autoscaling-service-sg`     | **新規作成**<br/>ALB からの通信を許可 |

### 4.4 IAM ロール

| リソース            | 名称                   | 備考               |
| ------------------- | ---------------------- | ------------------ |
| Task Execution Role | `ecsTaskExecutionRole` | 既存のロールを使用 |

### 4.5 ロードバランサー

| リソース                  | 名称                     | 備考             |
| ------------------------- | ------------------------ | ---------------- |
| Application Load Balancer | `my-app-autoscaling-alb` | **新規作成**     |
| Target Group              | `my-app-autoscaling-tg`  | **新規作成**     |
| Listener                  | HTTP:8080                | ALB 作成時に設定 |

---

## 5. 作業の流れ

### 5.1 各ステップの概要

1. **ECR リポジトリ作成**

   - Docker イメージを保存するリポジトリを作成

2. **Docker イメージビルド・プッシュ**

   - Spring Boot アプリケーションをコンテナ化
   - ECR にプッシュ

3. **Security Group 作成**

   - ALB 用: Port 8080 を許可
   - ECS Service 用: ALB からの通信を許可

4. **Target Group 作成**

   - ヘルスチェック設定を含む

5. **Application Load Balancer 作成**

   - リスナー設定(HTTP:8080)
   - Target Group との紐付け

6. **Task Definition 作成**

   - コンテナ定義
   - リソース設定(CPU/Memory)

7. **ECS Service 作成**

   - Desired count 設定
   - ネットワーク設定
   - Load Balancer との統合

8. **Auto Scaling 設定**

   - Target Tracking Scaling Policy の設定
   - CPU 使用率の閾値設定

9. **動作確認**
   - 負荷テストツールでリクエスト送信
   - スケールアウト/インの確認

---

## 6. Web API サーバーの準備

### 6.1 概要

負荷テスト用の Web API サーバーを作成します。このサーバーは、ECS タスクとして動作する Spring Boot アプリケーションで API エンドポイントを提供します。

**アプリケーションの特徴:**

- **言語**: Java + Spring Boot
- **機能**: 文字列の暗号化処理（10 万回のループ）
- **目的**: 意図的に CPU 負荷を発生させてオートスケーリングを検証
- **エンドポイント**: `GET /api/encryptor`

### 6.2 ソースコードの取得

#### 6.2.1 GitHub リポジトリ

ソースコードは以下の GitHub リポジトリで公開されています：

```
https://github.com/kentny/ecs-learning-course
```

#### 6.2.2 クローン/ダウンロード方法

```bash
git clone https://github.com/kentny/ecs-learning-course.git
cd ecs-learning-course
```

> **Note:** ブランチは `main` を使用してください。

### 6.3 ディレクトリ構造の確認

クローン後、`autoscaling-section` ディレクトリに移動します：

```bash
cd autoscaling-section
ls -la
```

**ディレクトリ構成:**

```
autoscaling-section/
├── docker-compose.yml      # Docker Compose設定ファイル
├── encryptor/              # Spring Bootアプリケーション
│   ├── src/
│   ├── Dockerfile
│   ├── build.gradle
│   └── ...
└── k6/                     # 負荷テストツール（後述）
    └── LoadTest.js
```

### 6.4 ソースコードの確認

#### 6.4.1 VS Code でプロジェクトを開く

```bash
code encryptor/
```

または、VS Code のメニューから：

1. `File` → `Open`
2. `autoscaling-section/encryptor/` を選択
3. 信頼確認ダイアログで「Yes」を選択

#### 6.4.2 API コントローラーの確認

[src/main/java/com/example/encryptor/EncryptorController.java](ecs-learning-course/autoscaling-section/encryptor/src/main/java/com/example/encryptor/controller/EncryptorController.java) を開きます。

**主要なコード:**

```java

@RestController
@RequestMapping("/api/encryptor")
public class EncryptorController {
    @GetMapping
    String get() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        SecretKey key = KeyGenerator.getInstance("AES").generateKey();
        Cipher cipher = Cipher.getInstance("AES");

        for (int i=0; i<100000; i++) {
            byte[] data = new byte[256];
            cipher.init(Cipher.ENCRYPT_MODE, key);
            cipher.doFinal(data);
        }

        return "Finish!";
    }
}
```

**処理の説明:**

- **エンドポイント**: `/api/encryptor`
- **メソッド**: GET
- **処理内容**: 暗号化処理を 10 万回ループ実行（意図的に CPU 負荷を高める）
- **レスポンス**: "Finish!" という文字列を返却

### 6.5 Dockerfile の確認

[encryptor/Dockerfile](ecs-learning-course/autoscaling-section/encryptor/Dockerfile) を開いて内容を確認します。

**Dockerfile（マルチステージビルド）:**

```dockerfile
FROM gradle:jdk21 AS build
WORKDIR /app
COPY . /app
RUN chmod +x ./gradlew && \
    ./gradlew build


FROM openjdk:21
COPY --from=build /app/build/libs/encryptor-0.0.1-SNAPSHOT.jar ./encryptor.jar
CMD [ "java", "-jar", "encryptor.jar" ]
```

**ポイント:**

1. **ビルドステージ**: Gradle を使用して Java アプリケーションをビルド
2. **実行ステージ**: ビルドされた JAR ファイルを実行環境にコピーして起動
3. **chmod +x**: Gradlew に実行権限を付与（環境によっては Permission Error が発生するため）

### 6.6 Docker Compose の確認

`autoscaling-section` ディレクトリに戻り、[docker-compose.yml](ecs-learning-course/autoscaling-section/docker-compose.yml) を確認します。

**docker-compose.yml:**

```yaml
version: "3.9"
services:
  encryptor:
    container_name: encryptor
    build: ./encryptor
    ports:
      - "8080:8080"
    healthcheck:
      test:
        ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
      start_period: 3s
      interval: 2s
      timeout: 3s
      retries: 10

  k6:
    container_name: k6
    image: grafana/k6
    entrypoint: k6 run
    command: LoadTest.js
    working_dir: /workspace
    volumes:
      - ./k6:/workspace
    depends_on:
      encryptor:
        condition: service_healthy
```

**設定内容:**

**encryptor サービス:**

- **container_name**: コンテナ名を `encryptor` に設定
- **build**: `./encryptor` ディレクトリの Dockerfile を使用してビルド
- **ports**: ホストの 8080 番ポートとコンテナの 8080 番ポートをマッピング
- **healthcheck**: ヘルスチェック設定
  - Spring Boot Actuator の `/actuator/health` エンドポイントを使用
  - `start_period: 3s` - 起動後 3 秒待機してからチェック開始
  - `interval: 2s` - 2 秒ごとにヘルスチェックを実行
  - `timeout: 3s` - タイムアウト 3 秒
  - `retries: 10` - 10 回リトライ

**k6 サービス（負荷テスト用）:**

- **container_name**: コンテナ名を `k6` に設定
- **image**: Grafana の公式 k6 イメージを使用
- **command**: `LoadTest.js` スクリプトを実行
- **volumes**: ローカルの `./k6` ディレクトリをマウント
- **depends_on**: `encryptor` サービスが healthy になってから起動

### 6.7 ローカル環境での動作確認

#### 6.7.1 アプリケーションの起動

`autoscaling-section` ディレクトリで以下のコマンドを実行します：

```bash
docker compose up encryptor
```

**起動確認:**

- Spring のロゴが表示されれば起動成功
- 初回起動時はビルドに時間がかかります

**出力例:**

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.x.x)

... Started EncryptorApplication in X.XXX seconds
```

#### 6.7.2 API の動作確認

ブラウザまたは curl で以下の URL にアクセスします：

```
http://localhost:8080/api/encryptor
```

**curl コマンドの場合:**

```bash
curl http://localhost:8080/api/encryptor
```

**期待されるレスポンス:**

```
Finish!
```

このレスポンスが返ってくれば、Web API の動作確認は完了です。

#### 6.7.3 アプリケーションの停止

ターミナルで `Ctrl + C` を押してアプリケーションを停止します。

または、別のターミナルで：

```bash
docker compose down
```

---

## 7. 負荷テストツール（k6）の設定

### 7.1 k6 の概要

オートスケーリングを実験するためには、サーバーに意図的に負荷をかけてコンテナ数が増減する様子を確認する必要があります。手動でブラウザから何度も API を呼び出すのは現実的ではないため、自動的に大量のリクエストを送信する負荷テストツールを使用します。

**負荷テストツールの選択肢:**

| ツール名 | 特徴                                                 |
| -------- | ---------------------------------------------------- |
| **k6**   | シンプルで使いやすい、オープンソース（**今回採用**） |
| JMeter   | Java 製、高機能だが設定が複雑                        |
| Gatling  | Scala 製、高性能                                     |
| Locust   | Python 製、分散負荷テストに強い                      |

**k6 の特徴:**

- Grafana Labs が提供するオープンソースツール
- JavaScript でテストシナリオを記述
- シンプルで学習コストが低い
- Docker イメージが公式提供されている
- 今回のような簡単な負荷テストに最適

### 7.2 LoadTest.js の確認と解説

#### 7.2.1 ファイルの場所

`autoscaling-section/k6/LoadTest.js` を開きます。

**VSCode での操作:**

1. エクスプローラーで `autoscaling-section` → `k6` を展開
2. `LoadTest.js` をクリックして開く

#### 7.2.2 LoadTest.js の内容

```javascript
import http from "k6/http";
import { sleep } from "k6";

export const options = {
  vus: 10,
  duration: "300s",
};

export default function () {
  http.get("http://encryptor:8080/api/encryptor");
  sleep(1);
}
```

#### 7.2.3 コードの詳細解説

**1. インポート部分:**

```javascript
import http from "k6/http";
import { sleep } from "k6";
```

- `k6/http`: HTTP リクエストを送信するためのモジュール
- `k6`: sleep（待機）などの基本機能を含むコアモジュール

**2. オプション設定:**

```javascript
export const options = {
  vus: 10,
  duration: "300s",
};
```

| パラメータ | 意味          | 設定値 | 説明                                     |
| ---------- | ------------- | ------ | ---------------------------------------- |
| `vus`      | Virtual Users | `10`   | 同時実行する仮想ユーザー数（同時接続数） |
| `duration` | Duration      | `300s` | テスト実行時間（300 秒 = 5 分間）        |

**負荷の計算:**

- 10 ユーザー × 1 秒間隔 = **約 10 RPS (Requests Per Second)**
- 300 秒間で合計 **約 3,000 リクエスト** が送信される

> **Note:** これらのパラメータは、今回のオートスケーリング検証に必要な負荷を与えられるよう事前に調整されています。

**3. テスト実行部分:**

```javascript
export default function () {
  http.get("http://encryptor:8080/api/encryptor");
  sleep(1);
}
```

- `http.get()`: 指定した URL に対して HTTP GET リクエストを送信
- `sleep(1)`: 1 秒間待機
- この関数が各仮想ユーザーごとに繰り返し実行される

#### 7.2.4 URL の説明

```javascript
http.get("http://encryptor:8080/api/encryptor");
```

**ドメイン名が `encryptor` である理由:**

Docker Compose では、同じ Compose ファイル内で定義されたサービスは、**サービス名で相互に通信できる**仕組みになっています。

**仕組みの詳細:**

1. `docker compose up` を実行すると、専用のブリッジネットワークが自動作成される
2. 各サービス（コンテナ）は同じネットワークに配置される
3. Docker の内部 DNS により、サービス名（`encryptor`）がコンテナの IP アドレスに自動解決される
4. k6 コンテナから `http://encryptor:8080` にアクセスすると、encryptor コンテナにルーティングされる

> **重要:** AWS ECS にデプロイした後は、Docker Compose を使用しないため、この URL を ALB のエンドポイントに変更する必要があります（後述）。

### 7.3 docker-compose.yml の k6 サービス詳細解説

#### 7.3.1 k6 サービスの設定

[docker-compose.yml](ecs-learning-course/autoscaling-section/docker-compose.yml) の k6 サービス部分を詳しく確認します。

```yaml
k6:
  container_name: k6
  image: grafana/k6
  entrypoint: k6 run
  command: LoadTest.js
  working_dir: /workspace
  volumes:
    - ./k6:/workspace
  depends_on:
    encryptor:
      condition: service_healthy
```

#### 7.3.2 各設定項目の詳細

**1. container_name**

```yaml
container_name: k6
```

- コンテナ名を `k6` に設定
- `docker ps` で確認する際に識別しやすくなる

**2. image**

```yaml
image: grafana/k6
```

- Grafana Labs が公式提供する k6 の Docker イメージを使用
- 自分で Dockerfile を作成する必要がない

**3. entrypoint（エントリーポイントの上書き）**

```yaml
entrypoint: k6 run
```

**エントリーポイントとは:**

Docker イメージには、デフォルトで実行されるコマンド（エントリーポイント）が定義されていることがあります。

**エントリーポイントの動作:**

```bash
# grafana/k6 イメージのデフォルトエントリーポイント: "k6"
docker run grafana/k6 version
# 実際に実行されるコマンド: k6 version
```

**上書きの理由:**

- デフォルトのエントリーポイントは `k6` のみ
- 今回は `k6 run` コマンドを実行したい
- `entrypoint: k6 run` で上書きすることで、後続の `command` が引数として渡される

**エントリーポイントの確認方法:**

```bash
docker image inspect grafana/k6
```

出力結果の中に以下のような記述があります：

```json
"Entrypoint": [
    "k6"
]
```

**4. command**

```yaml
command: LoadTest.js
```

- エントリーポイントに渡される引数
- 最終的に実行されるコマンド: `k6 run LoadTest.js`

**5. working_dir**

```yaml
working_dir: /workspace
```

- コンテナ起動時の作業ディレクトリを `/workspace` に設定
- このディレクトリ内で `LoadTest.js` が探索される

**6. volumes（バインドマウント）**

```yaml
volumes:
  - ./k6:/workspace
```

**バインドマウントとは:**

ホスト側のディレクトリとコンテナ側のディレクトリを同期させる仕組みです。

```
┌─────────────────┐      同期      ┌────────────────────┐
│ ホスト          │ ←──────────→  │ コンテナ            │
│ ./k6/           │               │ /workspace/        │
│ LoadTest.js     │               │ LoadTest.js        │
└─────────────────┘               └────────────────────┘
```

**効果:**

- ホスト側の `./k6/LoadTest.js` がコンテナ内の `/workspace/LoadTest.js` として見える
- ファイルを編集すると即座にコンテナ側に反映される
- コンテナを再ビルドする必要がない

**7. depends_on（サービス依存関係）**

```yaml
depends_on:
  encryptor:
    condition: service_healthy
```

**基本的な depends_on:**

```yaml
depends_on:
  - encryptor
```

これだけでも `encryptor` サービスが**起動してから** `k6` サービスが起動します。

**問題点:**

- 起動開始しただけで、まだ準備ができていない可能性がある
- Spring Boot の起動には数秒かかる
- k6 がリクエストを送っても、まだ API が応答できない

**condition の追加:**

```yaml
condition: service_healthy
```

- `encryptor` サービスが **healthy（健全）状態** になるまで待機
- ヘルスチェックが成功してから k6 が起動する

### 7.4 ヘルスチェックの仕組み

#### 7.4.1 encryptor サービスのヘルスチェック設定

```yaml
encryptor:
  # ... 省略 ...
  healthcheck:
    test:
      ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
    start_period: 3s
    interval: 2s
    timeout: 3s
    retries: 10
```

#### 7.4.2 ヘルスチェックの動作フロー

```
コンテナ起動
  ↓
start_period: 3秒待機
  ↓
ヘルスチェック実行 (curl -f .../actuator/health)
  ├─ 成功 → Healthy状態 → k6サービス起動
  └─ 失敗
      ├─ リトライ回数10回未満？
      │   └─ Yes → interval: 2秒待機 → ヘルスチェック再実行
      └─ リトライ回数10回以上 → Unhealthy状態
```

#### 7.4.3 各パラメータの詳細

**test コマンド:**

```yaml
test: ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
```

**分解して説明:**

1. `CMD-SHELL`: シェルコマンドを実行することを宣言
2. `curl -f http://localhost:8080/actuator/health`: 自分自身の health エンドポイントにリクエスト
3. `||`: 前のコマンドが失敗した場合に次を実行（OR 演算子）
4. `exit 1`: エラーコード 1 で終了（ヘルスチェック失敗を明示）

**curl コマンドの詳細:**

- `-f`: HTTP エラー時に失敗扱いにする（デフォルトでは HTTP エラーでも成功扱い）
- `http://localhost:8080/actuator/health`: Spring Boot Actuator のヘルスチェックエンドポイント
- コンテナ内から自分自身（localhost）にアクセス

**Spring Boot Actuator とは:**

Spring Boot の監視・管理機能を提供するモジュールで、以下のようなエンドポイントが自動生成されます：

- `/actuator/health`: アプリケーションの健全性チェック
- `/actuator/metrics`: メトリクス情報
- `/actuator/info`: アプリケーション情報

**レスポンス例:**

```json
{
  "status": "UP"
}
```

**パラメータ設定:**

| パラメータ     | 設定値 | 意味                                            |
| -------------- | ------ | ----------------------------------------------- |
| `start_period` | `3s`   | コンテナ起動後、ヘルスチェック開始まで 3 秒待機 |
| `interval`     | `2s`   | ヘルスチェックを 2 秒間隔で実行                 |
| `timeout`      | `3s`   | 1 回のヘルスチェックのタイムアウト時間          |
| `retries`      | `10`   | 失敗時に 10 回までリトライ                      |

**タイムライン例:**

```
0秒: コンテナ起動
3秒: 1回目のヘルスチェック → 失敗（まだSpring Boot起動中）
5秒: 2回目のヘルスチェック → 失敗
7秒: 3回目のヘルスチェック → 成功 → Healthy状態に
7秒: k6サービスが起動開始
```

### 7.5 ローカルでの負荷テスト実行

#### 7.5.1 Docker Compose の起動

`autoscaling-section` ディレクトリで以下のコマンドを実行します：

```bash
docker compose up
```

> **Note:** `-d`（デタッチモード）オプションは付けずに、ログをリアルタイムで確認します。

#### 7.5.2 起動プロセスの確認

**起動順序:**

```
1. ユーザー: docker compose up を実行
     ↓
2. Docker Compose: encryptorコンテナを起動
     ↓
3. encryptorコンテナ: Spring Boot起動中...
     ↓
4. ヘルスチェック: curl /actuator/health (繰り返し実行)
     ↓
5. encryptorコンテナ: Healthy状態になる
     ↓
6. Docker Compose: k6コンテナを起動
     ↓
7. k6コンテナ: 負荷テスト開始
     ↓
8. 300秒間繰り返し:
   - k6 → encryptor: GET /api/encryptor
   - encryptor → k6: レスポンス
```

#### 7.5.3 コンソール出力の確認

**1. Spring Boot の起動:**

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.x.x)

... Started EncryptorApplication in X.XXX seconds
```

**2. k6 の起動:**

```
          /\      |‾‾| /‾‾/   /‾‾/
     /\  /  \     |  |/  /   /  /
    /  \/    \    |     (   /   ‾‾\
   /          \   |  |\  \ |  (‾)  |
  / __________ \  |__| \__\ \_____/ .io

  execution: local
     script: LoadTest.js
     output: -

  scenarios: (100.00%) 1 scenario, 10 max VUs, 5m30s max duration (incl. graceful stop):
           * default: 10 looping VUs for 5m0s (gracefulStop: 30s)
```

**3. リアルタイムログ（約 1 秒ごとに更新）:**

```
running (0m05.0s), 10/10 VUs, 50 complete and 0 interrupted iterations
default ✓ [======>                               ] 10 VUs  0m05.0s/5m0s

running (0m10.0s), 10/10 VUs, 100 complete and 0 interrupted iterations
default ✓ [=========>                            ] 10 VUs  0m10.0s/5m0s
```

**ログの読み方:**

- `10/10 VUs`: 10 個の仮想ユーザーすべてが実行中
- `50 complete`: 50 回のリクエストが完了
- `0 interrupted`: 中断されたリクエストは 0 件
- プログレスバーで進行状況を表示

#### 7.5.4 負荷テストの停止

300 秒待つのは時間がかかるため、動作確認後は停止します。

**停止方法:**

```bash
Ctrl + C
```

または、別のターミナルで：

```bash
docker compose down
```

#### 7.5.5 テスト完了時の出力例

もし 300 秒間実行し続けた場合、以下のようなサマリーが表示されます：

```
     ✓ status was 200

     checks.........................: 100.00% ✓ 3000       ✗ 0
     data_received..................: 456 kB  1.5 kB/s
     data_sent......................: 270 kB  900 B/s
     http_req_blocked...............: avg=1.2ms   min=0s     med=1ms    max=50ms   p(90)=2ms    p(95)=3ms
     http_req_connecting............: avg=800µs   min=0s     med=600µs  max=30ms   p(90)=1.5ms  p(95)=2ms
     http_req_duration..............: avg=125ms   min=80ms   med=120ms  max=250ms  p(90)=150ms  p(95)=180ms
     http_req_failed................: 0.00%   ✓ 0          ✗ 3000
     http_req_receiving.............: avg=200µs   min=50µs   med=180µs  max=2ms    p(90)=300µs  p(95)=400µs
     http_req_sending...............: avg=100µs   min=30µs   med=90µs   max=1ms    p(90)=150µs  p(95)=200µs
     http_req_tls_handshaking.......: avg=0s      min=0s     med=0s     max=0s     p(90)=0s     p(95)=0s
     http_req_waiting...............: avg=124ms   min=79ms   med=119ms  max=249ms  p(90)=149ms  p(95)=179ms
     http_reqs......................: 3000    10/s
     iteration_duration.............: avg=1.12s   min=1.08s  med=1.12s  max=1.25s  p(90)=1.15s  p(95)=1.18s
     iterations.....................: 3000    10/s
     vus............................: 10      min=10       max=10
     vus_max........................: 10      min=10       max=10
```

**重要な指標:**

- `http_reqs`: 総リクエスト数（3000 回）
- `http_req_failed`: 失敗率（0%が理想）
- `http_req_duration`: レスポンスタイム（今回は暗号化処理により約 125ms）
