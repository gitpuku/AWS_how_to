# AWS CI/CD作業手順書

## 1. GitHubリポジトリの作成

### 1.1 概要
GitHubにリポジトリ(アプリケーションのコードを保存する場所)を作成します。ここにコードをコミットすることで、イベントトリガーとしてCI/CDパイプラインが起動します。

### 1.2 前提条件
- GitHubアカウントを持っていること
- GitHubアカウントにログイン済みであること

### 1.3 リポジトリ作成手順

#### 1.3.1 リポジトリ作成画面へアクセス
1. GitHubアカウントにログインした状態で、以下のURLにアクセスします
   ```
   https://github.com/new
   ```
   ※ログインしていない場合は、ログイン画面が表示されますのでログインしてください

#### 1.3.2 リポジトリの設定
1. **Owner(オーナー)**: 自分のアカウント名を選択します
2. **Repository name(リポジトリ名)**: `ecs-learning-course` と入力します
3. **Description(説明)**: 任意項目のため、省略可能です
4. **Public/Private**: `Private` を選択します
   - Private: 権限のある人(作成者本人)のみ閲覧可能
   - Public: 誰でも閲覧可能
   ※後からPublicに変更することも可能です
5. 以下のオプションは**すべてチェックを外します**(後から追加可能):
   - □ Add a README file
   - □ Add .gitignore
   - □ Choose a license

#### 1.3.3 リポジトリの作成
1. `Create repository` ボタンをクリックします
2. リポジトリが作成されたことを確認します

---

## 2. ローカル環境へのクローン

### 2.1 リポジトリURLのコピー
1. 作成したリポジトリのページで、リポジトリURLをコピーします
   - ページ上部に表示されているHTTPS URLをコピー

### 2.2 ターミナルでのクローン操作

#### 2.2.1 作業ディレクトリへ移動
```bash
cd ~/Desktop
```
※お好みのディレクトリに移動してください

#### 2.2.2 リポジトリをクローン
```bash
git clone <コピーしたURL>
```

例:
```bash
git clone https://github.com/your-account/ecs-learning-course.git
```

#### 2.2.3 クローン完了の確認
1. ディレクトリが作成されたことを確認
   ```bash
   ls
   ```

2. クローンしたディレクトリ内に移動
   ```bash
   cd ecs-learning-course
   ```

3. 現時点では空のディレクトリであることを確認
   ```bash
   ls
   ```

---

## 3. 必要なAWSリソースの整理

### 3.1 概要
CI/CDパイプラインを構築する前に、必要なAWSリソースを整理し、新規作成が必要なものと既存のものを確認します。

### 3.2 リソース一覧

#### 3.2.1 ECS関連リソース

| リソース | 名前 | 状態 | 備考 |
|---------|------|------|------|
| **ECSクラスター** | `my-app-cluster` | 既存 | 過去のセクションで作成済み |
| **ECSサービス** | `my-app-api-service` | **【新規】** | 今回のセクションで作成 |
| **タスク定義** | `my-app-api` | **【新規】** | 今回のセクションで作成 |
| **ECRリポジトリ** | `my-app-api` | **【新規】** | 今回のセクションで作成 |

#### 3.2.2 ネットワーク・セキュリティ関連リソース

| リソース | 名前 | 状態 | 備考 |
|---------|------|------|------|
| **VPC** | `my-workspace-vpc` | 既存 | 過去のセクションで作成済み |
| **サブネット(パブリック)** | `my-workspace-subnet-public1-a` | 既存 | 過去のセクションで作成済み |
| **サブネット(プライベート)** | `my-workspace-subnet-private1-a` | 既存 | 過去のセクションで作成済み |
| **セキュリティグループ** | `my-app-api-sg` | **【新規】** | 今回のセクションで作成 |

#### 3.2.3 IAM関連リソース

| リソース | 名前 | 状態 | 備考 |
|---------|------|------|------|
| **タスク実行ロール** | `ecsTaskExecutionRole` | 既存 | 過去のセクションで作成済み |

### 3.3 前提条件の確認

> **重要**: 以下のリソースが既に存在していることを前提として、このコースは進めていきます。もし削除されている場合は、「AWS_ECS作成手順書.md」を参照して再作成してください。

**既存リソースの確認項目:**
- [ ] ECSクラスター `my-app-cluster` が存在する
- [ ] VPC `my-workspace-vpc` が存在する
- [ ] パブリックサブネット `my-workspace-subnet-public1-a` が存在する
- [ ] プライベートサブネット `my-workspace-subnet-private1-a` が存在する
- [ ] タスク実行ロール `ecsTaskExecutionRole` が存在する

### 3.4 作業の流れ

これから、以下の順序で**【新規】**リソースを作成していきます:

1. タスク定義 `my-app-api` の作成(一時的なダミー設定)
2. ECRリポジトリ `my-app-api` の作成
3. ECSサービス `my-app-api-service` の作成

> **注意**: 本来ECSサービスを作成する際にはタスク定義が必要ですが、タスク定義の作成時にはECRのイメージURIが必要になります。しかし、ECRリポジトリはまだ作成していないため、イメージURIが存在しません。
> 
> そのため、以下の手順で進めます:
> 1. タスク定義を**ダミーのイメージURI**で作成
> 2. ECRリポジトリを作成
> 3. ECSサービスを作成
> 4. 後ほどCI/CDパイプラインで正しいイメージURIに更新

---

## 4. タスク定義の作成

### 4.1 概要
ECSサービスを作成する前に、タスク定義を作成します。タスク定義には、コンテナの設定(イメージURI、CPU、メモリなど)を定義します。

> **重要**: この段階ではECRリポジトリがまだ存在しないため、一時的にAWSが公開しているNGINXのイメージを使用します。後ほどCI/CDパイプラインで正しいイメージに更新されます。

### 4.2 手順

#### 4.2.1 ECSコンソールへアクセス
1. AWSマネジメントコンソールで「ECS」を検索し、「Elastic Container Service」を選択します

#### 4.2.2 タスク定義作成画面へ移動
1. 左側のメニューから「タスク定義」をクリックします
2. 「新しいタスク定義の作成」ボタンをクリックします

#### 4.2.3 タスク定義の基本設定

**タスク定義ファミリー名:**
```
my-app-api
```

**インフラストラクチャの要件:**
- **起動タイプ**: `AWS Fargate` にチェック
- **オペレーティングシステム/アーキテクチャ**: 
  - OS: `Linux`
  - アーキテクチャ: `X86_64`
  
  > **補足**: `X86_64`はIntelチップ、`ARM64`はARMチップです。要件に応じて選択してください。このコースでは`X86_64`を使用します。

**タスクサイズ:**
- **CPU**: `0.5 vCPU`
  - 最小の`0.25 vCPU`だとSpring Bootを動かすには不十分なため、`0.5 vCPU`を選択します
- **メモリ**: `1 GB`
  - 最小の`1 GB`を選択します

> **注意**: これらのリソース設定は後ほどCI/CDパイプラインで更新されるため、ここでの設定値は一時的なものです。

**タスクロール:**
- 空欄のまま(設定不要)

**タスク実行ロール:**
- デフォルトのまま(`ecsTaskExecutionRole`が自動選択されます)

#### 4.2.4 コンテナの定義

画面を下にスクロールし、「コンテナ」セクションで以下を設定します。

**コンテナ-1:**

**基本設定:**
- **名前**: `dummy`
  - 一時的なダミーコンテナなので`dummy`と命名します
  - 後ほどCI/CDで正しい名前に更新されます
  
- **イメージURI**: 
  ```
  public.ecr.aws/nginx/nginx:stable-perl
  ```
  - AWSが公開しているNGINXイメージを一時的に使用します
  - ECRリポジトリ作成後、CI/CDで正しいSpring BootのイメージURIに更新されます

**ポートマッピング:**
- デフォルトのまま(後ほどCI/CDで更新されます)

**環境変数:**
- 設定不要

**ログ収集:**
- **ログ収集の使用** にチェックを入れます
  - トラブルシューティング時にログが必要になるため、有効化します

**その他の設定:**
- デフォルトのまま

#### 4.2.5 タスク定義の作成
1. 画面下部の「作成」ボタンをクリックします
2. タスク定義 `my-app-api` のリビジョン `1` が作成されます

---

## 5. ECRリポジトリの作成

### 5.1 概要
Dockerイメージを保存するためのプライベートなコンテナレジストリ(ECRリポジトリ)を作成します。

### 5.2 手順

#### 5.2.1 ECRリポジトリ作成画面へ移動
1. ECSコンソールの左側メニューから「リポジトリ」をクリックします
2. 「リポジトリを作成」ボタンをクリックします

#### 5.2.2 リポジトリの設定

**可視性設定:**
- 「プライベート」を選択します
  - 公開する必要がないため、プライベートリポジトリとします

**リポジトリ名:**
```
my-app-api
```

**その他の設定:**
- デフォルトのまま(変更不要)

#### 5.2.3 リポジトリの作成
1. 「リポジトリを作成」ボタンをクリックします
2. リポジトリ `my-app-api` が作成されます
3. 現時点ではイメージは空の状態です

---

## 6. ECSサービスの作成

### 6.1 概要
タスク定義とECRリポジトリの準備が完了したので、ECSサービスを作成します。ECSサービスは、タスク定義に基づいてコンテナを起動し、管理します。

### 6.2 手順

#### 6.2.1 クラスター選択
1. ECSコンソールで「クラスター」をクリックします
2. クラスター一覧から `my-app-cluster` をクリックします

#### 6.2.2 サービス作成画面へ移動
1. 「サービス」タブで「作成」ボタンをクリックします

#### 6.2.3 環境設定

**コンピューティング設定:**
- **コンピューティングオプション**: `起動タイプ`
- **起動タイプ**: `FARGATE`
- **プラットフォームバージョン**: `LATEST`

**アプリケーションタイプ:**
- `サービス` を選択

**タスク定義:**
- **ファミリー**: `my-app-api`
- **リビジョン**: `1 (latest)`

**サービス名:**
```
my-app-api-service
```

**サービスタイプ:**
- `レプリカ` を選択

**必要なタスク:**
```
1
```
- 1つのタスク(コンテナ)のみ起動します
- 複数指定すると、同じタスク定義を使用した複数のコンテナが起動します

#### 6.2.4 デプロイ設定

**デプロイオプション:**
- デフォルトの `ローリングアップデート` のまま
  - Blue/Greenデプロイは設定が複雑で費用もかかるため、今回は使用しません

**サービスコネクト:**
- デフォルトのまま(設定不要)

**サービス検出:**
- デフォルトのまま(設定不要)

#### 6.2.5 ネットワーキング設定

**VPC:**
- `my-workspace-vpc` を選択します

**サブネット:**
- **パブリックサブネット2つ**にチェックを入れます
- プライベートサブネットのチェックは外します
  - パブリックサブネットを使用することで、インターネットからのアクセスを可能にします

**セキュリティグループ:**
1. 「新しいセキュリティグループの作成」を選択します
2. 以下の情報を入力:

**セキュリティグループ名:**
```
my-app-api-sg
```

**セキュリティグループの説明:**
```
For my-app-api-service
```

**インバウンドルール:**
- **タイプ**: `HTTP`
- **プロトコル**: `TCP`
- **ポート範囲**: `80`
- **ソース**: `Anywhere (0.0.0.0/0)`
  
  > **セキュリティに関する注意**: 
  > - より厳格にする場合は、カスタムで自分のIPアドレスのみを許可することを推奨します
  > - 今回は設定を簡略化するため、Anywhere(どこからでもアクセス可能)に設定します

**パブリックIP:**
- `オン` になっていることを確認します
  - インターネットからアクセスするために必要です

#### 6.2.6 その他の設定

**ロードバランシング:**
- `なし` を選択

**サービスのオートスケーリング:**
- デフォルトのまま(設定不要)

**タグ:**
- デフォルトのまま(設定不要)

#### 6.2.7 サービスの作成
1. 「作成」ボタンをクリックします
2. デプロイが開始されます

#### 6.2.8 デプロイ完了の確認

**デプロイ状態の確認:**
1. サービス作成画面で「正常にデプロイされました」と表示されるまで待ちます(数分かかります)
2. ECSコンソールの「クラスター」→「my-app-cluster」→「サービス」タブで、`my-app-api-service` が表示されることを確認します

---

## 7. 動作確認(ダミーコンテナの確認)

### 7.1 概要
作成したECSサービスが正常に動作しているか確認します。この段階ではまだダミーのNGINXコンテナが動作している状態です。

### 7.2 手順

#### 7.2.1 タスクの確認
1. ECSコンソールで「クラスター」→「my-app-cluster」→「サービス」→「my-app-api-service」をクリックします
2. 「タスク」タブをクリックします
3. タスク一覧に1つのタスクが表示され、ステータスが「実行中(RUNNING)」になっていることを確認します

#### 7.2.2 コンテナの確認
1. 表示されているタスクのIDをクリックします
2. 「コンテナ」セクションで、コンテナ名 `dummy` のステータスが「実行中(RUNNING)」になっていることを確認します

#### 7.2.3 パブリックIPの確認とアクセス
1. タスク詳細画面の「ネットワーキング」セクションで、「パブリックIP」が割り当てられていることを確認します
2. パブリックIPをコピーします
3. ブラウザで以下のURLにアクセスします:
   ```
   http://<パブリックIP>
   ```
   
   例:
   ```
   http://54.123.45.67
   ```

#### 7.2.4 確認結果

ブラウザに「**Welcome to nginx!**」と表示されれば、ECSサービスが正常に動作しています。

**なぜNGINXが表示されるのか:**
- タスク定義 `my-app-api` のリビジョン1で、NGINXのイメージURI(`public.ecr.aws/nginx/nginx:stable-perl`)を指定しているため
- NGINXコンテナは起動時に80番ポートで「Welcome to nginx!」ページを表示します
- まだSpring BootのWEB APIコンテナは作成していないため、この状態は正常です

**次のステップ:**
- この後、Spring BootのWEB APIアプリケーションをローカルで準備し、CI/CDパイプラインを構築します
- CI/CDパイプラインにより、タスク定義が正しいイメージURIに更新され、Spring Bootアプリケーションが動作するようになります

---

## 8. Spring Boot WEB APIのセットアップ

### 8.1 概要
Spring Bootを使用したWEB APIアプリケーションをローカル環境にセットアップします。このコースはSpring Bootの学習が目的ではないため、すでに作成済みのコードを使用します。

> **注意**: 
> - 今回はSpring Bootを使用しますが、Ruby on Rails、Django、Next.jsなど他のWebフレームワークでも同じ考え方が適用できます
> - 実務では自分の環境に応じて応用してください

### 8.2 参考リポジトリ

このセクションで使用するコードは、以下のGitHubリポジトリで公開されています:

```
https://github.com/kentny/ecs-learning-course
```

### 8.3 手順

#### 8.3.1 ソースコードのダウンロード

1. 上記のGitHubリポジトリにアクセスします
2. ページ右下の「**Tags**」をクリックします
3. `cicd-hello-api` というタグを探します
4. タグ名の右側にある **ZIPアイコン** をクリックしてダウンロードします

#### 8.3.2 ダウンロードファイルの解凍

1. ダウンロードされたZIPファイルをダブルクリックして解凍します
2. 解凍すると `cicd-section` というディレクトリが含まれています

#### 8.3.3 ファイルの配置

**ターミナルで操作する場合:**

1. 以前作成したGitHubリポジトリをクローンしたディレクトリに移動します:
   ```bash
   cd ~/Desktop/ecs-learning-course
   ```
   ※クローンした場所に応じて適宜変更してください

2. 現在のディレクトリ構造を確認します:
   ```bash
   ls
   ```
   現時点では空のはずです。

3. ダウンロードフォルダから `cicd-section` ディレクトリを移動します:
   ```bash
   mv ~/Downloads/ecs-learning-course-cicd-hello-api/cicd-section .
   ```

4. ディレクトリが移動されたことを確認します:
   ```bash
   ls
   ```
   `cicd-section` ディレクトリが表示されれば成功です。

5. ダウンロードフォルダの不要なファイルを削除します:
   ```bash
   rm -rf ~/Downloads/ecs-learning-course-cicd-hello-api
   rm ~/Downloads/ecs-learning-course-cicd-hello-api.zip
   ```

#### 8.3.4 VS Codeでプロジェクトを開く

1. VS Codeを起動します
2. メニューから「ファイル」→「フォルダーを開く」を選択します
3. `ecs-learning-course/cicd-section/api` ディレクトリを選択します
   - 例: `/home/<ユーザー名>/Desktop/ecs-learning-course/cicd-section/api`
4. 「OK」ボタンをクリックします

> **補足**: コマンドラインから直接開く場合:
> ```bash
> code ~/Desktop/ecs-learning-course/cicd-section/api
> ```

#### 8.3.5 プロジェクト構造の確認

VS Codeでプロジェクトが開いたら、以下のファイル・ディレクトリが存在することを確認します:

```
api/
├── Dockerfile          ← Docker用の設定ファイル
├── build.gradle        ← Gradleビルド設定
├── settings.gradle
└── src/
    ├── main/
    │   ├── java/
    │   │   └── controller/
    │   │       └── HelloController.java  ← WEB APIのコントローラー
    │   └── resources/
    └── test/
```

**重要なファイル:**

**Dockerfile:**
- コンテナイメージをビルドするための設定ファイル
- Spring Bootアプリケーションを実行する環境を定義

**HelloController.java:**
- `/api/hello` エンドポイントにGETリクエストが来た際に、固定文字列 `"Hello"` を返すシンプルなAPI
- Spring Bootの文法で実装されています

### 8.4 ローカル環境での動作確認

#### 8.4.1 概要
ローカルマシンでSpring Boot APIを起動し、正常に動作することを確認します。実行環境としてDockerコンテナを使用します。

> **なぜDockerを使用するのか:**
> - Java実行環境(JDK 21)やGradleを直接PCにインストールする必要がない
> - 環境の差異による問題を回避できる
> - 実際にAWS ECSで動作させる環境と同じ構成で確認できる

#### 8.4.2 Dockerfileの確認

`Dockerfile` の内容を簡単に確認します:

```dockerfile
# Java 21とGradleを含むベースイメージを使用
FROM gradle:jdk21

# 作業ディレクトリを設定
WORKDIR /app

# プロジェクトファイルをコンテナにコピー
COPY . .

# Spring Bootアプリケーションを起動
CMD ["./gradlew", "bootRun"]
```

**解説:**
- `gradle:jdk21` イメージを使用(Java 21 + Gradle環境)
- `/app` を作業ディレクトリに設定
- プロジェクトファイル一式をコンテナ内にコピー
- `./gradlew bootRun` コマンドでSpring Bootを起動

#### 8.4.3 Dockerイメージのビルド

1. VS Codeでターミナルを開きます:
   - メニューから「ターミナル」→「新しいターミナル」を選択

2. 現在のディレクトリが `api` であることを確認します:
   ```bash
   pwd
   ```

3. Dockerイメージをビルドします:
   ```bash
   docker image build -t hello-world-api .
   ```

   **コマンドの説明:**
   - `docker image build`: Dockerイメージをビルド
   - `-t hello-world-api`: イメージに `hello-world-api` という名前(タグ)を付ける
   - `.`: カレントディレクトリをビルドコンテキストとして使用(Dockerfileを含む)

4. ビルドが完了するまで待ちます(初回は数分かかります)
   - `gradle:jdk21` イメージのダウンロード
   - 依存関係のダウンロード
   - プロジェクトのビルド

5. ビルド完了後、イメージが作成されたことを確認します:
   ```bash
   docker image ls
   ```

   以下のように `hello-world-api` が表示されれば成功です:
   ```
   REPOSITORY          TAG       IMAGE ID       CREATED          SIZE
   hello-world-api     latest    xxxxxxxxxxxx   30 seconds ago   xxx MB
   ```

#### 8.4.4 Dockerコンテナの起動

1. ビルドしたイメージからコンテナを起動します:
   ```bash
   docker container run --rm -p 8080:8080 hello-world-api
   ```

   **コマンドの説明:**
   - `docker container run`: コンテナを起動
   - `--rm`: コンテナ停止時に自動的にコンテナを削除
   - `-p 8080:8080`: ホストの8080番ポートとコンテナの8080番ポートをマッピング
     - Spring Bootはデフォルトで8080番ポートでリッスンします
   - `hello-world-api`: 使用するイメージ名

2. 起動処理が開始されます(1〜2分かかります)
   - 依存関係のダウンロード
   - アプリケーションの起動

3. 以下のようなSpringロゴと起動完了メッセージが表示されれば成功です:
   ```
     .   ____          _            __ _ _
    /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
   ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
    \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
     '  |____| .__|_| |_|_| |_\__, | / / / /
    =========|_|==============|___/=/_/_/_/
   
   ... (起動ログ)
   ```

#### 8.4.5 APIの動作確認

1. コンテナが起動したまま、新しいブラウザタブを開きます

2. 以下のURLにアクセスします:
   ```
   http://localhost:8080/api/hello
   ```

3. ブラウザに以下のように表示されれば成功です:
   ```
   Hello
   ```

**動作確認のポイント:**
- エンドポイント `/api/hello` にアクセス
- レスポンスとして固定文字列 `"Hello"` が返される
- これは `HelloController.java` で実装されたシンプルなAPIです

#### 8.4.6 コンテナの停止

1. ターミナルに戻り、`Ctrl + C` を押してコンテナを停止します
2. `--rm` オプションを指定しているため、コンテナは自動的に削除されます



