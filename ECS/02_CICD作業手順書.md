# AWS CI/CD 作業手順書

## 1. GitHub リポジトリの作成

### 1.1 概要

GitHub にリポジトリ(アプリケーションのコードを保存する場所)を作成します。ここにコードをコミットすることで、イベントトリガーとして CI/CD パイプラインが起動します。

### 1.2 前提条件

- GitHub アカウントを持っていること
- GitHub アカウントにログイン済みであること

### 1.3 リポジトリ作成手順

#### 1.3.1 リポジトリ作成画面へアクセス

1. GitHub アカウントにログインした状態で、以下の URL にアクセスします
   ```
   https://github.com/new
   ```
   ※ログインしていない場合は、ログイン画面が表示されますのでログインしてください

#### 1.3.2 リポジトリの設定

1. **Owner(オーナー)**: 自分のアカウント名を選択します
2. **Repository name(リポジトリ名)**: `ecs-learning-course` と入力します
3. **Description(説明)**: 任意項目のため、省略可能です
4. **Public/Private**: `Private` を選択します
   - Private: 権限のある人(作成者本人)のみ閲覧可能
   - Public: 誰でも閲覧可能
     ※後から Public に変更することも可能です
5. 以下のオプションは**すべてチェックを外します**(後から追加可能):
   - □ Add a README file
   - □ Add .gitignore
   - □ Choose a license

#### 1.3.3 リポジトリの作成

1. `Create repository` ボタンをクリックします
2. リポジトリが作成されたことを確認します

---

## 2. ローカル環境へのクローン

### 2.1 リポジトリ URL のコピー

1. 作成したリポジトリのページで、リポジトリ URL をコピーします
   - ページ上部に表示されている HTTPS URL をコピー

### 2.2 ターミナルでのクローン操作

#### 2.2.1 作業ディレクトリへ移動

```bash
cd ~/Desktop
```

※お好みのディレクトリに移動してください

#### 2.2.2 リポジトリをクローン

```bash
git clone <コピーしたURL>
```

例:

```bash
git clone https://github.com/your-account/ecs-learning-course.git
```

#### 2.2.3 クローン完了の確認

1. ディレクトリが作成されたことを確認

   ```bash
   ls
   ```

2. クローンしたディレクトリ内に移動

   ```bash
   cd ecs-learning-course
   ```

3. 現時点では空のディレクトリであることを確認
   ```bash
   ls
   ```

---

## 3. 必要な AWS リソースの整理

### 3.1 概要

CI/CD パイプラインを構築する前に、必要な AWS リソースを整理し、新規作成が必要なものと既存のものを確認します。

### 3.2 リソース一覧

#### 3.2.1 ECS 関連リソース

| リソース           | 名前                 | 状態         | 備考                       |
| ------------------ | -------------------- | ------------ | -------------------------- |
| **ECS クラスター** | `my-app-cluster`     | 既存         | 過去のセクションで作成済み |
| **ECS サービス**   | `my-app-api-service` | **【新規】** | 今回のセクションで作成     |
| **タスク定義**     | `my-app-api`         | **【新規】** | 今回のセクションで作成     |
| **ECR リポジトリ** | `my-app-api`         | **【新規】** | 今回のセクションで作成     |

#### 3.2.2 ネットワーク・セキュリティ関連リソース

| リソース                     | 名前                             | 状態         | 備考                       |
| ---------------------------- | -------------------------------- | ------------ | -------------------------- |
| **VPC**                      | `my-workspace-vpc`               | 既存         | 過去のセクションで作成済み |
| **サブネット(パブリック)**   | `my-workspace-subnet-public1-a`  | 既存         | 過去のセクションで作成済み |
| **サブネット(プライベート)** | `my-workspace-subnet-private1-a` | 既存         | 過去のセクションで作成済み |
| **セキュリティグループ**     | `my-app-api-sg`                  | **【新規】** | 今回のセクションで作成     |

#### 3.2.3 IAM 関連リソース

| リソース             | 名前                   | 状態 | 備考                       |
| -------------------- | ---------------------- | ---- | -------------------------- |
| **タスク実行ロール** | `ecsTaskExecutionRole` | 既存 | 過去のセクションで作成済み |

### 3.3 前提条件の確認

> **重要**: 以下のリソースが既に存在していることを前提として、このコースは進めていきます。もし削除されている場合は、「AWS_ECS 作成手順書.md」を参照して再作成してください。

**既存リソースの確認項目:**

- [ ] ECS クラスター `my-app-cluster` が存在する
- [ ] VPC `my-workspace-vpc` が存在する
- [ ] パブリックサブネット `my-workspace-subnet-public1-a` が存在する
- [ ] プライベートサブネット `my-workspace-subnet-private1-a` が存在する
- [ ] タスク実行ロール `ecsTaskExecutionRole` が存在する

### 3.4 作業の流れ

これから、以下の順序で**【新規】**リソースを作成していきます:

1. タスク定義 `my-app-api` の作成(一時的なダミー設定)
2. ECR リポジトリ `my-app-api` の作成
3. ECS サービス `my-app-api-service` の作成

> **注意**: 本来 ECS サービスを作成する際にはタスク定義が必要ですが、タスク定義の作成時には ECR のイメージ URI が必要になります。しかし、ECR リポジトリはまだ作成していないため、イメージ URI が存在しません。
>
> そのため、以下の手順で進めます:
>
> 1. タスク定義を**ダミーのイメージ URI**で作成
> 2. ECR リポジトリを作成
> 3. ECS サービスを作成
> 4. 後ほど CI/CD パイプラインで正しいイメージ URI に更新

---

## 4. タスク定義の作成

### 4.1 概要

ECS サービスを作成する前に、タスク定義を作成します。タスク定義には、コンテナの設定(イメージ URI、CPU、メモリなど)を定義します。

> **重要**: この段階では ECR リポジトリがまだ存在しないため、一時的に AWS が公開している NGINX のイメージを使用します。後ほど CI/CD パイプラインで正しいイメージに更新されます。

### 4.2 手順

#### 4.2.1 ECS コンソールへアクセス

1. AWS マネジメントコンソールで「ECS」を検索し、「Elastic Container Service」を選択します

#### 4.2.2 タスク定義作成画面へ移動

1. 左側のメニューから「タスク定義」をクリックします
2. 「新しいタスク定義の作成」ボタンをクリックします

#### 4.2.3 タスク定義の基本設定

**タスク定義ファミリー名:**

```
my-app-api
```

**インフラストラクチャの要件:**

- **起動タイプ**: `AWS Fargate` にチェック
- **オペレーティングシステム/アーキテクチャ**:

  - OS: `Linux`
  - アーキテクチャ: `X86_64`

  > **補足**: `X86_64`は Intel チップ、`ARM64`は ARM チップです。要件に応じて選択してください。このコースでは`X86_64`を使用します。

**タスクサイズ:**

- **CPU**: `0.5 vCPU`
  - 最小の`0.25 vCPU`だと Spring Boot を動かすには不十分なため、`0.5 vCPU`を選択します
- **メモリ**: `1 GB`
  - 最小の`1 GB`を選択します

> **注意**: これらのリソース設定は後ほど CI/CD パイプラインで更新されるため、ここでの設定値は一時的なものです。

**タスクロール:**

- 空欄のまま(設定不要)

**タスク実行ロール:**

- デフォルトのまま(`ecsTaskExecutionRole`が自動選択されます)

#### 4.2.4 コンテナの定義

画面を下にスクロールし、「コンテナ」セクションで以下を設定します。

**コンテナ-1:**

**基本設定:**

- **名前**: `dummy`
  - 一時的なダミーコンテナなので`dummy`と命名します
  - 後ほど CI/CD で正しい名前に更新されます
- **イメージ URI**:
  ```
  public.ecr.aws/nginx/nginx:stable-perl
  ```
  - AWS が公開している NGINX イメージを一時的に使用します
  - ECR リポジトリ作成後、CI/CD で正しい Spring Boot のイメージ URI に更新されます

**ポートマッピング:**

- デフォルトのまま(後ほど CI/CD で更新されます)

**環境変数:**

- 設定不要

**ログ収集:**

- **ログ収集の使用** にチェックを入れます
  - トラブルシューティング時にログが必要になるため、有効化します

**その他の設定:**

- デフォルトのまま

#### 4.2.5 タスク定義の作成

1. 画面下部の「作成」ボタンをクリックします
2. タスク定義 `my-app-api` のリビジョン `1` が作成されます

---

## 5. ECR リポジトリの作成

### 5.1 概要

Docker イメージを保存するためのプライベートなコンテナレジストリ(ECR リポジトリ)を作成します。

### 5.2 手順

#### 5.2.1 ECR リポジトリ作成画面へ移動

1. ECS コンソールの左側メニューから「リポジトリ」をクリックします
2. 「リポジトリを作成」ボタンをクリックします

#### 5.2.2 リポジトリの設定

**可視性設定:**

- 「プライベート」を選択します
  - 公開する必要がないため、プライベートリポジトリとします

**リポジトリ名:**

```
my-app-api
```

**その他の設定:**

- デフォルトのまま(変更不要)

#### 5.2.3 リポジトリの作成

1. 「リポジトリを作成」ボタンをクリックします
2. リポジトリ `my-app-api` が作成されます
3. 現時点ではイメージは空の状態です

---

## 6. ECS サービスの作成

### 6.1 概要

タスク定義と ECR リポジトリの準備が完了したので、ECS サービスを作成します。ECS サービスは、タスク定義に基づいてコンテナを起動し、管理します。

### 6.2 手順

#### 6.2.1 クラスター選択

1. ECS コンソールで「クラスター」をクリックします
2. クラスター一覧から `my-app-cluster` をクリックします

#### 6.2.2 サービス作成画面へ移動

1. 「サービス」タブで「作成」ボタンをクリックします

#### 6.2.3 環境設定

**コンピューティング設定:**

- **コンピューティングオプション**: `起動タイプ`
- **起動タイプ**: `FARGATE`
- **プラットフォームバージョン**: `LATEST`

**アプリケーションタイプ:**

- `サービス` を選択

**タスク定義:**

- **ファミリー**: `my-app-api`
- **リビジョン**: `1 (latest)`

**サービス名:**

```
my-app-api-service
```

**サービスタイプ:**

- `レプリカ` を選択

**必要なタスク:**

```
1
```

- 1 つのタスク(コンテナ)のみ起動します
- 複数指定すると、同じタスク定義を使用した複数のコンテナが起動します

#### 6.2.4 デプロイ設定

**デプロイオプション:**

- デフォルトの `ローリングアップデート` のまま
  - Blue/Green デプロイは設定が複雑で費用もかかるため、今回は使用しません

**サービスコネクト:**

- デフォルトのまま(設定不要)

**サービス検出:**

- デフォルトのまま(設定不要)

#### 6.2.5 ネットワーキング設定

**VPC:**

- `my-workspace-vpc` を選択します

**サブネット:**

- **パブリックサブネット 2 つ**にチェックを入れます
- プライベートサブネットのチェックは外します
  - パブリックサブネットを使用することで、インターネットからのアクセスを可能にします

**セキュリティグループ:**

1. 「新しいセキュリティグループの作成」を選択します
2. 以下の情報を入力:

**セキュリティグループ名:**

```
my-app-api-sg
```

**セキュリティグループの説明:**

```
For my-app-api-service
```

**インバウンドルール:**

- **タイプ**: `HTTP`
- **プロトコル**: `TCP`
- **ポート範囲**: `80`
- **ソース**: `Anywhere (0.0.0.0/0)`

  > **セキュリティに関する注意**:
  >
  > - より厳格にする場合は、カスタムで自分の IP アドレスのみを許可することを推奨します
  > - 今回は設定を簡略化するため、Anywhere(どこからでもアクセス可能)に設定します

**パブリック IP:**

- `オン` になっていることを確認します
  - インターネットからアクセスするために必要です

#### 6.2.6 その他の設定

**ロードバランシング:**

- `なし` を選択

**サービスのオートスケーリング:**

- デフォルトのまま(設定不要)

**タグ:**

- デフォルトのまま(設定不要)

#### 6.2.7 サービスの作成

1. 「作成」ボタンをクリックします
2. デプロイが開始されます

#### 6.2.8 デプロイ完了の確認

**デプロイ状態の確認:**

1. サービス作成画面で「正常にデプロイされました」と表示されるまで待ちます(数分かかります)
2. ECS コンソールの「クラスター」→「my-app-cluster」→「サービス」タブで、`my-app-api-service` が表示されることを確認します

---

## 7. 動作確認(ダミーコンテナの確認)

### 7.1 概要

作成した ECS サービスが正常に動作しているか確認します。この段階ではまだダミーの NGINX コンテナが動作している状態です。

### 7.2 手順

#### 7.2.1 タスクの確認

1. ECS コンソールで「クラスター」→「my-app-cluster」→「サービス」→「my-app-api-service」をクリックします
2. 「タスク」タブをクリックします
3. タスク一覧に 1 つのタスクが表示され、ステータスが「実行中(RUNNING)」になっていることを確認します

#### 7.2.2 コンテナの確認

1. 表示されているタスクの ID をクリックします
2. 「コンテナ」セクションで、コンテナ名 `dummy` のステータスが「実行中(RUNNING)」になっていることを確認します

#### 7.2.3 パブリック IP の確認とアクセス

1. タスク詳細画面の「ネットワーキング」セクションで、「パブリック IP」が割り当てられていることを確認します
2. パブリック IP をコピーします
3. ブラウザで以下の URL にアクセスします:

   ```
   http://<パブリックIP>
   ```

   例:

   ```
   http://54.123.45.67
   ```

#### 7.2.4 確認結果

ブラウザに「**Welcome to nginx!**」と表示されれば、ECS サービスが正常に動作しています。

**なぜ NGINX が表示されるのか:**

- タスク定義 `my-app-api` のリビジョン 1 で、NGINX のイメージ URI(`public.ecr.aws/nginx/nginx:stable-perl`)を指定しているため
- NGINX コンテナは起動時に 80 番ポートで「Welcome to nginx!」ページを表示します
- まだ Spring Boot の WEB API コンテナは作成していないため、この状態は正常です

**次のステップ:**

- この後、Spring Boot の WEB API アプリケーションをローカルで準備し、CI/CD パイプラインを構築します
- CI/CD パイプラインにより、タスク定義が正しいイメージ URI に更新され、Spring Boot アプリケーションが動作するようになります

---

## 8. Spring Boot WEB API のセットアップ

### 8.1 概要

Spring Boot を使用した WEB API アプリケーションをローカル環境にセットアップします。このコースは Spring Boot の学習が目的ではないため、すでに作成済みのコードを使用します。

> **注意**:
>
> - 今回は Spring Boot を使用しますが、Ruby on Rails、Django、Next.js など他の Web フレームワークでも同じ考え方が適用できます
> - 実務では自分の環境に応じて応用してください

### 8.2 参考リポジトリ

このセクションで使用するコードは、以下の GitHub リポジトリで公開されています:

```
https://github.com/kentny/ecs-learning-course
```

### 8.3 手順

#### 8.3.1 ソースコードのダウンロード

1. 上記の GitHub リポジトリにアクセスします
2. ページ右下の「**Tags**」をクリックします
3. `cicd-hello-api` というタグを探します
4. タグ名の右側にある **ZIP アイコン** をクリックしてダウンロードします

#### 8.3.2 ダウンロードファイルの解凍

1. ダウンロードされた ZIP ファイルをダブルクリックして解凍します
2. 解凍すると `cicd-section` というディレクトリが含まれています

#### 8.3.3 ファイルの配置

**ターミナルで操作する場合:**

1. 以前作成した GitHub リポジトリをクローンしたディレクトリに移動します:

   ```bash
   cd ~/Desktop/ecs-learning-course
   ```

   ※クローンした場所に応じて適宜変更してください

2. 現在のディレクトリ構造を確認します:

   ```bash
   ls
   ```

   現時点では空のはずです。

3. ダウンロードフォルダから `cicd-section` ディレクトリを移動します:

   ```bash
   mv ~/Downloads/ecs-learning-course-cicd-hello-api/cicd-section .
   ```

4. ディレクトリが移動されたことを確認します:

   ```bash
   ls
   ```

   `cicd-section` ディレクトリが表示されれば成功です。

5. ダウンロードフォルダの不要なファイルを削除します:
   ```bash
   rm -rf ~/Downloads/ecs-learning-course-cicd-hello-api
   rm ~/Downloads/ecs-learning-course-cicd-hello-api.zip
   ```

#### 8.3.4 VS Code でプロジェクトを開く

1. VS Code を起動します
2. メニューから「ファイル」→「フォルダーを開く」を選択します
3. `ecs-learning-course/cicd-section/api` ディレクトリを選択します
   - 例: `/home/<ユーザー名>/Desktop/ecs-learning-course/cicd-section/api`
4. 「OK」ボタンをクリックします

> **補足**: コマンドラインから直接開く場合:
>
> ```bash
> code ~/Desktop/ecs-learning-course/cicd-section/api
> ```

#### 8.3.5 プロジェクト構造の確認

VS Code でプロジェクトが開いたら、以下のファイル・ディレクトリが存在することを確認します:

```
api/
├── Dockerfile          ← Docker用の設定ファイル
├── build.gradle        ← Gradleビルド設定
├── settings.gradle
└── src/
    ├── main/
    │   ├── java/
    │   │   └── controller/
    │   │       └── HelloController.java  ← WEB APIのコントローラー
    │   └── resources/
    └── test/
```

**重要なファイル:**

**Dockerfile:**

- コンテナイメージをビルドするための設定ファイル
- Spring Boot アプリケーションを実行する環境を定義

**HelloController.java:**

- `/api/hello` エンドポイントに GET リクエストが来た際に、固定文字列 `"Hello"` を返すシンプルな API
- Spring Boot の文法で実装されています

### 8.4 ローカル環境での動作確認

#### 8.4.1 概要

ローカルマシンで Spring Boot API を起動し、正常に動作することを確認します。実行環境として Docker コンテナを使用します。

> **なぜ Docker を使用するのか:**
>
> - Java 実行環境(JDK 21)や Gradle を直接 PC にインストールする必要がない
> - 環境の差異による問題を回避できる
> - 実際に AWS ECS で動作させる環境と同じ構成で確認できる

#### 8.4.2 Dockerfile の確認

`Dockerfile` の内容を簡単に確認します:

```dockerfile
# Java 21とGradleを含むベースイメージを使用
FROM gradle:jdk21

# 作業ディレクトリを設定
WORKDIR /app

# プロジェクトファイルをコンテナにコピー
COPY . .

# Spring Bootアプリケーションを起動
CMD ["./gradlew", "bootRun"]
```

**解説:**

- `gradle:jdk21` イメージを使用(Java 21 + Gradle 環境)
- `/app` を作業ディレクトリに設定
- プロジェクトファイル一式をコンテナ内にコピー
- `./gradlew bootRun` コマンドで Spring Boot を起動

#### 8.4.3 Docker イメージのビルド

1. VS Code でターミナルを開きます:

   - メニューから「ターミナル」→「新しいターミナル」を選択

2. 現在のディレクトリが `api` であることを確認します:

   ```bash
   pwd
   ```

3. Docker イメージをビルドします:

   ```bash
   docker image build -t hello-world-api .
   ```

   **コマンドの説明:**

   - `docker image build`: Docker イメージをビルド
   - `-t hello-world-api`: イメージに `hello-world-api` という名前(タグ)を付ける
   - `.`: カレントディレクトリをビルドコンテキストとして使用(Dockerfile を含む)

4. ビルドが完了するまで待ちます(初回は数分かかります)

   - `gradle:jdk21` イメージのダウンロード
   - 依存関係のダウンロード
   - プロジェクトのビルド

5. ビルド完了後、イメージが作成されたことを確認します:

   ```bash
   docker image ls
   ```

   以下のように `hello-world-api` が表示されれば成功です:

   ```
   REPOSITORY          TAG       IMAGE ID       CREATED          SIZE
   hello-world-api     latest    xxxxxxxxxxxx   30 seconds ago   xxx MB
   ```

#### 8.4.4 Docker コンテナの起動

1. ビルドしたイメージからコンテナを起動します:

   ```bash
   docker container run --rm -p 8080:8080 hello-world-api
   ```

   **コマンドの説明:**

   - `docker container run`: コンテナを起動
   - `--rm`: コンテナ停止時に自動的にコンテナを削除
   - `-p 8080:8080`: ホストの 8080 番ポートとコンテナの 8080 番ポートをマッピング
     - Spring Boot はデフォルトで 8080 番ポートでリッスンします
   - `hello-world-api`: 使用するイメージ名

2. 起動処理が開始されます(1〜2 分かかります)

   - 依存関係のダウンロード
   - アプリケーションの起動

3. 以下のような Spring ロゴと起動完了メッセージが表示されれば成功です:

   ```
     .   ____          _            __ _ _
    /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
   ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
    \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
     '  |____| .__|_| |_|_| |_\__, | / / / /
    =========|_|==============|___/=/_/_/_/

   ... (起動ログ)
   ```

#### 8.4.5 API の動作確認

1. コンテナが起動したまま、新しいブラウザタブを開きます

2. 以下の URL にアクセスします:

   ```
   http://localhost:8080/api/hello
   ```

3. ブラウザに以下のように表示されれば成功です:
   ```
   Hello
   ```

**動作確認のポイント:**

- エンドポイント `/api/hello` にアクセス
- レスポンスとして固定文字列 `"Hello"` が返される
- これは `HelloController.java` で実装されたシンプルな API です

#### 8.4.6 コンテナの停止

1. ターミナルに戻り、`Ctrl + C` を押してコンテナを停止します
2. `--rm` オプションを指定しているため、コンテナは自動的に削除されます

---

## 9. Docker コンテナイメージの最適化

### 9.1 概要

前回の講義では、単一の`Dockerfile`を使用して Spring Boot アプリケーションのビルドと実行を行いました。しかし、この方法ではイメージサイズが大きくなり、デプロイ時間も長くなります。

本セクションでは、**マルチステージビルド**という技術を使用して、Docker イメージを最適化し、サイズを削減します。

### 9.2 Java アプリケーションのビルドと実行

#### 9.2.1 Java の特徴

Java は、Python や JavaScript などのインタープリタ型言語とは異なり、**コンパイルが必要**な言語です。

**ビルドプロセス:**

1. **複数の Java ソースファイル(.java)** → **コンパイル** → **1 つの JAR ファイル**
2. JAM ファイルを実行することでアプリケーションが起動される

> **例:**
>
> - 本コースのプロジェクトには複数の Java ファイルが存在します
> - Gradle というビルドツールを使用して、これらのファイルを 1 つの JAR ファイルにパッケージ化します
> - 最終的な成果物は「1 つの JAR ファイル」です

#### 9.2.2 前回の Dockerfile の問題点

前回の講義で使用した`Dockerfile`:

```dockerfile
FROM gradle:jdk21

WORKDIR /app

COPY . .

CMD [ "./gradlew", "bootRun" ]
```

**この方法の問題点:**

| 問題点                       | 説明                                                                                                     |
| ---------------------------- | -------------------------------------------------------------------------------------------------------- |
| **イメージサイズが大きい**   | `gradle:jdk21`イメージには、ビルドツールや多くの依存関係が含まれているため、イメージサイズが大きい       |
| **デプロイ時間が長い**       | コンテナ起動時に毎回`bootRun`コマンドが実行され、ビルドが行われるため起動に時間がかかる                  |
| **不要なファイルが含まれる** | ビルド完了後、ソースコード(.java ファイル)やビルドツール(Gradle)は実行に不要だが、イメージに含まれている |

**結果:**

- イメージサイズが非常に大きい(例:740MB)
- コンテナの起動が遅い
- ストレージ効率が悪い

#### 9.2.3 マルチステージビルドの概念

マルチステージビルドは、複数の`FROM`文を使用して、異なる段階で異なるベースイメージを使用する技術です。

**利点:**

1. **ビルド段階**と**実行段階**を分離
2. ビルド段階の成果物(JAR ファイル)だけを実行段階にコピー
3. ビルドに必要なファイルやツールを最終イメージから除外
4. **イメージサイズを大幅に削減**(例:740MB → 524MB)

**概念図:**

```
ステージ1(ビルド):                    ステージ2(実行):
┌─────────────────────┐              ┌──────────────────┐
│ gradle:jdk21        │              │ openjdk:21-slim  │
├─────────────────────┤              ├──────────────────┤
│ ・Gradleツール     │              │ ・Java実行環境   │
│ ・Javaコンパイラ   │              │ (最小限のみ)    │
│ ・ビルド環境       │              │                  │
│ ・ソースコード     │              │                  │
│ ・その他多数       │              │                  │
└─────────────────────┘              └──────────────────┘
           ↓                                   ↑
     ./gradlew build                   (JARファイル
      (JARファイル作成)                  を実行)
           ↓                                   ↑
      JARファイル ──────────────→ コピー
```

**イメージサイズの比較:**

| イメージ          | 用途       | サイズ         | 説明                           |
| ----------------- | ---------- | -------------- | ------------------------------ |
| `gradle:jdk21`    | ビルド環境 | 約 800MB       | ビルドツール等を含む           |
| `openjdk:21-slim` | 実行環境   | 約 80MB        | Java 実行環境のみ              |
| **削減効果**      | -          | **約 90%削減** | 最終イメージが大幅に小さくなる |

### 9.3 マルチステージ Dockerfile の実装

#### 9.3.1 改良された Dockerfile

マルチステージビルドを使用した新しい`Dockerfile`:

```dockerfile
# =====================================
# ステージ1: ビルドステージ
# =====================================
FROM gradle:jdk21 AS build

WORKDIR /app

COPY . /app

RUN chmod +x ./gradlew && \
    ./gradlew build

# =====================================
# ステージ2: 実行ステージ
# =====================================
FROM openjdk:21

# ビルドステージから成果物(JARファイル)をコピー
COPY --from=build /app/build/libs/my-app-0.0.1-SNAPSHOT.jar ./my-app.jar

# アプリケーションを実行
CMD [ "java", "-jar", "my-app.jar" ]
```

#### 9.3.2 Dockerfile の詳細説明

**ステージ 1: ビルドステージ(6 行目～ 12 行目)**

```dockerfile
FROM gradle:jdk21 AS build
```

- `gradle:jdk21` イメージをベースに使用
- `AS build` でこのステージに「build」という名前を付ける
- 後のステージで参照する際に使用

```dockerfile
WORKDIR /app
COPY . /app
RUN chmod +x ./gradlew && \
    ./gradlew build
```

- 作業ディレクトリ `/app` を作成
- ローカルのすべてのファイルをコンテナの `/app` にコピー
- `chmod +x ./gradlew`: Gradle ラッパーに実行権限を付与
- `./gradlew build` でプロジェクトをビルド
  - 複数の Java ファイルをコンパイル
  - 1 つの JAR ファイル(`build/libs/my-app-0.0.1-SNAPSHOT.jar`)を作成

> **重要**: 前回のように`bootRun`ではなく、`build`コマンドを使用
>
> - `bootRun`: ビルド + 実行(イメージ内で実行)
> - `build`: ビルド結果をファイルとして出力(JAR ファイル作成)

**ステージ 2: 実行ステージ(15 行目～ 21 行目)**

```dockerfile
FROM openjdk:21
```

- 実行用に`openjdk:21` イメージを使用
- ビルドツールやその他の不要なものは含まない

```dockerfile
COPY --from=build /app/build/libs/my-app-0.0.1-SNAPSHOT.jar ./my-app.jar
```

- `--from=build` で「build」ステージから取得
- ビルドステージで作成された JAR ファイルをコピー
- `/app/build/libs/my-app-0.0.1-SNAPSHOT.jar` : ビルドステージ内でのパス
- `./my-app.jar` : 実行ステージ内でのコピー先パス(名前変更)

```dockerfile
CMD [ "java", "-jar", "my-app.jar" ]
```

- Java コマンドでアプリケーションを起動
- `-jar` オプション: JAR ファイルを実行
- `my-app.jar` : 実行する JAR ファイル

### 9.4 Dockerfile の更新

#### 9.4.1 既存の Dockerfile を確認

1. VS Code で`api`ディレクトリが開いている状態を確認します

2. ファイルエクスプローラーから`Dockerfile`をクリックして開きます

3. 現在の内容を確認します:

```dockerfile
FROM gradle:jdk21

WORKDIR /app

COPY . /app

CMD [ "./gradlew", "bootRun" ]
```

#### 9.4.2 Dockerfile を更新

1. 既存の Dockerfile の内容を全て削除します

2. マルチステージビルド版に置き換えます:

```dockerfile
# =====================================
# ステージ1: ビルドステージ
# =====================================
FROM gradle:jdk21 AS build

WORKDIR /app

COPY . /app

RUN chmod +x ./gradlew && \
    ./gradlew build

# =====================================
# ステージ2: 実行ステージ
# =====================================
FROM openjdk:21

COPY --from=build /app/build/libs/my-app-0.0.1-SNAPSHOT.jar ./my-app.jar

CMD [ "java", "-jar", "my-app.jar" ]
```

3. ファイルを保存します(`Ctrl + S`)

#### 9.4.3 Dockerfile の保存確認

- ファイルタブにファイル名が表示され、変更マークがなければ保存完了です

### 9.5 ビルドイメージサイズの比較

#### 9.5.1 マルチステージビルド版のビルド

1. ターミナルを開きます:

   - メニューから「ターミナル」→「新しいターミナル」を選択
   - または`Ctrl + Shift + `(バッククォート)

2. 現在のディレクトリが`api`であることを確認します:

```bash
cd /path/to/ecs-learning-course/cicd-section/api
```

3. マルチステージビルド版のイメージをビルドします:

```bash
docker image build -t hello-world-api-v2 .
```

> **コマンド解説:**
>
> - `docker image build`: Docker イメージをビルド
> - `-t hello-world-api-v2`: イメージ名を `hello-world-api-v2` に設定
> - `.`: カレントディレクトリを対象(更新された Dockerfile を使用)

4. ビルド完了までしばらく待ちます(初回は数分かかります)

#### 9.5.2 ビルド完了確認

ビルド完了後、以下のコマンドでイメージ一覧を表示します:

```bash
docker image ls
```

**出力例:**

```
REPOSITORY               TAG       IMAGE ID       CREATED          SIZE
hello-world-api-v2      latest    xxxxxxxxxxxx   10 seconds ago   524MB
hello-world-api         latest    xxxxxxxxxxxx   1 day ago        740MB
```

**サイズ削減の確認:**

| イメージ                   | サイズ | 削減率         |
| -------------------------- | ------ | -------------- |
| `hello-world-api`(前回)    | 740MB  | -              |
| `hello-world-api-v2`(今回) | 524MB  | **約 29%削減** |

> **差分の原因:**
>
> - ビルド段階の Gradle ツール、コンパイラ、ソースコードが最終イメージから除外
> - 実行に必要な Java 実行環境(`openjdk:21-slim`)のみが含まれる

#### 9.5.3 イメージの実行確認

新しくビルドしたイメージが正常に動作することを確認します:

1. コンテナを起動します:

```bash
docker container run --rm -p 8080:8080 hello-world-api-v2
```

2. Spring Boot が起動するまで待ちます(約 30 秒～ 1 分)

3. 起動ログに Spring ロゴが表示されれば成功です:

```
     .   ____          _            __ _ _
    /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
   ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
    \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
     '  |____| .__|_| |_|_| |_\__, | / / / /
    =========|_|==============|___/=/_/_/_/
```

#### 9.5.4 API の動作確認

1. 新しいブラウザタブを開きます

2. 以下の URL にアクセスします:

```
http://localhost:8080/api/hello
```

3. ブラウザに以下のように表示されることを確認します:

```
Hello
```

> **確認ポイント:**
>
> - エンドポイント `/api/hello` が正常に動作
> - マルチステージビルド版のイメージが正常に起動
> - アプリケーションが期待通りに動作

#### 9.5.5 起動速度の比較

**起動時間の改善:**

| イメージ                   | 起動時間     | 理由                                |
| -------------------------- | ------------ | ----------------------------------- |
| `hello-world-api`(前回)    | 1 ～ 2 分    | コンテナ起動時にビルド処理を実行    |
| `hello-world-api-v2`(今回) | 30 秒～ 1 分 | ビルド済みの JAR ファイルのみを実行 |

> **改善効果:**
>
> - 起動時間が約 50 ～ 60%高速化
> - 理由: ビルド処理がイメージビルド時に完了しているため

#### 9.5.6 コンテナの停止

1. ターミナルに戻ります

2. `Ctrl + C` を押してコンテナを停止します

3. `--rm` オプションのため、コンテナは自動的に削除されます

### 9.6 マルチステージビルドの利点まとめ

#### 9.6.1 ファイルサイズの削減

| 項目           | 前回  | 今回  | 削減                |
| -------------- | ----- | ----- | ------------------- |
| イメージサイズ | 740MB | 524MB | **216MB 削減(29%)** |

#### 9.6.2 起動速度の改善

- **前回:** コンテナ起動時にビルド処理を実行(1 ～ 2 分)
- **今回:** ビルド済み JAR を実行(30 秒～ 1 分)
- **改善率:** 約 50 ～ 60%高速化

#### 9.6.3 セキュリティの向上

| 項目                 | 説明                                                   |
| -------------------- | ------------------------------------------------------ |
| **ソースコード除外** | 最終イメージに Java ソースコードが含まれない           |
| **ビルドツール除外** | Gradle やその他のビルドツールが含まれない              |
| **攻撃対象面積削減** | 不要なソフトウェアが含まれないため、脆弱性のリスク低減 |

#### 9.6.4 本番環境への適用

マルチステージビルドの特性は、本番環境へのデプロイに特に効果的です:

- **ストレージ効率:** AWS などのクラウド環境でストレージコストを削減
- **デプロイ時間:** イメージサイズが小さいため、プルしやすく、起動が高速
- **スケーラビリティ:** 複数インスタンスのデプロイが迅速

---

## 10. GitHub Actions の設定

### 10.1 概要

GitHub Actions は、GitHub 上でコードの変更(プッシュ、プルリクエストなど)をトリガーに自動的にビルド、テスト、デプロイなどの処理を実行する CI/CD(継続的インテグレーション/継続的デプロイメント)ツールです。

このセクションでは、GitHub Actions を使用して自動的に以下の処理を実行できるよう設定を行います:

- コードの変更検出
- Docker イメージのビルド
- AWS ECR へのプッシュ
- ECS へのデプロイ

### 10.2 GitHub Actions の基本構造

GitHub Actions パイプラインは以下の要素で構成されています:

#### 10.2.1 イベント(Event)

- **定義**: パイプラインの開始トリガーとなる GitHub 上の動き
- **例**:
  - `push`: コミットがプッシュされた時
  - `pull_request`: プルリクエストが作成された時
  - `issues`: Issue が開かれた時
  - その他の GitHub イベント

#### 10.2.2 ランナー(Runner)

- **定義**: CI/CD パイプラインを実行するマシン
- **例**:
  - `ubuntu-latest`: Ubuntu の最新バージョン
  - `windows-latest`: Windows の最新バージョン
  - `macos-latest`: macOS の最新バージョン
  - セルフホストランナー(自身で用意したマシン)

#### 10.2.3 ジョブ(Job)

- **定義**: ランナー上で実行される処理の単位
- **特性**:
  - 複数個定義可能
  - デフォルトでは並列実行される(依存関係がなければ同時に実行)
  - それぞれ異なるランナーで独立して実行
  - ジョブ間の相互干渉がない

#### 10.2.4 ステップ(Step)

- **定義**: ジョブ内で実行される個別の処理
- **特性**:
  - ジョブ内では順序が保証される(上から順に実行)
  - 同じランナー上で実行されるため、前のステップの出力を次のステップで利用可能
  - ターミナルコマンドを順次実行するのと同じイメージ

#### 10.2.5 GitHub Actions の全体像

```
┌─────────────────────────────────────────┐
│ イベント(Event)                          │
│ 例: Push, Pull Request, Issue          │
└────────────────┬────────────────────────┘
                 │ トリガー
                 ▼
┌─────────────────────────────────────────┐
│ ランナー(Runner)                         │
│ Ubuntu, Windows, macOS など             │
└────────────────┬────────────────────────┘
                 │
       ┌─────────┴──────────┐
       ▼                    ▼
┌──────────────┐    ┌──────────────┐
│  ジョブ 1    │    │  ジョブ 2    │
│┌──────────┐ │    │┌──────────┐ │
││ステップ 1│ │    ││ステップ 1│ │
│└──────────┘ │    │└──────────┘ │
│┌──────────┐ │    │┌──────────┐ │
││ステップ 2│ │    ││ステップ 2│ │
│└──────────┘ │    │└──────────┘ │
└──────────────┘    └──────────────┘
    (並列実行)         (並列実行)
```

### 10.3 ワークフローファイルの作成

#### 10.3.1 ディレクトリ構造の準備

GitHub Actions を使用するには、リポジトリの特定の場所にワークフローファイルを配置する必要があります。

1. VS Code で `ecs-learning-course` ディレクトリを開きます

   - メニューから **File → Open Folder** を選択
   - `ecs-learning-course` ディレクトリを選択

2. ディレクトリが開かれたら、以下の信頼確認ダイアログが表示される場合があります

   > **Do you trust the authors of the files in this folder?**

   このメッセージに対して、**Yes, I trust the authors** をクリックして進めます

3. 新規フォルダを作成します

   - エクスプローラーの最上部で **New Folder** アイコンをクリック(またはマウス右クリックで「New Folder」を選択)
   - フォルダ名を **`.github`** と入力します(先頭のドット `.` は必須です)

4. `.github` フォルダ内に新規フォルダを作成します

   - `.github` フォルダを展開して選択
   - **New Folder** アイコンをクリック
   - フォルダ名を **`workflows`** と入力します

> **GitHub Actions 規約:**
>
> GitHub Actions が自動的にワークフローを認識するには、ファイルの配置場所が固定されています:
>
> - ディレクトリ構造: `/.github/workflows/`
> - ファイル形式: YAML ファイル(`.yml` または `.yaml` 拡張子)
>
> この命名と構造は GitHub により決定されているため、変更することはできません。

#### 10.3.2 ワークフローファイルの作成

1. `workflows` フォルダ内に新規ファイルを作成します

   - `workflows` フォルダを選択した状態で **New File** をクリック
   - ファイル名を入力します: **`ci-cd.yml`**

   > **ファイル名について:**
   >
   > - 拡張子は `.yml` または `.yaml` である必要があります
   > - ファイル名の前半部分(`ci-cd`)は任意です(GitHub が自動的に認識します)
   > - わかりやすい名前を付けることをお勧めします

2. ファイルが開かれると、YAML ファイルの編集が可能になります

### 10.4 ワークフローの基本設定

#### 10.4.1 ワークフロー定義の記述

作成した `ci-cd.yml` ファイルに、以下の内容を記述します:

```yaml
name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  hello-job:
    runs-on: ubuntu-latest

    steps:
      - run: echo Hello
      - run: echo "GitHub Actions!"

  goodbye-job:
    runs-on: ubuntu-latest

    steps:
      - run: echo "Goodbye GitHub Actions!"
```

#### 10.4.2 設定内容の詳細説明

**1. パイプラインの名前**

```yaml
name: CI/CD Pipeline
```

- このワークフロー全体の識別名です
- GitHub の Actions ページに表示されます
- わかりやすい名前を付けてください

**2. トリガーイベント(on セクション)**

```yaml
on:
  push:
    branches:
      - main
```

- **`on`**: このワークフローが実行されるトリガーを定義
- **`push`**: コミットがプッシュされた時にトリガー
- **`branches`**: ブランチの指定
  - `- main`: `main` ブランチへのプッシュが対象
  - 他のブランチも対象にする場合: `- main` と `- develop` など複数記述可能

**複数イベントを指定する例:**

```yaml
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
```

このように記述することで、プッシュ時とプルリクエスト時の両方がトリガーになります。

**3. ジョブの定義(jobs セクション)**

```yaml
jobs:
  hello-job:
    runs-on: ubuntu-latest
    steps: ...
```

- **`jobs`**: 複数のジョブを定義
- **`hello-job`**: ジョブの識別名(任意で命名可能)
- **`runs-on`**: このジョブを実行するランナーを指定
  - `ubuntu-latest`: Ubuntu の最新版を使用
  - 他の選択肢: `windows-latest`, `macos-latest` など
- **`steps`**: このジョブ内で実行するステップのリスト

**4. ステップの定義(steps セクション)**

```yaml
steps:
  - run: echo Hello
  - run: echo "GitHub Actions!"
```

- **`-` (ハイフン)**: YAML のリスト表記(複数のステップを並べる)
- **`run`**: 実行するコマンド
  - 通常のターミナルコマンドと同じ

> **ステップの`name` フィールドについて:**
>
> `name` フィールドはオプションです。省略した場合、GitHub Actions は `run` コマンドの内容をステップ名として表示します。
>
> - `name` を指定した場合: ステップ名として指定した文字列が表示される
> - `name` を省略した場合: `run` コマンドの内容が自動的にステップ名として使用される

**このワークフローの実行フロー:**

1. `main` ブランチへのコミットプッシュをトリガー
2. `hello-job` と `goodbye-job` が並列実行開始
3. `hello-job` 内で:
   - ステップ 1: `echo Hello` を実行して "Hello" を出力
   - ステップ 2: `echo "GitHub Actions!"` を実行して "GitHub Actions!" を出力
4. `goodbye-job` 内で:
   - ステップ 1: `echo "Goodbye GitHub Actions!"` を実行
5. 両ジョブの完了を待つ
6. パイプライン終了

### 10.5 ワークフローファイルの保存とプッシュ

#### 10.5.1 ファイルの保存

1. `ci-cd.yml` ファイルを保存します

   - キーボード: `Ctrl + S`(Windows/Linux) または `Cmd + S`(macOS)

#### 10.5.2 Git コマンドでコミット・プッシュ

1. VS Code 内のターミナルを開きます

   - メニュー: **Terminal → New Terminal** または `Ctrl + `` (バッククォート)

2. `ecs-learning-course` ディレクトリにいることを確認します

   ```bash
   pwd
   ```

3. Git のステータスを確認します

   ```bash
   git status
   ```

   **出力例:**

   ```
   On branch main

   No commits yet

   Untracked files:
     (use "git add <file>..." to include in what will be committed)
           .github/

   nothing added to commit but untracked files exist (use "git add" to track)
   ```

   > `.github` ディレクトリが `Untracked files`(追跡されていないファイル)として表示されます

4. ファイルをステージします

   ```bash
   git add .github
   ```

   または、すべてのファイルを追加する場合:

   ```bash
   git add .
   ```

5. ステータスを確認して、ステージされたことを確認します

   ```bash
   git status
   ```

   **出力例:**

   ```
   On branch main

   No commits yet

   Changes to be committed:
     (use "git rm --cached <file>..." to unstage)
           new file:   .github/workflows/ci-cd.yml
   ```

6. コミットを作成します

   ```bash
   git commit -m "Add GitHub Actions CI/CD pipeline"
   ```

   **出力例:**

   ```
   [main (root-commit) xxxxxxxx] Add GitHub Actions CI/CD pipeline
    1 file changed, 30 insertions(+)
    create mode 100644 .github/workflows/ci-cd.yml
   ```

7. リポジトリにプッシュします

   ```bash
   git push origin main
   ```

   **出力例:**

   ```
   Enumerating objects: 4, done.
   Counting objects: 100% (4/4), done.
   Delta compression: 100% (2/2), done.
   Writing objects: 100% (4/4), 389 bytes | 389.00 KiB/s, done.
   Total 4 (delta 0), reused 0 (delta 0), received 0 (pack-reused 0)
   To https://github.com/your-account/ecs-learning-course.git
    * [new branch]      main -> main
   ```

### 10.6 GitHub Actions の実行確認

#### 10.6.1 Actions ページへアクセス

1. GitHub のリポジトリページにアクセスします

2. ページ上部のタブメニューから **Actions** をクリックします

   > **画面例:**
   >
   > リポジトリページには以下のタブが表示されます:
   > `Code | Issues | Pull requests | Actions | Projects | ...`

#### 10.6.2 ワークフロー実行の確認

1. Actions ページが表示されます

   > **初回の表示:**
   > プッシュしたコミットメッセージが表示され、右側に **緑色のチェックマーク(✓)** が付いている場合、パイプラインが正常に完了しています。

2. コミットメッセージをクリックして、詳細ページを表示します

   **詳細ページの構成:**

   - 左側: ジョブ一覧

     - `hello-job`
     - `goodbye-job`

   - 右側: ログ表示領域

#### 10.6.3 ジョブの実行ログを確認

1. `hello-job` をクリックすると、そのジョブ内で実行されたステップが表示されます

   **表示内容:**

   ```
   ✓ Set up job
   ✓ Run echo Hello
   ✓ Run echo "GitHub Actions!"
   ✓ Complete job
   ```

   > `name` フィールドを指定していないため、ステップ名は `run` コマンドの内容が使用されます。

2. **Run echo Hello** のステップをクリックして詳細を確認します

   **ログ内容:**

   ```
   Run echo Hello
   Hello
   ```

3. **Run echo "GitHub Actions!"** のステップをクリックして詳細を確認します

   **ログ内容:**

   ```
   Run echo "GitHub Actions!"
   GitHub Actions!
   ```

#### 10.6.4 goodbye-job の確認

1. 左側のジョブ一覧から `goodbye-job` をクリックします

2. このジョブ内のステップを確認します

   **表示内容:**

   ```
   ✓ Set up job
   ✓ Run echo "Goodbye GitHub Actions!"
   ✓ Complete job
   ```

3. **Run echo "Goodbye GitHub Actions!"** ステップの詳細を確認します

   **ログ内容:**

   ```
   Run echo "Goodbye GitHub Actions!"
   Goodbye GitHub Actions!
   ```

#### 10.6.5 実行結果の確認ポイント

| 確認項目             | 期待値                      | 確認方法                         |
| -------------------- | --------------------------- | -------------------------------- |
| **パイプライン結果** | 緑色のチェックマーク(✓)表示 | Actions ページのトップで確認     |
| **ジョブ数**         | 2 つのジョブが表示される    | 詳細ページ左側のジョブ一覧で確認 |
| **ジョブ実行順序**   | 並列実行(完了時刻が近い)    | 各ジョブの完了時刻を比較         |
| **ステップ出力**     | 正しい文字列が出力される    | 各ステップのログで確認           |

### 10.7 GitHub Actions の実行仕組みの確認

#### 10.7.1 イベントとトリガーの関係

**今回のワークフロー:**

```yaml
on:
  push:
    branches:
      - main
```

このトリガー定義により:

- `main` ブランチへの`push`(コミット)があった時点でイベントが発火
- GitHub Actions が自動的にワークフローを実行開始
- ユーザーが手動で実行を開始する必要はない

#### 10.7.2 ジョブの並列実行確認

ワークフローで複数のジョブを定義した場合:

```yaml
jobs:
  hello-job: ...
  goodbye-job: ...
```

**実行パターン:**

- デフォルトでは `hello-job` と `goodbye-job` は**並列実行**
- 依存関係がなければ、同時に実行される
- それぞれ異なるランナーで独立して動作

**実行時間の比較:**

| パターン     | 実行時間 | 説明                                        |
| ------------ | -------- | ------------------------------------------- |
| **並列実行** | 30 秒    | 2 つのジョブが同時に実行(今回のケース)      |
| **直列実行** | 60 秒    | ジョブ 1 終了 → ジョブ 2 実行(もし依存関係) |

#### 10.7.3 ステップ内での順序保証

同一ジョブ内のステップは必ず順序が保証されます:

```yaml
steps:
  - name: Step 1
    run: echo "First"

  - name: Step 2
    run: echo "Second"

  - name: Step 3
    run: echo "Third"
```

実行結果:

```
First
Second
Third
```

必ずこの順番で実行されます(並列化されない)。
