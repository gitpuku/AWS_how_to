# ECSにおける状態管理

## 1. セクションの概要

このセクションでは、ECSを使ったコンテナのオーケストレーションシステムにおいて、**状態の管理**をどう行うかについて学習する。特に**セッション管理**にフォーカスを当てる。

---

## 2. RESTの原則とステートレス

### RESTの原則
HTTPベースのWEB APIで広く使われているのが**REST API**。RESTにはいくつかの原則があり、その一つが「**ステートレス**」。

### ステートレスとは
- **定義**: サーバーはクライアントの以前のリクエスト状態を保持しない
- **意味**: サーバーは基本的に、クライアントが誰なのかを把握できない
- **結果**: 誰が呼び出しても、同じリクエスト内容なら全く同じレスポンスが返る

```
クライアント → リクエスト → サーバー
              ← レスポンス ←
(サーバーは前回のリクエストを覚えていない)
```

---

## 3. ステートレスの課題

### ログイン機能のあるシステムでの問題
RESTの原則を愚直に実行すると都合が悪いシーンが存在する。

#### 典型例: ECサイト（Amazon等）
- 一回ログインした後、サイト内で画面遷移しても毎回ログインを求められることはない
- 画面遷移時には裏でHTTPリクエストがサーバーに飛んでいる
- サーバー側は何らかの方法で「このクライアントは既にログイン済みか」を判断している

#### サーバーの振る舞い
- **ログイン前**: ログイン画面に誘導
- **ログイン後**: 通常通りサイト内の画面遷移を許可

→ これは一見、RESTの「ステートレス」原則に反しているように見える

---

## 4. 単一サーバーでの状態管理

### サーバーが1つだけの場合
状態管理は比較的シンプル。

```
[クライアント] → [コンテナ(サーバー)]
                 ↓
           (ログイン状態を保持)
```

- クライアントのログイン状態をサーバー内で保持
- リクエストが来るたびに、何らかのリクエストIDを使ってログイン状態を判断
- それに応じてレスポンスデータを返す

---

## 5. 複数コンテナでの状態管理の問題

### オートスケーリング環境での課題
コンテナが複数存在する場合、話は複雑になる。

#### システム構成
```
[クライアント]
     ↓
[ロードバランサー]
     ↓ ↓ ↓
[コンテナ1] [コンテナ2] [コンテナ3]
```

### 問題が発生するシナリオ

#### ステップ1: ログイン処理
1. ユーザーがログインリクエストを送信
2. ロードバランサー経由で**コンテナ1**に到達
3. **コンテナ1**がログイン処理を実行し、内部に「ログイン済み」フラグを保持
4. ログイン成功レスポンスをクライアントに返す

```
[クライアント] → [LB] → [コンテナ1]✓(ログイン済み保持) [コンテナ2] [コンテナ3]
```

#### ステップ2: 画面遷移（ユーザー情報ページへ）
1. ユーザーがユーザー情報画面へ遷移（新しいリクエスト）
2. ロードバランサーがラウンドロビンで**コンテナ2**に振り分け
3. **コンテナ2**はこのユーザーのログイン状態を知らない
   - ログイン処理は**コンテナ1**が行った
   - 状態は共有されていない
4. **コンテナ2**は「ログインしていない」と判断
5. ログインページへの誘導画面をレスポンスとして返す

```
[クライアント] → [LB] → [コンテナ1]✓ [コンテナ2]❌ [コンテナ3]
                              ↑
                    (ログイン状態を知らない)
```

#### ユーザーの体験
- さっきログインしたのに、また ログイン画面が表示される
- **明らかにバグのような挙動** ❌

---

## 6. 解決策の必要性

### 必要なメカニズム
複数コンテナ環境で正常に動作させるには、**ログイン状態などの状態を管理するメカニズム**が必要。

```
[クライアント]
     ↓
[ロードバランサー]
     ↓ ↓ ↓
[コンテナ1] [コンテナ2] [コンテナ3]
     ↓ ↓ ↓
[何らかの状態管理メカニズム] ← ここがポイント!
```

---

## 7. 代表的な状態管理手法（3種類）

状態を管理するための代表的な手法は以下の3つ。これらは**排他的ではなく、組み合わせて使うことも可能**。

### 3つの手法の概要
1. **外部ストア方式** - データベースやキャッシュに状態を保存
2. **スティッキーセッション方式** - 同じユーザーを同じサーバーに固定
3. **JWTトークン方式** - クライアント側にトークンとして状態を保持

---

## 8. 外部ストア方式

### 概要
外部にデータベースや**セッションストア**（キャッシュ）を用意し、そこに状態を保存する方式。

#### 代表的な技術
- **キャッシュ**: Redis, Memcached
- **データベース**: MySQL, PostgreSQL

### 仕組み
```
[クライアント]
     ↓
[ロードバランサー]
     ↓ ↓ ↓
[コンテナ1] [コンテナ2] [コンテナ3]
     ↓ ↓ ↓ (全て参照)
[外部ストレージ/セッションストア]
   (Redis, DB等)
```

#### 動作フロー
1. ユーザーがログイン → **コンテナ1**が処理
2. **コンテナ1**がログイン状態を**外部ストレージ**に保存（コンテナ自体には保持しない）
3. 次のリクエストが**コンテナ2**に到達
4. **コンテナ2**が外部ストレージを参照 → ログイン状態を確認できる ✓
5. 正しいレスポンスを返せる

### メリット ✅
- **スケーラビリティが高い**
  - 全コンテナが共通のストレージを参照
  - どのコンテナにリクエストが来ても一貫した情報を取得可能
  - 負荷分散が容易
- **耐障害性が高い**
  - 特定のコンテナに情報がサイロ化しない
  - コンテナが死んでも、状態情報は外部に保存されているため影響なし

### デメリット ❌
- **追加費用がかかる**
  - 外部ストレージの運用コストが必要
- **ネットワーク遅延が発生**
  - 外部ストレージとの通信が必要
  - **対策**: 高速なキャッシュ（Redis等）を使用
    - メモリベースで読み書きが速い

---

## 9. スティッキーセッション方式

### 概要
**特定のユーザーのリクエストを常に同じサーバーにルーティングする**方式。

### 名前の由来
**Sticky** = 粘っこい、粘着した  
→ 同じクライアントと同じコンテナを常に「くっつける」という意味

### 仕組み
```
[クライアント]
  (セッションID保持)
     ↓
[ロードバランサー]
 (セッションIDを見て振り分け)
     ↓
[コンテナ1]← この組み合わせを固定
     ↓
  (状態保持)
```

#### 動作フロー
1. **サーバー/ロードバランサー**が**セッションID**を生成
2. セッションIDを**クライアント（ブラウザ）**に渡す
3. 以降、クライアントは毎回のリクエストに**セッションIDを添付**
4. ロードバランサーはセッションIDを見て、**常に同じコンテナ**にルーティング

### メリット ✅
- **外部ストレージが不要**で実装がシンプル
- セットアップが容易

### デメリット ❌
- **コンテナとユーザーの依存度が高い**
  - ユーザーの状態は特定のコンテナ1つが保持
  - そのコンテナが死ぬと状態も消失 → セッションが切れる
  
- **負荷分散の問題**
  - ヘビーユーザーが特定のコンテナに固定される
  - 1つのコンテナだけ負荷が高くなる可能性
  - 負荷が均等に分散されない

### 推奨される使い方
- **消えても問題ないデータのみ**をコンテナ内で保持
- **消えると困る重要な状態**は外部ストア方式と組み合わせる
- ただし、そこまでするなら最初から外部ストア方式のみを使う方が良いケースも多い（ケースバイケース）

---

## 10. JWTトークン方式

### 概要
**JWT (JSON Web Token)** を使って状態を管理する方式。

### 決定的な違い
状態情報を**クライアント側（ブラウザ）に保存**する。

```
[クライアント/ブラウザ]
   ↓ (JWTトークンを保持)
   ↓ (トークンをリクエストに添付)
[ロードバランサー]
     ↓ ↓ ↓
[コンテナ1] [コンテナ2] [コンテナ3]
   ↓ (署名を検証して状態を把握)
```

### JWTの構造
JWTは**Base64エンコード**された3つの部分から構成される：

```
ヘッダー.ペイロード.署名
(Base64).(Base64).(Base64署名)
```

- **ヘッダー**: トークンのメタ情報
- **ペイロード**: セッション情報、ユーザー状態
- **署名**: サーバーが署名した検証用データ

### 動作フロー
1. サーバーがJWTトークンを生成（セッション情報を含む）
2. サーバーが秘密鍵でトークンに**署名**
3. トークンを**クライアント**に返す
4. クライアントはブラウザにトークンを保存
5. 以降のリクエストでトークンを添付
6. サーバーは**署名を検証**して改ざんされていないかチェック
7. 検証OKなら、トークン内の状態情報を信頼して使用

### メリット ✅
- **スケーラビリティが非常に高い**
  - サーバーサイドは状態を一切管理しない
  - コンテナの負荷分散が容易
  - ロードバランサーは単純にラウンドロビンで振り分けるだけでOK

### デメリット ❌
- **セキュリティ上の考慮事項が多い**
  - 他の手法: セッションIDのみをクライアントに渡す
    - 実際の情報（ユーザーIDなど）はサーバー/DB側で保持
    - クライアントは直接情報を読めない
  
  - JWT方式: 全ての状態情報がトークンに含まれる
    - Base64エンコードされているだけ（暗号化ではない）
    - **ユーザーは見ようと思えば見れる** ⚠️
    
- **センシティブな情報の取り扱いに不向き**
  - ユーザーに見せたくない情報は含められない

### 推奨される使い方
- **JWTトークン方式だけで完結することは稀**
- **基本的な情報**（ログイン状態など、見られても問題ない情報）→ JWTで管理
- **センシティブな情報**（個人情報、機密データなど）→ 外部ストアと組み合わせる

---

## 11. このコースで採用する手法

今回のハンズオンでは、**スティッキーセッション方式**を使用する。

### 選定理由

#### 1. ハンズオンのシンプルさ
- 外部ストアが不要で実装できる
- セットアップが簡単で、ハンズオンに集中できる

#### 2. ECSに焦点を当てるため
- JWTトークン方式は、署名・検証などの処理がアプリケーション側の実装が中心
- Spring Boot、Railsなどのアプリケーションフレームワークの話になる
- **ECS**というこのコースの主眼から外れてしまう

#### 3. 実用性
- 規模がそれほど大きくない場合
- 簡単に状態管理/セッション管理をしたい場合
- **スティッキーセッションも悪くない選択肢**

---

## まとめ

### RESTとステートレスの課題
- RESTの原則「ステートレス」は、サーバーが状態を保持しないことを意味する
- しかし実際のアプリケーションではログイン状態などを保持する必要がある
- 単一サーバーでは簡単だが、複数コンテナ（オートスケーリング）環境では問題が発生

### 3つの状態管理手法

| 手法 | メリット | デメリット | 適用シーン |
|------|----------|------------|------------|
| **外部ストア** | スケーラブル、耐障害性高い | 追加費用、遅延 | 本格的な本番環境 |
| **スティッキーセッション** | シンプル、追加コスト不要 | 耐障害性低い、負荷分散の問題 | 小規模、簡易的な実装 |
| **JWT** | 非常にスケーラブル | セキュリティ考慮事項多い | 外部ストアと組み合わせて使用 |

### 次のステップ
スティッキーセッション方式の実装方法をハンズオンで学習する。

---

## 12. セッションとは

### セッションの定義
**セッション**とは、ユーザーがWEBアプリケーションを使用している際の**一連の操作や状態**を指す。

- **期間**: ユーザーがWEBサイトにアクセスしてから離れるまで
- **目的**: 特定の時間内でユーザーの活動を追跡し、状態を保持する

### セッションで実現できること
- **ログイン状態の維持**
- **ショッピングカートの商品管理**
- **ユーザー操作の記憶**

---

## 13. セッションの具体的な流れ

### ECサイト（Amazon等）の例

```
[ブラウザ]                        [サーバー]
    |                                  |
    |-- (1) ログインリクエスト -------->|
    |                                  | (ログイン処理)
    |<---- ログイン成功レスポンス ------|
    |                                  |
    |-- (2) カートに商品追加 ---------->|
    |                                  | (ログイン状態を確認)
    |<---- 追加完了レスポンス ----------|
    |                                  |
    |-- (3) カート商品を購入 ---------->|
    |                                  | (ログイン状態を確認)
    |<---- 購入完了レスポンス ----------|
```

### ポイント
- 最初にログインすれば、2回目以降の操作で**毎回ログインする必要はない**
- **ログイン状態**がお互いの間で保存・維持される
- これら一連の流れを**セッション**と呼ぶ

---

## 14. セッションの仕組み（セッションID）

### セッションIDの生成と保存

#### ステップ1: ログイン時にセッションIDを作成
```
[ブラウザ]                        [サーバー]
    |                                  |
    |-- ログインリクエスト ------------>|
    |                                  | ✓ セッションID生成
    |                                  |   (ランダムな文字列)
    |<-- ログイン成功 + セッションID --|
    |                                  |
    ↓ セッションIDを保存
```

**セッションID**
- パッと見はランダムな文字列
- サーバー側で生成
- レスポンスと一緒にブラウザに返される

#### ステップ2: ブラウザがセッションIDを保存
ブラウザは受け取った**セッションID**を内部に保存する。

#### ステップ3: 以降のリクエストでセッションIDを送信
```
[ブラウザ]                             [サーバー]
    |                                       |
    |-- カート追加 + セッションID ---------->|
    |                                       | (セッションIDで識別)
    |<-- 追加完了 --------------------------|
    |                                       |
    |-- 購入リクエスト + セッションID ------->|
    |                                       | (セッションIDで識別)
    |<-- 購入完了 --------------------------|
```

次回以降、同じサーバーへのリクエストには**必ずセッションIDを含める**。

#### ステップ4: サーバーがユーザーを識別
サーバーは受け取った**セッションID**を使って：
- **相手が誰なのか**を識別
- **ログイン済みかどうか**を確認
- **セッション内の状態を維持**

---

## 15. セッションIDのセキュリティ

### ⚠️ セッションIDは非常に重要な情報

#### なぜ重要なのか
- サーバーは**セッションID**でユーザーを識別している
- セッションIDを知っていれば**誰でもそのユーザーになりすませる**

#### 漏洩した場合のリスク
他人がセッションIDを知ってしまうと：
- ✗ 別のユーザーとして商品購入
- ✗ カートに商品を追加
- ✗ その他のクリティカルな操作

### 結論
**セッションIDは他人に渡したり、漏洩するとかなりまずい情報** ⚠️

---

## 16. Cookie（クッキー）

### Cookieとは
ブラウザが**セッションID**を保存する仕組みとして使われるのが**Cookie**。

#### 定義
- WEBサイトがユーザーのブラウザに保存する**小さなデータの断片**
- **サイズ制限**: 約4KB（大半のブラウザ）
  - それ以上大きい場合は、複数のCookieに分割する必要がある

#### 用途
- ユーザーの識別
- 訪問履歴の記録
- 設定の保存
- **ログイン状態の記憶**（セッションID）

### Cookieの重要性
**セッション管理の一部として非常に重要な役割**を果たす。  
→ **セッションID**は基本的に**Cookie領域**に保存される

### Cookieのデータ構造
**Key-Value形式**
- **Cookie Name**（名前）: Cookie の識別子
- **Cookie Value**（値）: 実際のデータ（セッションIDなど）

---

## 17. Cookieの動作確認（デモ）

### 使用サイト
[SetCookie.net](http://www.setcookie.net/) - Cookieの動作をテストできるサイト

### デモ手順

#### 1. Cookieを設定
1. [SetCookie.net](http://www.setcookie.net/)にアクセス
2. **Cookie Name**: 例）`sample-cookie`
3. **Cookie Value**: 例）`this-is-a-pen`
4. 送信前に**デベロッパーツール**を開く

#### 2. ネットワーク通信を確認
1. ブラウザで**右クリック → 検証**
2. **ネットワーク**タブを選択
3. **All**が選択されていることを確認
4. **送信**ボタンをクリック

#### 3. レスポンスヘッダーを確認
1. 一番上の`setcookie.net`へのリクエストを選択
2. **Headers**タブをクリック
3. **Response Headers**（レスポンスヘッダー）を探す
4. **Set-Cookie**属性に設定した値が含まれている

```
Set-Cookie: sample-cookie=this-is-a-pen
```

**意味**: サーバーがブラウザに「このCookieを保存してね」と指示している

#### 4. ブラウザに保存されたCookieを確認
1. デベロッパーツールで**アプリケーション**タブを選択
2. 左メニューの**Cookie**を展開
3. `setcookie.net`ドメインを選択
4. **Name**と**Value**に設定した内容が表示される

```
Name: sample-cookie
Value: this-is-a-pen
```

### Cookieの自動送信
次回以降、このドメインへリクエストを送る際には：
- ブラウザが自動的に**リクエストヘッダー**にCookieを含める
- **全てブラウザが自動的に処理**してくれる

---

## 18. まとめ（セッションとCookie）

### セッション
- ユーザーのWEBアプリ使用中の一連の操作・状態を指す
- ログイン状態やカート情報などを維持する仕組み

### セッションIDの役割
- サーバーが生成するランダムな文字列
- ユーザーを識別し、ログイン状態を判断する
- **非常にセキュアで重要な情報**（漏洩厳禁）

### Cookieの役割
- セッションIDを保存する領域
- WEBサイトごとに小さなデータ（約4KB）を保存
- Key-Value形式
- ブラウザが自動的に送受信を管理

### セッション管理の流れ
1. **ログイン時**: サーバーがセッションIDを生成 → Cookieでブラウザに送信
2. **保存**: ブラウザがCookieにセッションIDを保存
3. **以降のリクエスト**: ブラウザが自動的にCookieをリクエストヘッダーに含める
4. **識別**: サーバーがセッションIDでユーザーを識別・状態を維持

---

## 次回予告

次回以降は、**AWSを使ったスティッキーセッションの実装**を実際に体験する。

---

# スティッキーセッション デモアプリの構築

## 19. デモアプリの全体構成

### アーキテクチャ図

```
[ユーザー/クライアント]
         ↓
   [パブリックサブネット]
         ↓
  [ロードバランサー]
    (ポート: 80)
         ↓ (転送: 8080)
    [ECSサービス]
    (my-sm-service)
      ↓  ↓  ↓
   [コンテナ1] [コンテナ2] [コンテナ3]
   (Spring Boot WEB API)
```

### 構成要素
- **配置**: 全てのリソースをパブリックサブネットに配置
- **ロードバランサー**: ポート80で待ち受け、ポート8080に転送
- **ECSサービス**: my-sm-service
- **コンテナ**: 複数のSpring Boot製WEB APIコンテナ

### 学習目的
**スティッキーセッション**を有効/無効にした際の**リクエストの挙動の違い**を体験する。

---

## 20. ソースコードの準備

### GitHubリポジトリ
講義用のソースコードをGitHubから取得する。

#### リポジトリ構成
```
ecs-learning-course/
  └── session-management-section/
      └── session-management/
          ├── Dockerfile
          ├── build.gradle
          └── src/
              └── main/
                  └── java/
                      └── org/
                          └── example/
                              └── sessionmanagement/
                                  └── controller/
                                      └── UserController.java
```

### 手順
1. GitHubリポジトリのメインブランチをクローンまたはダウンロード
2. `session-management-section`ディレクトリを確認
3. VS Codeまたはターミナルで開く

---

## 21. Spring Boot APIの実装内容

### UserController.java

#### エンドポイントのプレフィックス
```java
@RequestMapping("/api/users")
```

全てのAPIは `/api/users` から始まる。

---

### API 1: `/status` - ログイン状態を確認

#### エンドポイント
```
GET /api/users/status
```

#### 処理内容
```java
// セッションから "login-status" 属性を取得
if (this.httpSession.getAttribute("login-status") == null) {
    return ResponseEntity.ok("You Are 'Logged Out'");
}
return ResponseEntity.ok("You Are 'Logged In'");
```

#### 動作
1. HTTPセッションから`login-status`属性を確認
2. **null**: ログインしていない → `"You Are 'Logged Out'"`を返す
3. **値あり**: ログイン済み → `"You Are 'Logged In'"`を返す

---

### API 2: `/login` - ログイン処理

#### エンドポイント
```
GET /api/users/login
```

#### 処理内容
```java
// セッションに "login-status" = "Logged In" を保存
this.httpSession.setAttribute("login-status", "Logged In");
return ResponseEntity.ok("Logged In");
```

#### 動作
1. HTTPセッションの`login-status`属性に`"Logged In"`文字列を保存
2. `"Logged In"`レスポンスを返す
3. 次回以降の`/status`呼び出しで`"You Are 'Logged In'"`が返るようになる

#### 注意
- デモの簡略化のため、GETメソッドを使用（通常はPOSTが適切）
- ユーザーIDやパスワード検証は省略

---

### API 3: `/logout` - ログアウト処理

#### エンドポイント
```
GET /api/users/logout
```

#### 処理内容
```java
// セッションを無効化
this.httpSession.invalidate();
return ResponseEntity.ok("Logged Out");
```

#### 動作
1. セッション全体を無効化
2. `"Logged Out"`レスポンスを返す
3. 次回のリクエストで新しいセッションが生成される

---

## 22. ローカルでの動作確認

### Dockerイメージのビルド

#### Dockerfileの内容
```dockerfile
# ビルドステージ
FROM gradle:jdk21 AS build
WORKDIR /app
COPY . /app
RUN chmod +x ./gradlew && \
    ./gradlew build

# 実行ステージ
FROM openjdk:21
COPY --from=build /app/build/libs/session-management-0.0.1-SNAPSHOT.jar ./session-management.jar
CMD [ "java", "-jar", "session-management.jar" ]
```

#### ビルドコマンド
```bash
docker image build -t session-management .
```

---

### コンテナの起動

```bash
docker container run --rm -p 8080:8080 session-management
```

#### オプション説明
- `--rm`: コンテナ停止後に自動削除
- `-p 8080:8080`: ポート8080をバインド

---

## 23. APIの動作テスト

### 準備: デベロッパーツールを開く
1. ブラウザで右クリック → **検証**
2. **ネットワーク**タブを選択
3. **All**が選択されていることを確認

---

### テスト 1: 初回のステータス確認

#### リクエスト
```
GET http://localhost:8080/api/users/status
```

#### 期待される結果
- **レスポンス**: `You Are 'Logged Out'`
- **Response Headers**: `Set-Cookie: JSESSIONID=...`（新しいセッションIDが生成される）

#### 確認ポイント
1. **レスポンスヘッダー**に`Set-Cookie`がある
   - Spring Bootが新しいセッションIDを生成
   - `JSESSIONID`: Spring Bootのセッション管理で使用されるCookie名
   
2. **アプリケーション**タブ → **Cookie** → **localhost:8080**
   - `JSESSIONID`が保存されていることを確認

---

### テスト 2: ログイン実行

#### リクエスト
```
GET http://localhost:8080/api/users/login
```

#### 期待される結果
- **レスポンス**: `Logged In`
- **Response Headers**: `Set-Cookie`なし（既にセッションが存在するため）
- **Request Headers**: `Cookie: JSESSIONID=...`（ブラウザが自動的に送信）

#### 確認ポイント
1. **リクエストヘッダー**に`Cookie`が含まれている
   - ブラウザが自動的にセッションIDを添付
   
2. **レスポンスヘッダー**に`Set-Cookie`がない
   - 既にセッションが存在するため、新規作成不要

---

### テスト 3: ログイン後のステータス確認

#### リクエスト
```
GET http://localhost:8080/api/users/status
```

#### 期待される結果
- **レスポンス**: `You Are 'Logged In'`（ログイン状態に変化！）
- **Request Headers**: `Cookie: JSESSIONID=...`

#### 動作の理由
1. ブラウザが自動的にセッションIDをCookieとして送信
2. サーバーがセッションIDでユーザーを識別
3. セッション内の`login-status`が`"Logged In"`であることを確認
4. `"You Are 'Logged In'"`を返す

---

### テスト 4: ログアウト実行

#### リクエスト
```
GET http://localhost:8080/api/users/logout
```

#### 期待される結果
- **レスポンス**: `Logged Out`
- **Request Headers**: `Cookie: JSESSIONID=...`（古いセッションID）

#### サーバー側の動作
セッションが無効化される。

---

### テスト 5: ログアウト後のステータス確認

#### リクエスト
```
GET http://localhost:8080/api/users/status
```

#### 期待される結果
- **レスポンス**: `You Are 'Logged Out'`（ログアウト状態に戻った）
- **Response Headers**: `Set-Cookie: JSESSIONID=...`（**新しい**セッションIDが生成される）

#### 動作の理由
1. ログアウトで古いセッションが無効化された
2. 次のリクエストで新しいセッションが自動生成される
3. 新しいセッションには`login-status`がない → `You Are 'Logged Out'`

---

## 24. Cookieを手動で削除した場合の挙動

### 実験: セッションの重要性を理解する

#### 手順
1. `/login`でログイン → `You Are 'Logged In'`状態になる
2. **デベロッパーツール** → **アプリケーション**タブ → **Cookie**
3. `JSESSIONID`を右クリック → **Delete**
4. `/status`を再度リクエスト

#### 結果
- **レスポンス**: `You Are 'Logged Out'`（さっきログインしたのに！）
- **Request Headers**: `Cookie`なし（削除したため）
- **Response Headers**: `Set-Cookie: JSESSIONID=...`（新しいセッションが生成）

#### なぜこうなるのか
1. Cookieを削除 → ブラウザはセッションIDを持っていない
2. 次のリクエストでCookieが送信されない
3. サーバーは「初めて来たユーザー」と判断
4. 新しいセッションIDを生成して返す
5. 以前のログイン状態は失われる

---

## 25. セッション管理のポイント

### セッションIDの重要性 ⚠️

#### セッションIDは非常にセンシティブな情報
- **セッションIDがあれば、誰でもそのユーザーになりすませる**
- 他人に漏洩すると、そのユーザーとして操作できてしまう
  - 商品購入
  - カートへの追加
  - その他のクリティカルな操作

#### セキュリティ対策
今回のデモでは説明を省略したが、実際には以下の対策が重要：
- **HttpOnly属性**: JavaScriptからCookieを読めないようにする
- **Secure属性**: HTTPS通信でのみCookieを送信
- **SameSite属性**: CSRF攻撃を防ぐ

### 注意事項 ⚠️
- **本物のECサイトなどのCookieを他人に見せてはいけない**
- 動画やスクリーンショットで公開することも危険
- 今回はデモ用のローカル環境なので問題ない

---

## 26. まとめ（デモアプリ）

### 作成したもの
- **Spring Boot製のWEB API**
  - `/api/users/status`: ログイン状態確認
  - `/api/users/login`: ログイン処理
  - `/api/users/logout`: ログアウト処理

### 学んだこと
1. **セッションIDの生成**: サーバーが自動的に生成し、Cookieで送信
2. **Cookieの自動送信**: ブラウザがリクエストヘッダーに自動的に含める
3. **状態の維持**: セッションIDを使ってサーバー内でユーザー状態を保持
4. **セッションの無効化**: ログアウトやCookie削除で状態がリセットされる

### 次のステップ
このデモアプリを**AWSのECS環境**にデプロイし、**スティッキーセッション**の動作を確認する。

---

# AWS環境へのデプロイ

## 27. ロードバランサー（ALB）の作成

### 手順

#### 1. ALBの基本設定
1. AWSコンソールで**ロードバランサー**を検索
2. **ロードバランサーの作成**をクリック
3. **Application Load Balancer**を選択

#### 2. 基本的な設定
- **ロードバランサー名**: `my-sm-alb`
  - sm = Session Managementの略
- **スキーム**: インターネット向け
- **IPアドレスタイプ**: IPv4

#### 3. ネットワークマッピング
- **VPC**: `my-workspace-vpc`
- **アベイラビリティゾーン**: 2つ選択
- **サブネット**: 両方とも**パブリックサブネット**を選択

---

## 28. セキュリティグループの作成（ロードバランサー用）

### my-sm-lb-sg

#### 作成手順
1. セキュリティグループのセクションで**新規作成リンク**をクリック

#### 設定内容
- **セキュリティグループ名**: `my-sm-lb-sg`
- **説明**: `my-sm-lb-sg`（同じ名前でOK）
- **VPC**: `my-workspace-vpc`

#### インバウンドルール
| タイプ | プロトコル | ポート範囲 | ソース | 説明 |
|--------|-----------|-----------|--------|------|
| HTTP | TCP | 80 | 0.0.0.0/0 (Anywhere) | 全てのIPアドレスから許可 |

**セキュリティのベストプラクティス**  
⚠️ 本番環境や実際の開発業務では、ソースを自分のIPアドレスのみに絞ることを推奨

#### アウトバウンドルール
- デフォルトのまま（全てのトラフィック、全てのIPアドレスへ許可）

#### ALBへの適用
1. セキュリティグループ作成後、ALB作成画面に戻る
2. セキュリティグループの更新ボタン（🔄）をクリック
3. デフォルトのセキュリティグループを削除
4. `my-sm-lb-sg`を選択

---

## 29. ターゲットグループの作成

### my-sm-tg

#### 作成手順
1. ALB作成画面の**リスナーとルーティング**セクション
2. **ターゲットグループの作成**をクリック

#### 基本設定
- **ターゲットタイプ**: **IPアドレス**
- **ターゲットグループ名**: `my-sm-tg`
- **プロトコル**: HTTP
- **ポート**: `8080`（コンテナが待ち受けるポート）
- **IPアドレスタイプ**: IPv4
- **VPC**: `my-workspace-vpc`
- **プロトコルバージョン**: HTTP/1

#### ヘルスチェック設定
- **プロトコル**: HTTP
- **ヘルスチェックパス**: `/api/users/status`
  - Spring Bootアプリで定義したステータス確認API
- **成功コード**: `200`

#### 詳細設定（デフォルトでOK）
- 正常のしきい値
- 非正常のしきい値
- タイムアウト
- 間隔

#### ターゲットの登録
- この段階では登録しない（ECSサービス作成時に自動登録される）
- **ターゲットグループの作成**をクリック

#### ALBへの適用
1. ALB作成画面に戻る
2. ターゲットグループの更新ボタン（🔄）をクリック
3. `my-sm-tg`を選択
4. **ロードバランサーの作成**をクリック

---

## 30. ECRリポジトリの作成

### 手順
1. AWSコンソールで**ECR**を検索
2. 左メニューから**リポジトリ**を選択
3. **リポジトリを作成**をクリック

### 設定
- **可視性設定**: プライベート
- **リポジトリ名**: `my-sm`
- その他の設定: デフォルトのまま
- **リポジトリを作成**をクリック

---

## 31. タスク定義の作成

### 手順
1. AWSコンソールで**ECS**を検索
2. 左メニューから**タスク定義**を選択
3. **新しいタスク定義の作成**をクリック

### タスク定義ファミリーの設定
- **タスク定義ファミリー名**: `my-sm`

### インフラストラクチャの要件
- **起動タイプ**: AWS Fargate
- **オペレーティングシステム/アーキテクチャ**: Linux/X86_64
- **CPU**: 0.25 vCPU（最小）
- **メモリ**: 1 GB

### タスクロール
- **タスクロール**: なし（空欄）
- **タスク実行ロール**: `ecsTaskExecutionRole`
  - ECRからイメージをプルし、CloudWatch Logsに書き込むために必要

---

### コンテナの定義

#### コンテナの基本設定
- **名前**: `sessionmanagement`
- **イメージURI**: `<ECRリポジトリURI>:latest`
  - ECRの`my-sm`リポジトリのURIをコピー
  - 末尾に`:latest`を追加

#### イメージURIの取得方法
1. ECRのリポジトリ一覧から`my-sm`を表示
2. URIをコピー
3. タスク定義のイメージURIフィールドに貼り付け
4. 末尾に`:latest`を追加

例: `123456789012.dkr.ecr.us-west-2.amazonaws.com/my-sm:latest`

#### ポートマッピング
- **コンテナポート**: `8080`
- **プロトコル**: TCP
- **ポート名**: 空欄
- **アプリケーションプロトコル**: HTTP

#### ログ収集
- **ログ収集を使用**: ✅ チェックを入れる
- CloudWatch Logsにログが自動送信される

### タスク定義の作成
**作成**ボタンをクリック

---

## 32. Dockerイメージのビルドとプッシュ

### 前提条件
- Dockerがインストールされている
- AWS CLIがインストール・設定済み
- `session-management`ディレクトリにいる

### 手順

#### 1. プッシュコマンドの確認
1. ECRの`my-sm`リポジトリを開く
2. **プッシュコマンドの表示**をクリック
3. 4つのコマンドが表示される

#### 2. AWS認証
```bash
aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin <your-account-id>.dkr.ecr.us-west-2.amazonaws.com
```

#### 3. Dockerイメージのビルド

⚠️ **重要: Platformの指定**

```bash
docker build --platform linux/x86_64 -t my-sm .
```

**なぜPlatformを指定するのか**
- M1/M2 MacやARM環境でビルドする場合に必要
- Fargateはx86_64アーキテクチャで実行されるため
- Platform指定なしだとアーキテクチャ不一致でコンテナが起動しない

#### 4. イメージのタグ付け
```bash
docker tag my-sm:latest <your-account-id>.dkr.ecr.us-west-2.amazonaws.com/my-sm:latest
```

#### 5. ECRへのプッシュ
```bash
docker push <your-account-id>.dkr.ecr.us-west-2.amazonaws.com/my-sm:latest
```

### 確認
ECRの`my-sm`リポジトリに`latest`タグのイメージが表示される

---

## 33. セキュリティグループの作成（ECSサービス用）

### my-sm-service-sg

後でECSサービス作成時に作成する。

#### 設定内容
- **セキュリティグループ名**: `my-sm-service-sg`
- **説明**: `my-sm-service-sg`
- **VPC**: `my-workspace-vpc`

#### インバウンドルール
| タイプ | プロトコル | ポート範囲 | ソース | 説明 |
|--------|-----------|-----------|--------|------|
| カスタムTCP | TCP | 8080 | my-sm-lb-sg | ロードバランサーからのみ許可 |

**ポイント**
- ソースタイプを**セキュリティグループ**にする
- ロードバランサーのセキュリティグループ（`my-sm-lb-sg`）を指定
- これにより、ロードバランサー経由のトラフィックのみ許可される

---

## 34. ECSサービスの作成

### 手順
1. ECSコンソールで**クラスター**を選択
2. `my-ecs-cluster`を選択
3. **サービス**タブで**作成**をクリック

### 環境の設定
- **既存のクラスター**: `my-ecs-cluster`
- **コンピューティング設定**: 起動タイプ
- **起動タイプ**: `FARGATE`
- **プラットフォームバージョン**: `LATEST`

### デプロイ設定
- **アプリケーションタイプ**: サービス
- **タスク定義**:
  - **ファミリー**: `my-sm`
  - **リビジョン**: `1`（LATEST）
- **サービス名**: `my-sm-service`
- **サービスタイプ**: レプリカ
- **必要なタスク**: `3`
  - ⚠️ 複数コンテナでセッション動作を確認するため3つ
  - コストは1つの3倍になるので注意

### ネットワーキング
- **VPC**: `my-workspace-vpc`
- **サブネット**: **パブリックサブネット**を2つ選択
  - プライベートサブネットは削除

### セキュリティグループ
1. **新しいセキュリティグループを作成**を選択
2. 設定:
   - **セキュリティグループ名**: `my-sm-service-sg`
   - **説明**: `my-sm-service-sg`
   - **インバウンドルール**:
     - **タイプ**: カスタムTCP
     - **ポート**: `8080`
     - **ソース**: セキュリティグループ → `my-sm-lb-sg`

### パブリックIP
- **パブリックIPの自動割り当て**: ✅ オン
  - ECRからイメージをプルするために必要

---

### ロードバランシング

#### ロードバランサーの設定
- **ロードバランサータイプ**: Application Load Balancer
- **ロードバランサー**: 既存のロードバランサーを使用
- **ロードバランサー名**: `my-sm-alb`

#### リスナーの設定
- **既存のリスナーを使用**: ✅
- **リスナー**: `80:HTTP`
- **ターゲットグループ**: 既存のターゲットグループを使用
- **ターゲットグループ名**: `my-sm-tg`
- **ヘルスチェックの猶予期間**: 60秒

### サービスの自動スケーリング
- 今回は設定しない（オフ）

### サービスの作成
**作成**ボタンをクリック

---

## 35. デプロイの確認

### サービスの状態確認
1. ECSコンソールでサービス`my-sm-service`を開く
2. **タスク**タブを確認
3. 3つのタスクが**RUNNING**状態になるまで待つ（数分かかる）

### 確認項目
- **必要なタスク数**: 3
- **実行中のタスク数**: 3
- **タスクの状態**: RUNNING

### タスクのヘルスチェック
1. **ターゲット**タブを確認
2. 3つのターゲットが**Healthy**になることを確認

### ロードバランサーのDNS名取得
1. EC2コンソール → **ロードバランサー**
2. `my-sm-alb`を選択
3. **DNS名**をコピー

例: `my-sm-alb-1234567890.us-west-2.elb.amazonaws.com`

---

## 36. 動作確認

### APIテスト

#### 1. ステータス確認
```
GET http://my-sm-alb-XXXXXXXXXX.us-west-2.elb.amazonaws.com/api/users/status
```

**期待結果**: `You Are 'Logged Out'`

#### 2. ログイン
```
GET http://my-sm-alb-XXXXXXXXXX.us-west-2.elb.amazonaws.com/api/users/login
```

**期待結果**: `Logged In`

#### 3. ステータス再確認
```
GET http://my-sm-alb-XXXXXXXXXX.us-west-2.elb.amazonaws.com/api/users/status
```

**現在の挙動（スティッキーセッション無効）**:
- ログインしたのに`You Are 'Logged Out'`が返ることがある
- ロードバランサーが異なるコンテナにリクエストを振り分けるため
- セッション情報が共有されていない

→ この問題を解決するのが**スティッキーセッション**

---

## まとめ

### 作成したAWSリソース

| リソース | 名前 | 用途 |
|---------|------|------|
| ALB | `my-sm-alb` | HTTPトラフィックの負荷分散 |
| セキュリティグループ（ALB用） | `my-sm-lb-sg` | HTTP(80)を許可 |
| ターゲットグループ | `my-sm-tg` | コンテナへのルーティング |
| ECRリポジトリ | `my-sm` | Dockerイメージの保存 |
| タスク定義 | `my-sm` | コンテナの設定 |
| セキュリティグループ（ECS用） | `my-sm-service-sg` | ALBからのみ8080を許可 |
| ECSサービス | `my-sm-service` | 3つのタスクを実行 |

### 次のステップ
**スティッキーセッション**を有効化し、セッション情報が正しく維持されることを確認する。



