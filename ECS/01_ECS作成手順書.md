# AWS VPC・サブネット・ルートテーブル・インターネットゲートウェイ作成手順書

## 概要

本手順書では、AWS マネジメントコンソールから VPC、サブネット、ルートテーブル、インターネットゲートウェイを作成し、ネットワーク環境を構築する手順を説明します。

## 前提条件

- AWS アカウントにログイン済みであること
- リージョン: **US West 2 (オレゴン)** を使用

## ネットワーク設計

### VPC CIDR

- **VPC CIDR**: `10.0.0.0/20`

### サブネット CIDR

| サブネット名                   | CIDR          | 利用可能 IP 数 | 用途         |
| ------------------------------ | ------------- | -------------- | ------------ |
| my-workspace-subnet-private1-a | `10.0.0.0/24` | 256            | プライベート |
| my-workspace-subnet-public1-a  | `10.0.1.0/24` | 256            | パブリック   |

> **注意**: CIDR 設計は後から変更が困難なため、柔軟性と余裕を持たせた設計を推奨します。

---

## 手順 1: リージョンの確認・変更

1. AWS マネジメントコンソールにログイン
2. 画面右上のリージョン選択メニューをクリック
3. **US West (Oregon) us-west-2** を選択

---

## 手順 2: VPC の作成

### 2-1. VPC サービスへの移動

1. 画面上部の検索ボックスに「**VPC**」と入力
2. 表示された「**VPC**」をクリック

### 2-2. VPC 作成画面へ

1. 左側メニューから「**VPC**」をクリック
2. 画面右上の「**VPC を作成**」ボタンをクリック

> **参考**: 初期状態では、デフォルト VPC が 1 つ存在します。これはそのまま残しておいて問題ありません。

### 2-3. VPC 設定

| 項目               | 設定値                     |
| ------------------ | -------------------------- |
| 作成するリソース   | **VPC のみ**               |
| 名前タグ           | `my-workspace-vpc`         |
| IPv4 CIDR ブロック | **手動入力**               |
| IPv4 CIDR          | `10.0.0.0/20`              |
| IPv6 CIDR ブロック | **IPv6 CIDR ブロックなし** |
| テナンシー         | **デフォルト**             |

### 2-4. VPC 作成の実行

1. 設定内容を確認
2. 「**VPC を作成**」ボタンをクリック
3. 作成完了を確認

---

## 手順 3: サブネットの作成

### 3-1. サブネット作成画面へ

1. 左側メニューから「**サブネット**」をクリック
2. 画面右上の「**サブネットを作成**」ボタンをクリック

### 3-2. プライベートサブネットの作成

#### VPC 選択

- **VPC ID**: `my-workspace-vpc` (先ほど作成した VPC) を選択

#### サブネット設定 1

| 項目                          | 設定値                           |
| ----------------------------- | -------------------------------- |
| サブネット名                  | `my-workspace-subnet-private1-a` |
| アベイラビリティーゾーン      | **us-west-2a** (末尾が A のもの) |
| IPv4 VPC CIDR ブロック        | `10.0.0.0/20` (自動表示)         |
| IPv4 サブネット CIDR ブロック | `10.0.0.0/24`                    |

> **確認**: 「256 IPs」と表示されることを確認してください。

#### サブネット作成の実行

1. 設定内容を確認
2. 「**サブネットを作成**」ボタンをクリック

### 3-3. パブリックサブネットの作成

1. 再度「**サブネットを作成**」ボタンをクリック
2. **VPC ID**: `my-workspace-vpc` を選択

#### サブネット設定 2

| 項目                          | 設定値                           |
| ----------------------------- | -------------------------------- |
| サブネット名                  | `my-workspace-subnet-public1-a`  |
| アベイラビリティーゾーン      | **us-west-2a** (末尾が A のもの) |
| IPv4 VPC CIDR ブロック        | `10.0.0.0/20` (自動表示)         |
| IPv4 サブネット CIDR ブロック | `10.0.1.0/24`                    |

> **確認**: 「256 IPs」と表示されることを確認してください。  
> IP アドレス範囲: `10.0.1.0` ～ `10.0.1.255`

#### サブネット作成の実行

1. 設定内容を確認
2. 「**サブネットを作成**」ボタンをクリック

---

## 手順 4: サブネット作成の確認

### サブネット一覧の確認

1. サブネット一覧画面で、フィルターが適用されている場合は「✕」をクリックして解除
2. 以下の 2 つのサブネットが表示されていることを確認:
   - `my-workspace-subnet-private1-a`
   - `my-workspace-subnet-public1-a`

---

## 手順 5: ルートテーブルの作成

### 5-1. プライベートサブネット用ルートテーブルの作成

#### ルートテーブル作成画面へ

1. VPC ダッシュボードの左側メニューから「**ルートテーブル**」をクリック
2. 画面右上の「**ルートテーブルを作成**」ボタンをクリック

> **注意**: 既存のルートテーブルが表示されている場合がありますが、無視して新規作成してください。

#### プライベート用ルートテーブル設定

| 項目 | 設定値                        |
| ---- | ----------------------------- |
| 名前 | `my-workspace-rtb-private1-a` |
| VPC  | `my-workspace-vpc`            |

> **rtb**: Route Table (ルートテーブル) の略称

3. 「**ルートテーブルを作成**」ボタンをクリック

### 5-2. パブリックサブネット用ルートテーブルの作成

1. 再度「**ルートテーブルを作成**」ボタンをクリック

#### パブリック用ルートテーブル設定

| 項目 | 設定値                       |
| ---- | ---------------------------- |
| 名前 | `my-workspace-rtb-public1-a` |
| VPC  | `my-workspace-vpc`           |

2. 「**ルートテーブルを作成**」ボタンをクリック

---

## 手順 6: インターネットゲートウェイの作成

### 6-1. インターネットゲートウェイ作成画面へ

1. 左側メニューから「**インターネットゲートウェイ**」をクリック
2. 「**インターネットゲートウェイの作成**」ボタンをクリック

### 6-2. インターネットゲートウェイ設定

| 項目     | 設定値             |
| -------- | ------------------ |
| 名前タグ | `my-workspace-igw` |

> **igw**: Internet Gateway (インターネットゲートウェイ) の略称

3. 「**インターネットゲートウェイを作成**」ボタンをクリック

### 6-3. VPC へのアタッチ

1. 作成した `my-workspace-igw` にチェックを入れる
2. 画面上部の「**アクション**」メニューをクリック
3. 「**VPC にアタッチ**」を選択

#### アタッチ設定

| 項目           | 設定値             |
| -------------- | ------------------ |
| 使用可能な VPC | `my-workspace-vpc` |

4. 「**インターネットゲートウェイのアタッチ**」ボタンをクリック

---

## 手順 7: パブリックルートテーブルへのルート追加

### 7-1. ルートテーブル選択

1. 左側メニューから「**ルートテーブル**」をクリック
2. `my-workspace-rtb-public1-a` を選択

### 7-2. ルートの編集

1. 下部の「**ルート**」タブをクリック
2. 「**ルートを編集**」ボタンをクリック

> **確認**: デフォルトでは、ターゲットが「local」のルートが 1 つ存在します。

### 7-3. インターネットゲートウェイへのルート追加

1. 「**ルートを追加**」ボタンをクリック

#### ルート設定

| 項目       | 設定値                                          |
| ---------- | ----------------------------------------------- |
| 送信先     | `0.0.0.0/0`                                     |
| ターゲット | インターネットゲートウェイ → `my-workspace-igw` |

> **0.0.0.0/0**: すべての送信先を表す CIDR 表記

2. ターゲット欄をクリックし、「**インターネットゲートウェイ**」を選択
3. 候補から `my-workspace-igw` を選択
4. 「**変更を保存**」ボタンをクリック

> **重要**: プライベートルートテーブル (`my-workspace-rtb-private1-a`) にはインターネットゲートウェイを追加しません。

---

## 手順 8: サブネットへのルートテーブル関連付け

### 8-1. プライベートサブネットへの関連付け

#### サブネット選択

1. 左側メニューから「**サブネット**」をクリック
2. `my-workspace-subnet-private1-a` にチェックを入れる

#### ルートテーブルの関連付け

1. 下部の「**ルートテーブル**」タブをクリック
2. 「**ルートテーブルの関連付けを編集**」ボタンをクリック

#### ルートテーブル選択

| 項目              | 設定値                        |
| ----------------- | ----------------------------- |
| ルートテーブル ID | `my-workspace-rtb-private1-a` |

3. 「**保存**」ボタンをクリック

### 8-2. パブリックサブネットへの関連付け

#### サブネット選択

1. `my-workspace-subnet-public1-a` にチェックを入れる

#### ルートテーブルの関連付け

1. 下部の「**ルートテーブル**」タブをクリック
2. 「**ルートテーブルの関連付けを編集**」ボタンをクリック

#### ルートテーブル選択

| 項目              | 設定値                       |
| ----------------- | ---------------------------- |
| ルートテーブル ID | `my-workspace-rtb-public1-a` |

3. 「**保存**」ボタンをクリック

---

## 構成完了後の状態

### パブリックサブネット

- **サブネット**: `my-workspace-subnet-public1-a`
- **ルートテーブル**: `my-workspace-rtb-public1-a`
- **ルート**:
  - `10.0.0.0/20` → local (VPC 内通信)
  - `0.0.0.0/0` → `my-workspace-igw` (インターネット通信)

### プライベートサブネット

- **サブネット**: `my-workspace-subnet-private1-a`
- **ルートテーブル**: `my-workspace-rtb-private1-a`
- **ルート**:
  - `10.0.0.0/20` → local (VPC 内通信のみ)

---

## 手順 9: ECS クラスターの作成

### 9-1. ECS サービスへの移動

1. AWS マネジメントコンソール画面上部の検索ボックスに「**ECS**」と入力
2. 表示された「**Elastic Container Service**」をクリック

### 9-2. リージョンの確認

1. 画面右上のリージョンが **US West (Oregon) us-west-2** になっていることを確認

> **重要**: 前の手順で VPC をオレゴンリージョンに作成しているため、ECS も同じリージョンで作成する必要があります。

### 9-3. クラスター作成画面へ

1. 「**クラスターの作成**」ボタンをクリック

### 9-4. クラスター設定

#### 基本設定

| 項目                 | 設定値                 |
| -------------------- | ---------------------- |
| クラスター名         | `my-app-cluster`       |
| デフォルトの名前空間 | そのまま（デフォルト） |

#### インフラストラクチャー設定

| 項目                   | 設定値                                    |
| ---------------------- | ----------------------------------------- |
| インフラストラクチャー | **AWS Fargate (サーバーレス)** にチェック |

> **注意**:
>
> - **Fargate**: サーバーレスでコンテナを実行（推奨）
> - **EC2 インスタンス**: EC2 インスタンスを管理してコンテナを実行
> - **ECS Anywhere を使用した外部インスタンス**: オンプレミス環境で使用

今回は Fargate を使用するため、Fargate のみにチェックを入れてください。

### 9-5. クラスター作成の実行

1. 設定内容を確認
2. 「**作成**」ボタンをクリック
3. 1〜2 分程度でクラスター作成が完了します

### 9-6. 作成確認

1. クラスター一覧画面に `my-app-cluster` が表示されていることを確認
2. クラスター名をクリックして詳細画面を開く
3. 以下の状態を確認:
   - **サービス**: 0 個
   - **タスク**: 0 個

> **確認**: この時点ではクラスターのみが作成された状態で、サービスやタスクはまだ存在しません。

---

## 手順 10: タスク定義の作成

### 10-1. タスク定義画面への移動

1. ECS ダッシュボードの左側メニューから「**タスク定義**」をクリック
2. タスク定義の一覧が表示される（初期状態では何も表示されません）

### 10-2. 新しいタスク定義の作成

1. 「**新しいタスク定義の作成**」ボタンをクリック

> **参考**: タスク定義は JSON から作成することも、UI 上で作成することも可能です。今回は UI から作成します。

### 10-3. タスク定義ファミリー設定

| 項目                 | 設定値            |
| -------------------- | ----------------- |
| タスク定義ファミリー | `my-app-frontend` |

> **タスク定義ファミリー**: タスク定義の名前です。

### 10-4. インフラストラクチャー要件の設定

#### 起動タイプ

| 項目       | 設定値                         |
| ---------- | ------------------------------ |
| 起動タイプ | **AWS Fargate (サーバーレス)** |

#### オペレーティングシステム/アーキテクチャ

| 項目                                    | 設定値           |
| --------------------------------------- | ---------------- |
| オペレーティングシステム/アーキテクチャ | **Linux/X86_64** |

> **選択肢**:
>
> - Linux/X86_64: Intel/AMD 系 CPU
> - Linux/ARM64: ARM 系 CPU
> - Windows: Windows コンテナ

#### タスクサイズ

| 項目   | 設定値        | 備考                         |
| ------ | ------------- | ---------------------------- |
| CPU    | **0.25 vCPU** | 最小構成（デモアプリに十分） |
| メモリ | **0.5 GB**    | 最小構成（デモアプリに十分） |

> **重要**: タスクサイズは料金に直結します。
>
> - CPU は 1 時間あたりの vCPU 単位で課金
> - メモリは 1 時間あたりの GB 単位で課金
> - アプリケーションの用途に応じて**必要最小限**のサイズを選択することでコスト削減が可能
>
> 参考: [AWS Fargate 料金](https://aws.amazon.com/jp/fargate/pricing/)

#### タスクロールとタスク実行ロール

| 項目             | 設定値                 | 説明                                                          |
| ---------------- | ---------------------- | ------------------------------------------------------------- |
| タスクロール     | **なし**               | コンテナから AWS サービスにアクセスする際の権限（今回は不要） |
| タスク実行ロール | **新しいロールの作成** | ECR からイメージをプルする等の実行時に必要な権限              |

> **タスクロールとタスク実行ロールの違い**:
>
> - **タスクロール**: コンテナ内のアプリケーションが AWS サービス（S3 など）にアクセスする際に必要
> - **タスク実行ロール**: ECS がタスクを起動する際（ECR からのプル、CloudWatch へのログ送信など）に必要

### 10-5. コンテナの設定

#### コンテナ-1 の基本設定

| 項目         | 設定値                                   |
| ------------ | ---------------------------------------- |
| 名前         | `frontend`                               |
| イメージ URI | `public.ecr.aws/nginx/nginx:stable-perl` |
| 必須コンテナ | **はい**                                 |

#### イメージ URI の取得方法

1. ブラウザで「**AWS ECR Public**」または「**Amazon ECR Public Gallery**」を検索
2. [Amazon ECR Public Gallery](https://gallery.ecr.aws/) を開く
3. 検索ボックスで「**nginx**」を検索、または「Popular registries」から「**nginx**」を選択
4. 「**nginx/nginx**」を選択
5. イメージタグ（例: `stable-perl`）の隣にあるコピーアイコンをクリック
6. イメージ URI（`public.ecr.aws/nginx/nginx:stable-perl`）をコピー
7. タスク定義画面の「イメージ URI」フィールドにペースト

#### ポートマッピング

| 項目                       | 設定値   |
| -------------------------- | -------- |
| コンテナポート             | **80**   |
| プロトコル                 | **TCP**  |
| アプリケーションプロトコル | **HTTP** |

> **説明**: コンテナポート 80 は、NGINX のデフォルト HTTP ポートです。

#### 環境変数

- 特に設定不要（デフォルトのまま）

### 10-6. ログ収集の設定

| 項目               | 設定値                   |
| ------------------ | ------------------------ |
| ログ収集の使用     | **チェックを入れる**     |
| ログドライバー     | **awslogs** (デフォルト) |
| その他のオプション | デフォルトのまま         |

> **重要**: Amazon CloudWatch によるログ収集を有効化します。
>
> - 若干のコストはかかりますが、トラブルシューティングに非常に有用
> - コスト削減が最優先の場合はチェックを外すことも可能ですが、推奨しません

### 10-7. その他の設定

- **ストレージ**: デフォルトのまま
- **その他の設定**: デフォルトのまま

### 10-8. タスク定義の作成実行

1. すべての設定を確認
2. 「**作成**」ボタンをクリック
3. 「`my-app-frontend:1` が正常に作成されました」というメッセージを確認

### 10-9. タスク定義の確認

1. タスク定義一覧画面に戻る
2. `my-app-frontend` が一覧に表示されていることを確認
3. タスク定義名をクリックして詳細を確認

#### タスク定義のリビジョン（バージョン）について

タスク定義名の後ろに `:1` というリビジョン番号が付いています。

**リビジョンの意味**:

- タスク定義のバージョン番号を表します
- 初回作成時は `:1` からスタート
- タスク定義を更新するたびに `:2`、`:3`... とインクリメントされます

**リビジョンが必要な理由**:

- アプリケーションのアップデート時、新しいコンテナイメージを使用する必要がある
- 環境変数やリソース設定の変更が必要になる場合がある
- これらの変更はタスク定義の更新によって実現される

**新しいリビジョンの作成方法**:

1. タスク定義を選択
2. 「**新しいリビジョンの作成**」ボタンをクリック
3. 必要な変更を加えて作成

> **ベストプラクティス**: タスク定義は頻繁にバージョンアップされるのが一般的です。各リビジョンは履歴として保持されるため、必要に応じて以前のバージョンにロールバックすることも可能です。

---

## 手順 11: タスクの実行とデプロイ

### 11-1. クラスター画面への移動

1. ECS ダッシュボードの左側メニューから「**クラスター**」をクリック
2. 作成済みの `my-app-cluster` を選択

### 11-2. タスク実行画面への移動

1. クラスター詳細画面で、デフォルトで「**サービス**」タブが選択されている
2. その横の「**タスク**」タブをクリック
3. 「**新しいタスクの実行**」ボタンをクリック

> **注意**: 今回はサービスではなく、タスクを直接実行します。

### 11-3. コンピューティング設定

| 項目                       | 設定値         |
| -------------------------- | -------------- |
| コンピューティング設定     | **起動タイプ** |
| 起動タイプ                 | **Fargate**    |
| プラットフォームバージョン | **LATEST**     |

> **プラットフォームバージョン**: Fargate のバージョンです。基本的に「LATEST」（最新）を選択します。

### 11-4. デプロイ設定

| 項目                     | 設定値            |
| ------------------------ | ----------------- |
| アプリケーションのタイプ | **タスク**        |
| タスク定義 - ファミリー  | `my-app-frontend` |
| タスク定義 - リビジョン  | **1** (最新)      |
| 必要なタスクの数         | **1**             |
| タスクグループ           | 空欄（設定不要）  |

> **タスクの数**:
>
> - 複数のタスクを起動することも可能（例: 3、4、10 など）
> - タスク数が増えるとその分コストも増加
> - 今回のデモでは 1 つで十分

### 11-5. ネットワーク設定

#### ネットワーキングセクションを展開

「**ネットワーキング**」セクションをクリックして展開

#### VPC とサブネットの設定

| 項目       | 設定値                                   |
| ---------- | ---------------------------------------- |
| VPC        | `my-workspace-vpc`                       |
| サブネット | `my-workspace-subnet-public1-a` のみ選択 |

> **重要**:
>
> - デフォルトでプライベートサブネットとパブリックサブネットの両方が選択されている場合があります
> - **プライベートサブネット (`my-workspace-subnet-private1-a`) のチェックを外してください**
> - パブリックサブネットのみを使用します

#### セキュリティグループの設定

| 項目                       | 設定値                               |
| -------------------------- | ------------------------------------ |
| セキュリティグループ       | **新しいセキュリティグループを作成** |
| セキュリティグループ名     | `my-app-frontend-sg`                 |
| セキュリティグループの説明 | `Security group for frontend task`   |

> **注意**: 説明文には日本語は使用できません。英数字で記入してください。

#### インバウンドルールの設定

| 項目   | 設定値                     |
| ------ | -------------------------- |
| タイプ | **HTTP**                   |
| ポート | **80** (自動設定)          |
| ソース | **Anywhere** (`0.0.0.0/0`) |

> **ソースの選択肢**:
>
> - **Anywhere**: すべての IP アドレスからのアクセスを許可（今回はこれを選択）
> - **カスタム**: 特定の IP アドレス範囲を指定してアクセスを制限（よりセキュア）
>
> **注意**: 本番環境では、アクセス元 IP を適切に制限することを推奨します。

#### パブリック IP 設定

| 項目          | 設定値   |
| ------------- | -------- |
| パブリック IP | **オン** |

> **重要**: パブリック IP を有効にすることで、インターネットから直接アクセス可能になります。

### 11-6. タスクの作成

1. 「**タスクの上書き**」など他の設定は変更不要（デフォルトのまま）
2. すべての設定を確認
3. 「**作成**」ボタンをクリック

### 11-7. タスク起動の確認

#### タスクステータスの確認

1. タスク一覧画面で、新しいタスクのステータスが「**PROVISIONING**」と表示される
2. タスク ID をクリックして詳細画面を開く
3. 下部の「ステータス」セクションで「**PENDING**」から「**RUNNING**」に変わるまで待つ（1〜2 分程度）
4. ステータスが変わらない場合は、画面上部の更新ボタン（🔄）をクリック

#### NGINX へのアクセス確認

1. タスクが「**RUNNING**」ステータスになったことを確認
2. タスク詳細画面上部の「**パブリック IP**」欄に表示されている IP アドレスを確認
3. 「**オープンアドレス**」リンクをクリック、または表示されている IP アドレスをブラウザのアドレスバーに入力
4. NGINX のウェルカムページが表示されることを確認

> **トラブルシューティング**:
> NGINX ページが表示されない場合、以下を確認してください：
>
> - セキュリティグループの設定が正しいか
> - パブリック IP が有効になっているか
> - サブネットがパブリックサブネットになっているか

### 11-8. セキュリティグループ設定の確認

#### セキュリティグループへのアクセス

1. タスク詳細画面で「**ネットワーキング**」タブをクリック
2. 「セキュリティグループ」セクションに表示されているセキュリティグループ ID をクリック

#### インバウンドルールの確認

以下のルールが設定されていることを確認してください：

| タイプ | プロトコル | ポート範囲 | ソース    | 説明                          |
| ------ | ---------- | ---------- | --------- | ----------------------------- |
| HTTP   | TCP        | 80         | 0.0.0.0/0 | IPv4 からの HTTP アクセス許可 |
| HTTP   | TCP        | 80         | ::/0      | IPv6 からの HTTP アクセス許可 |

#### アウトバウンドルールの確認

デフォルト設定（すべてのトラフィックを許可）になっていることを確認：

| タイプ               | プロトコル | ポート範囲 | 送信先    |
| -------------------- | ---------- | ---------- | --------- |
| すべてのトラフィック | すべて     | すべて     | 0.0.0.0/0 |

### 11-9. タスクの停止

動作確認が完了したら、コスト削減のためタスクを停止します。

> **重要**: タスクは実行時間に応じて課金されるため、不要な場合は必ず停止してください。

#### タスク停止手順

1. タスク一覧画面に戻る
2. 停止したいタスクにチェックを入れる
3. 「**停止**」ボタンをクリック
4. 確認ダイアログで「**停止**」をクリック

#### 停止確認

1. タスクのステータスが変化するまで待つ
2. デフォルトでは「実行中」のフィルターが適用されているため、停止後はタスク一覧から消える
3. フィルターを変更することで、停止済みタスクも確認可能

> **確認**: タスク一覧で実行中のタスクが 0 個になっていることを確認してください。

---

## 手順 12: ロードバランサー用セキュリティグループの作成

### 12-1. セキュリティグループの概要

ブルー/グリーンデプロイメントを実現するために、ロードバランサーとそれに関連するセキュリティグループを設定します。

#### セキュリティグループのルール設計

今回、ロードバランサー用に**2 つのインバウンドルール**を設定します：

| ポート | プロトコル | 用途                                           | アクセス元               |
| ------ | ---------- | ---------------------------------------------- | ------------------------ |
| 80     | HTTP       | 本番環境（一般ユーザー向け）                   | すべて (0.0.0.0/0)       |
| 9000   | TCP        | テスト環境（開発者向け・グリーン環境の確認用） | 開発者の IP アドレスのみ |

> **重要なポイント**:
>
> - **ポート 80**: 一般ユーザーが本番環境（ブルー）にアクセスするため、すべての IP アドレスに対してオープン
> - **ポート 9000**: グリーン環境の動作確認用。まだ本番公開前のため、開発者のみがアクセスできるように制限

### 12-2. EC2 サービスへの移動

1. AWS マネジメントコンソール画面上部の検索ボックスに「**EC2**」と入力
2. 表示された「**EC2**」をクリック

### 12-3. セキュリティグループ画面への移動

1. EC2 ダッシュボードの左側メニューから「**セキュリティグループ**」をクリック
2. リージョンが **US West (Oregon) us-west-2** になっていることを確認
3. 以前作成したセキュリティグループ（`my-app-frontend-sg`）が一覧に表示されていることを確認

### 12-4. 新しいセキュリティグループの作成

1. 「**セキュリティグループを作成**」ボタンをクリック

### 12-5. セキュリティグループの基本設定

| 項目                   | 設定値                             |
| ---------------------- | ---------------------------------- |
| セキュリティグループ名 | `my-app-lb-sg`                     |
| 説明                   | `Security group for load balancer` |
| VPC                    | `my-workspace-vpc`                 |

> **略称**:
>
> - **lb**: Load Balancer (ロードバランサー) の略称
> - **sg**: Security Group (セキュリティグループ) の略称
>
> **注意**: 説明欄は必須項目です。日本語は使用できないため、英数字で記入してください。

### 12-6. インバウンドルールの設定

#### ルール 1: 一般ユーザー向け HTTP アクセス（ポート 80）

1. 「**ルールを追加**」ボタンをクリック

| 項目       | 設定値                          |
| ---------- | ------------------------------- |
| タイプ     | **HTTP**                        |
| プロトコル | **TCP** (自動設定)              |
| ポート範囲 | **80** (自動設定)               |
| ソース     | **Anywhere-IPv4** (`0.0.0.0/0`) |

> **警告表示について**:
> 「すべての IP アドレスに対してオープンになっている」という警告が表示されますが、一般ユーザー向けのアプリケーションとして公開するため、この設定は意図的なものです。無視して進めてください。

#### ルール 2: 開発者向けテストアクセス（ポート 9000）

1. 「**ルールを追加**」ボタンをクリック

| 項目       | 設定値                            |
| ---------- | --------------------------------- |
| タイプ     | **カスタム TCP**                  |
| プロトコル | **TCP**                           |
| ポート範囲 | **9000**                          |
| ソース     | **カスタム** (自分の IP アドレス) |

#### 自分の IP アドレスの調べ方

1. ブラウザで新しいタブを開く
2. Google で「**IP アドレス**」または「**IP 確認**」と検索
3. 「**使用中の IP アドレスを確認**」というページをクリック
4. 表示された IP アドレス（例: `123.45.67.89`）をコピー

#### IP アドレスの設定方法

1. セキュリティグループ設定画面のポート 9000 のルールの「ソース」欄に戻る
2. コピーした IP アドレスを入力し、**必ず末尾に `/32` を付ける**
   - 例: `123.45.67.89/32`

> **CIDR 表記の説明**:
>
> - `/32` は 32 ビット全体をネットワーク部として扱う指定
> - これにより、指定した IP アドレスに**完全一致するデバイスからのみ**アクセス可能になります
> - つまり、あなたのパソコンからのみポート 9000 にアクセスできる状態になります

**インバウンドルール設定例**:

| タイプ       | プロトコル | ポート範囲 | ソース          | 説明                                           |
| ------------ | ---------- | ---------- | --------------- | ---------------------------------------------- |
| HTTP         | TCP        | 80         | 0.0.0.0/0       | 一般ユーザー向け HTTP アクセス                 |
| カスタム TCP | TCP        | 9000       | 123.45.67.89/32 | 開発者向けテストアクセス（グリーン環境確認用） |

### 12-7. アウトバウンドルールの確認

デフォルトで以下の設定になっていることを確認してください（変更不要）：

| タイプ               | プロトコル | ポート範囲 | 送信先    |
| -------------------- | ---------- | ---------- | --------- |
| すべてのトラフィック | すべて     | すべて     | 0.0.0.0/0 |

### 12-8. セキュリティグループの作成実行

1. すべての設定を確認
2. 「**セキュリティグループを作成**」ボタンをクリック
3. 作成完了メッセージを確認

### 12-9. 作成確認

1. セキュリティグループ一覧画面で `my-app-lb-sg` が表示されていることを確認
2. セキュリティグループをクリックして詳細を確認
3. インバウンドルールが正しく設定されていることを確認

---

## 手順 13: 追加パブリックサブネットの作成

### 13-1. 追加サブネットが必要な理由

Application Load Balancer (ALB) を作成するには、**最低 2 つのアベイラビリティーゾーン (AZ)** にサブネットが必要です。

#### 現在のネットワーク構成

| リソース   | 名前                             | CIDR          | AZ         | 備考                   |
| ---------- | -------------------------------- | ------------- | ---------- | ---------------------- |
| VPC        | `my-workspace-vpc`               | `10.0.0.0/20` | -          | 4096 個の IP アドレス  |
| サブネット | `my-workspace-subnet-private1-a` | `10.0.0.0/24` | us-west-2a | プライベート           |
| サブネット | `my-workspace-subnet-public1-a`  | `10.0.1.0/24` | us-west-2a | パブリック（IGW 接続） |

現時点では、パブリックサブネットが 1 つ（AZ: us-west-2a）しか存在しないため、もう 1 つの AZ にパブリックサブネットを追加する必要があります。

#### 追加するサブネット

| リソース   | 名前                            | CIDR          | AZ         | 備考                       |
| ---------- | ------------------------------- | ------------- | ---------- | -------------------------- |
| サブネット | `my-workspace-subnet-public1-b` | `10.0.2.0/24` | us-west-2b | パブリック（IGW 接続予定） |

> **重要**: ロードバランサーはインターネットからアクセスを受けるため、**パブリックサブネット**に配置する必要があります。

### 13-2. サブネット作成画面への移動

1. AWS コンソール画面上部の AWS ロゴを右クリック → 「**新しいタブで開く**」
2. 検索ボックスに「**VPC**」と入力して VPC サービスを開く
3. 左側メニューから「**サブネット**」をクリック
4. リージョンが **US West (Oregon) us-west-2** になっていることを確認
5. 現在のサブネット（プライベート 1 つ、パブリック 1 つ）を確認

### 13-3. サブネットの作成

1. 「**サブネットを作成**」ボタンをクリック

#### VPC 選択

| 項目   | 設定値             |
| ------ | ------------------ |
| VPC ID | `my-workspace-vpc` |

#### サブネット設定

| 項目                          | 設定値                           |
| ----------------------------- | -------------------------------- |
| サブネット名                  | `my-workspace-subnet-public1-b`  |
| アベイラビリティーゾーン      | **us-west-2b** (末尾が B のもの) |
| IPv4 VPC CIDR ブロック        | `10.0.0.0/20` (自動表示)         |
| IPv4 サブネット CIDR ブロック | `10.0.2.0/24`                    |

> **CIDR 設計**:
>
> - `10.0.0.0/24`: プライベート 1a（既存）
> - `10.0.1.0/24`: パブリック 1a（既存）
> - `10.0.2.0/24`: パブリック 1b（新規） ← 重複なし

2. 「**サブネットを作成**」ボタンをクリック

### 13-4. 作成確認

1. サブネット一覧画面でフィルターを解除
2. 以下の 3 つのサブネットが表示されていることを確認:
   - `my-workspace-subnet-private1-a` (10.0.0.0/24, us-west-2a)
   - `my-workspace-subnet-public1-a` (10.0.1.0/24, us-west-2a)
   - `my-workspace-subnet-public1-b` (10.0.2.0/24, us-west-2b)

---

## 手順 14: Application Load Balancer の作成

### 14-1. ロードバランサー作成画面への移動

1. EC2 ダッシュボードに戻る（セキュリティグループ設定完了後の画面）
2. 左側メニューの「**ロードバランシング**」セクションから「**ロードバランサー**」をクリック
3. リージョンが **US West (Oregon) us-west-2** になっていることを確認

### 14-2. ロードバランサータイプの選択

1. 「**ロードバランサーの作成**」ボタンをクリック
2. **Application Load Balancer** の「**作成**」ボタンをクリック

> **ロードバランサーの種類**:
>
> - **Application Load Balancer (ALB)**: HTTP/HTTPS レイヤー（レイヤー 7）でのルーティングに最適
> - **Network Load Balancer (NLB)**: TCP/UDP レイヤー（レイヤー 4）での高性能ルーティング
> - **Gateway Load Balancer**: サードパーティの仮想アプライアンス向け
>
> 今回は HTTP/HTTPS プロトコルを使用するため、ALB を選択します。

### 14-3. 基本設定

| 項目               | 設定値                 |
| ------------------ | ---------------------- |
| ロードバランサー名 | `my-app-alb`           |
| スキーム           | **インターネット向け** |
| IP アドレスタイプ  | **IPv4**               |

> **スキーム**:
>
> - **インターネット向け**: インターネットから直接アクセス可能
> - **内部**: VPC 内部からのみアクセス可能
>
> **IP アドレスタイプ**:
>
> - **IPv4**: IPv4 アドレスのみ
> - **デュアルスタック**: IPv4 と IPv6 の両方に対応

### 14-4. ネットワークマッピング

#### VPC 選択

| 項目 | 設定値             |
| ---- | ------------------ |
| VPC  | `my-workspace-vpc` |

#### アベイラビリティーゾーンとサブネットの選択

以下の 2 つの AZ にチェックを入れ、それぞれパブリックサブネットを選択します：

| アベイラビリティーゾーン | サブネット                                    |
| ------------------------ | --------------------------------------------- |
| **us-west-2a**           | `my-workspace-subnet-public1-a` (10.0.1.0/24) |
| **us-west-2b**           | `my-workspace-subnet-public1-b` (10.0.2.0/24) |

> **警告表示について**:
> us-west-2b のサブネットで「インターネットゲートウェイへのルーティングがありません」という警告が表示されますが、後の手順で設定するため、現時点では無視してください。

### 14-5. セキュリティグループの設定

1. セキュリティグループ選択欄をクリック
2. `my-app-lb-sg` を選択
3. **default のセキュリティグループのチェックを外す**
4. `my-app-lb-sg` のみが選択された状態にする

### 14-6. リスナーとルーティングの設定

#### リスナー 1 の設定

| 項目               | 設定値                     |
| ------------------ | -------------------------- |
| プロトコル         | **HTTP**                   |
| ポート             | **80**                     |
| ターゲットグループ | 後で設定（まず作成が必要） |

---

## 手順 15: ターゲットグループの作成（ブルー環境用）

### 15-1. ターゲットグループ作成画面への移動

1. リスナー設定の「**ターゲットグループの作成**」リンクをクリック
2. 新しいタブでターゲットグループ作成画面が開く

### 15-2. ターゲットタイプの選択

| 項目             | 設定値          |
| ---------------- | --------------- |
| ターゲットタイプ | **IP アドレス** |

> **ターゲットタイプの説明**:
>
> - **インスタンス**: EC2 インスタンスを直接ターゲットにする
> - **IP アドレス**: IP アドレスでターゲットを指定（**ECS Fargate の場合はこれを選択**）
> - **Lambda 関数**: AWS Lambda 関数をターゲットにする
> - **Application Load Balancer**: 別の ALB をターゲットにする

### 15-3. ターゲットグループの基本設定

| 項目                 | 設定値                 |
| -------------------- | ---------------------- |
| ターゲットグループ名 | `my-app-frontend-tg-1` |
| プロトコル           | **HTTP**               |
| ポート               | **80**                 |
| IP アドレスタイプ    | **IPv4**               |
| VPC                  | `my-workspace-vpc`     |
| プロトコルバージョン | **HTTP1**              |

> **命名規則**:
>
> - `tg-1` (Target Group 1): ブルー環境用のターゲットグループ
> - 後でグリーン環境用に `tg-2` を作成します

### 15-4. ヘルスチェックの設定

ヘルスチェックは、ターゲット（コンテナ）が正常に動作しているかを定期的に確認する機能です。

| 項目                     | 設定値   |
| ------------------------ | -------- |
| ヘルスチェックプロトコル | **HTTP** |
| ヘルスチェックパス       | `/`      |

#### 詳細設定（デフォルトのまま）

| 項目             | デフォルト値 | 説明                                        |
| ---------------- | ------------ | ------------------------------------------- |
| 正常のしきい値   | 5            | 連続で成功したら Healthy と判断             |
| 非正常のしきい値 | 2            | 連続で失敗したら Unhealthy と判断           |
| タイムアウト     | 5 秒         | レスポンス待機時間                          |
| 間隔             | 30 秒        | ヘルスチェックの実行間隔                    |
| 成功コード       | **200**      | HTTP ステータスコード 200（OK）を正常と判断 |

> **成功コードについて**:
>
> - `200`: HTTP OK（最も一般的）
> - `200-299`: 200 番台すべて（成功系全般）
> - `301`: リダイレクト（必要に応じて）
>
> 今回は NGINX のデフォルトページにアクセスするため、`200` を指定します。

### 15-5. ターゲットの登録

1. 「**次へ**」をクリック
2. 「ターゲットの登録」画面が表示される

> **重要**:
>
> - 現時点ではターゲット（コンテナ）はまだ存在しません
> - ブルー/グリーンデプロイの過程で自動的にターゲットが登録されます
> - **何も登録せずに進めてください**
>   (10.0.0.　のように VPC サブネットからの IPv4 アドレスの入力が書いてたら「**削除**」ボタンをクリック)
>
> 3. ネットワーク欄が `my-workspace-vpc` になっていることを確認
> 4. ポートが **80** になっていることを確認
> 5. ターゲット一覧に何も表示されていないことを確認
> 6. 「**ターゲットグループの作成**」ボタンをクリック

### 15-6. 作成確認

1. 「ターゲットグループが正常に作成されました」というメッセージを確認
2. ターゲットグループ一覧で `my-app-frontend-tg-1` が表示されていることを確認

---

## 手順 16: ロードバランサー作成の完了

### 16-1. リスナー設定の完了

1. ロードバランサー作成画面のタブに戻る
2. ターゲットグループ選択欄の「**🔄 更新**」アイコンをクリック
3. ドロップダウンから `my-app-frontend-tg-1` を選択

### 16-2. その他の設定

- **リスナータグの追加**: 設定不要（デフォルトのまま）
- **その他の設定**: 設定不要（デフォルトのまま）

### 16-3. ロードバランサーの作成実行

1. すべての設定を確認
2. 「**ロードバランサーの作成**」ボタンをクリック
3. 「ロードバランサーが正常に作成されました」というメッセージを確認

### 16-4. ロードバランサーのプロビジョニング確認

1. ロードバランサー一覧画面に移動
2. `my-app-alb` のステータスが「**プロビジョニング中**」と表示される
3. 1〜2 分待つ
4. ステータスが「**アクティブ**」に変わることを確認（必要に応じて更新ボタンをクリック）

### 16-5. リスナーとルールの確認

1. `my-app-alb` を選択
2. 「**リスナーとルール**」タブをクリック
3. 以下の設定が確認できます:

| プロトコル | ポート | デフォルトアクション | ターゲットグループ     | トラフィック配分 |
| ---------- | ------ | -------------------- | ---------------------- | ---------------- |
| HTTP       | 80     | Forward to           | `my-app-frontend-tg-1` | 100%             |

### 16-6. 現在の構成状態

現時点で完成している構成は以下の通りです：

```
一般ユーザー (インターネット)
    ↓ (HTTP, ポート80)
Application Load Balancer (my-app-alb)
    ↓ (100%のトラフィック)
ターゲットグループ1 (my-app-frontend-tg-1) [ブルー環境用]
    ↓ (未接続)
[コンテナ - まだ未作成]
```

---

## 手順 17: ターゲットグループの追加作成（グリーン環境用）

### 17-1. ターゲットグループ作成画面への移動

1. EC2 ダッシュボードの左側メニュー「**ロードバランシング**」セクションから「**ターゲットグループ**」をクリック
2. 「**ターゲットグループの作成**」ボタンをクリック

### 17-2. ターゲットグループの設定

#### ターゲットタイプの選択

| 項目             | 設定値          |
| ---------------- | --------------- |
| ターゲットタイプ | **IP アドレス** |

#### 基本設定

| 項目                 | 設定値                 |
| -------------------- | ---------------------- |
| ターゲットグループ名 | `my-app-frontend-tg-2` |
| プロトコル           | **HTTP**               |
| ポート               | **80**                 |
| IP アドレスタイプ    | **IPv4**               |
| VPC                  | `my-workspace-vpc`     |
| プロトコルバージョン | **HTTP1**              |

> **命名規則**: `tg-2` (Target Group 2) はグリーン環境用のターゲットグループです。

### 17-3. ヘルスチェックの設定

前回と同じ設定を使用します：

| 項目                     | 設定値           |
| ------------------------ | ---------------- |
| ヘルスチェックプロトコル | **HTTP**         |
| ヘルスチェックパス       | `/`              |
| 詳細設定                 | デフォルトのまま |

### 17-4. ターゲットの登録

1. 「**次へ**」をクリック
2. ターゲット登録画面で何も登録せず、そのまま進む
3. ネットワークが `my-workspace-vpc` であることを確認
4. ポートが **80** であることを確認
5. 「**ターゲットグループの作成**」ボタンをクリック

### 17-5. 作成確認

1. 「ターゲットグループが正常に作成されました」というメッセージを確認
2. ターゲットグループ一覧で `my-app-frontend-tg-2` が表示されていることを確認

---

## 手順 18: リスナーの追加（ポート 9000 - グリーン環境用）

### 18-1. ロードバランサー詳細画面への移動

1. 左側メニューの「**ロードバランサー**」をクリック
2. `my-app-alb` を選択
3. 「**リスナーとルール**」タブをクリック
4. 現在は HTTP:80 のリスナーが 1 つだけ表示されている

### 18-2. リスナーの追加

1. 「**リスナーの追加**」ボタンをクリック

#### リスナー設定

| 項目                 | 設定値                 |
| -------------------- | ---------------------- |
| プロトコル           | **HTTP**               |
| ポート               | **9000**               |
| デフォルトアクション | Forward to             |
| ターゲットグループ   | `my-app-frontend-tg-2` |

> **重要**: ポート 9000 は開発者がグリーン環境の動作確認を行うためのポートです。

2. 「**リスナーの追加**」ボタンをクリック

### 18-3. リスナー追加の確認

「**リスナーとルール**」タブで以下の 2 つのリスナーが表示されていることを確認：

| プロトコル | ポート | デフォルトアクション | ターゲットグループ     | 用途                   |
| ---------- | ------ | -------------------- | ---------------------- | ---------------------- |
| HTTP       | 80     | Forward to           | `my-app-frontend-tg-1` | 本番環境（ブルー）     |
| HTTP       | 9000   | Forward to           | `my-app-frontend-tg-2` | テスト環境（グリーン） |

---

## 手順 19: ポート 80 リスナーへのターゲットグループ 2 の追加

### 19-1. ターゲットグループ追加が必要な理由

ブルー/グリーンデプロイメントを ECS で実行する際の要件として、**本番用リスナー（ポート 80）に両方のターゲットグループを登録**しておく必要があります。

これにより、デプロイ時にトラフィックの切り替え（ブルー → グリーン）が可能になります。

### 19-2. ルール編集画面への移動

1. 「**リスナーとルール**」タブで、**HTTP:80** のリスナーを選択（チェックボックスにチェック）
2. 「**ルールの管理**」ドロップダウンから「**ルールの編集**」を選択

### 19-3. デフォルトルールの編集

1. ルール一覧で、一番上のデフォルトルール（**最後（デフォルト）**）にチェックを入れる
2. 「**アクション**」ドロップダウンから「**ルールの編集**」を選択

### 19-4. ターゲットグループの追加

#### デフォルトアクション設定

現在、以下のように表示されているはずです：

| ターゲットグループ     | 重み |
| ---------------------- | ---- |
| `my-app-frontend-tg-1` | 100  |

#### ターゲットグループを追加

1. 「**ターゲットグループの追加**」ボタンをクリック
2. 2 番目のターゲットグループとして `my-app-frontend-tg-2` を選択

#### 重みの設定

| ターゲットグループ     | 重み    | トラフィック配分      |
| ---------------------- | ------- | --------------------- |
| `my-app-frontend-tg-1` | **100** | 99.01%                |
| `my-app-frontend-tg-2` | **1**   | 0.99% → **0%** に変更 |

> **重みの説明**:
>
> - **重み 100:1**: デフォルトでは 99.01%と 0.99%の割合でトラフィックが分散
> - **重み 100:0**: すべてのトラフィック（100%）が tg-1 に流れる
>
> **現在の想定**:
>
> - tg-1 (ブルー環境): 本番稼働中 → 100%のトラフィック
> - tg-2 (グリーン環境): まだ未稼働 → 0%のトラフィック（トラフィックを流さない）

3. `my-app-frontend-tg-2` の重みを **0** に変更
4. 「**変更内容の保存**」ボタンをクリック

### 19-5. 設定確認

1. ルール一覧画面に戻る
2. デフォルトルールのアクション列に以下のように表示されていることを確認：
   - Forward to: `my-app-frontend-tg-1` (100) and `my-app-frontend-tg-2` (0)

---

## 手順 21: ECS 用 IAM ロールの作成（ロードバランサー操作権限）

### 21-1. IAM ロールが必要な理由

ブルー/グリーンデプロイメントでは、ECS がロードバランサーのターゲットグループやリスナーを操作して、トラフィックをブルー環境からグリーン環境に切り替えます。

このため、**ECS にロードバランサーを操作する権限**を付与する必要があります。これを IAM ロール経由で実現します。

### 21-2. 参考ドキュメント

AWS 公式ドキュメント：[**Amazon ECS infrastructure IAM role for load balancers**](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AmazonECSInfrastructureRolePolicyForLoadBalancers.html)

このドキュメントに記載されている手順に従って、AWS CLI を使用して IAM ロールを作成します。

> **参考**: コンソール画面から手動で作成することも可能ですが、今回は AWS CLI を使用します。

### 21-3. AWS CloudShell の起動

AWS CLI を簡単に使用する方法として、AWS CloudShell を利用します。

1. AWS マネジメントコンソール画面右上の「**ターミナルアイコン**」（>\_）をクリック
2. CloudShell が画面下部に表示される（初回は起動に少し時間がかかる場合があります）
3. プロンプトが表示されたら準備完了

#### CloudShell の動作確認

```bash
aws --version
```

AWS CLI のバージョン情報が表示されれば正常に動作しています。

> **CloudShell の利点**:
>
> - AWS CLI がプリインストール済み
> - 認証設定が不要（現在ログイン中のユーザー権限で実行）
> - ブラウザ上で直接操作可能

---

## 手順 22: 信頼ポリシー JSON ファイルの作成

### 22-1. 信頼ポリシーとは

信頼ポリシーは、「このロールを誰が使えるか」を定義するポリシーです。今回は「ECS サービスがこのロールを使用できる」ことを許可します。

### 22-2. JSON ファイルの作成

CloudShell 上で JSON ファイルを作成します。

#### 方法 1: cat コマンドを使用（推奨）

1. CloudShell で以下のコマンドを入力：

```bash
cat << 'EOF' > ecs-infrastructure-trust-policy.json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowAccessToECSForInfrastructureManagement",
      "Effect": "Allow",
      "Principal": {
        "Service": "ecs.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
EOF
```

2. Enter キーを押してファイルを作成

> **警告が表示された場合**: 「複数行のテキストを貼り付けようとしています」という警告が表示されたら、「**貼り付け**」をクリック

#### 方法 2: ローカルでファイルを作成してアップロード

1. ローカル PC で上記 JSON の内容を `ecs-infrastructure-trust-policy.json` として保存
2. CloudShell で「**アクション**」→「**ファイルのアップロード**」を選択
3. 作成したファイルをアップロード

### 22-3. ファイル作成の確認

```bash
cat ecs-infrastructure-trust-policy.json
```

以下のような内容が表示されれば成功です：

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ecs.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```

### 22-4. 信頼ポリシーの内容説明

このポリシーの重要な部分を解説します：

#### STS (Security Token Service) とは

AWS STS は、一時的な認証情報（アクセスキー）を発行するサービスです。

#### sts:AssumeRole の意味

- **STS**: Security Token Service（一時的な認証情報を発行するサービス）
- **AssumeRole**: 発行した認証情報を「引き受ける」（使用する）権限

#### このポリシーの意味

| 項目      | 内容                | 説明                               |
| --------- | ------------------- | ---------------------------------- |
| Principal | `ecs.amazonaws.com` | ECS サービスが対象                 |
| Action    | `sts:AssumeRole`    | STS が発行した認証情報を使用できる |
| Effect    | `Allow`             | 許可する                           |

つまり、「**ECS サービスがこのロールを引き受けて（AssumeRole）、ロールに付与された権限を使用することを許可する**」という意味です。

---

## 手順 23: IAM ロールの作成

### 23-1. ロールの作成コマンド

CloudShell で以下のコマンドを実行します：

```bash
aws iam create-role \
  --role-name ecsInfrastructureRoleForLoadBalancers \
  --assume-role-policy-document file://ecs-infrastructure-trust-policy.json
```

> **注意**: ロール名は複数形の `ecsInfrastructureRoleForLoadBalancers` です（AWS 公式ドキュメント準拠）。ファイル名も一致していることを確認してください。

#### コマンドの説明

| オプション                      | 値                                            | 説明                               |
| ------------------------------- | --------------------------------------------- | ---------------------------------- |
| `--role-name`                   | `ecsInfrastructureRoleForLoadBalancers`       | 作成するロールの名前（複数形）     |
| `--assume-role-policy-document` | `file://ecs-infrastructure-trust-policy.json` | 信頼ポリシーの JSON ファイルを指定 |

### 23-2. 実行結果の確認

成功すると、以下のような JSON 形式のレスポンスが返されます：

```json
{
    "Role": {
        "Path": "/",
        "RoleName": "ecsInfrastructureRoleForLoadBalancers",
        "RoleId": "AROA...",
        "Arn": "arn:aws:iam::123456789012:role/ecsInfrastructureRoleForLoadBalancers",
        "CreateDate": "2025-12-09T...",
        "AssumeRolePolicyDocument": {...}
    }
}
```

### 23-3. IAM コンソールでの確認

1. AWS コンソール画面上部の検索ボックスに「**IAM**」と入力
2. IAM ダッシュボードを開く（CloudShell は最小化しておく）
3. 左側メニューから「**ロール**」をクリック
4. 検索ボックスに「**ecsInfrastructureRoleForLoadBalancers**」と入力
5. 作成したロールが一覧に表示されていることを確認
6. ロール名をクリックして詳細画面を開く

#### 確認ポイント

- 「**許可**」タブ: 現時点では何もポリシーがアタッチされていない（空）
- 「**信頼関係**」タブ: 先ほど設定した信頼ポリシーが表示される

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowAccessToECSForInfrastructureManagement",
      "Effect": "Allow",
      "Principal": {
        "Service": "ecs.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```

---

## 手順 24: IAM ロールへのポリシーのアタッチ

### 24-1. 管理ポリシーのアタッチ

作成したロールに、AWS が提供する管理ポリシー（ロードバランサー操作権限）をアタッチします。

CloudShell で以下のコマンドを実行：

```bash
aws iam attach-role-policy \
  --role-name ecsInfrastructureRoleForLoadBalancers \
  --policy-arn arn:aws:iam::aws:policy/AmazonECSInfrastructureRolePolicyForLoadBalancers
```

#### コマンドの説明

| オプション     | 値                                                                          | 説明                                         |
| -------------- | --------------------------------------------------------------------------- | -------------------------------------------- |
| `--role-name`  | `ecsInfrastructureRoleForLoadBalancers`                                     | ポリシーをアタッチするロールの名前（複数形） |
| `--policy-arn` | `arn:aws:iam::aws:policy/AmazonECSInfrastructureRolePolicyForLoadBalancers` | AWS マネージド管理ポリシーの ARN（完全形）   |

> **管理ポリシーとは**: AWS が事前に用意している、特定の用途に必要な権限をまとめたポリシーパッケージです。

### 24-2. 実行結果

成功した場合、特にレスポンスは返されません（エラーが表示されなければ成功）。

### 24-3. ポリシーアタッチの確認

1. IAM コンソールのロール詳細画面に戻る
2. 「**許可**」タブをクリック
3. 🔄 更新ボタンをクリック
4. 以下のポリシーがアタッチされていることを確認：
   - **AmazonECSInfrastructureRolePolicyForLoadBalancer**

### 24-4. ポリシーの内容確認

1. ポリシー名の横の「**+**」（展開）ボタンをクリック
2. 「**{} JSON**」タブをクリック
3. ポリシーの詳細が表示される

#### 主要な許可アクション（抜粋）

```json
{
  "Effect": "Allow",
  "Action": [
    "elasticloadbalancing:DescribeLoadBalancers",
    "elasticloadbalancing:DescribeListeners",
    "elasticloadbalancing:DescribeTargetGroups",
    "elasticloadbalancing:DescribeTargetHealth",
    "elasticloadbalancing:ModifyListener",
    "elasticloadbalancing:ModifyRule",
    "elasticloadbalancing:RegisterTargets",
    "elasticloadbalancing:DeregisterTargets"
  ],
  "Resource": "*"
}
```

> **ポリシーの意味**:
>
> - ロードバランサーの情報取得（Describe 系）
> - リスナーやルールの変更（Modify 系）
> - ターゲットの登録・解除（Register/Deregister）
>
> これらの権限により、ECS がブルー/グリーンデプロイ時にロードバランサーを操作できるようになります。

---

## 手順 25: IAM ロール作成完了の確認

### 25-1. 作成したロールのまとめ

| 項目         | 内容                                                     |
| ------------ | -------------------------------------------------------- |
| ロール名     | `ecsInfrastructureRoleForLoadBalancers`                  |
| 信頼関係     | ECS サービスがこのロールを使用可能 (`ecs.amazonaws.com`) |
| 許可ポリシー | `AmazonECSInfrastructureRolePolicyForLoadBalancers`      |
| 権限内容     | Elastic Load Balancing の操作権限                        |

### 25-2. 次のステップ

このロールは、次の手順で ECS サービスを作成する際に使用します。ECS サービスの設定で、このロールを指定することで、ブルー/グリーンデプロイメントが可能になります。

### 25-3. CloudShell の終了

作業が完了したら、CloudShell を閉じても問題ありません。次回使用時も同じ環境が保持されます。

---

## 手順 26: ECS サービス定義ファイルの作成

### 26-1. 参考ドキュメント

AWS 公式ドキュメント：[Create an Amazon ECS blue/green deployment](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deploy-blue-green-service.html)

このドキュメントの CLI セクションに従って、ECS サービスをブルー/グリーンデプロイ設定で作成します。

> **注意**: 設定項目が非常に多いため、今回は AWS CLI を使用してサービスを作成します。CLI に慣れることも AWS 学習において重要です。

### 26-2. サービス定義 JSON ファイルのテンプレート取得

1. 上記の参考ドキュメントを開く
2. 「**CLI**」タブをクリック
3. 「Step 1: Create a file named `service-definition.json`」の JSON をコピー

**AWS 公式ドキュメントに記載されている JSON テンプレート（原文）**:

以下は、AWS 公式ドキュメントから引用したブルー/グリーンデプロイ用の service-definition.json の例です。

```json
{
  "serviceName": "myBlueGreenService",
  "cluster": "arn:aws:ecs:us-west-2:123456789012:cluster/sample-fargate-cluster",
  "taskDefinition": "sample-fargate:1",
  "desiredCount": 5,
  "launchType": "FARGATE",
  "networkConfiguration": {
    "awsvpcConfiguration": {
      "subnets": [
        "subnet-09ce6e74c116a2299",
        "subnet-00bb3bd7a73526788",
        "subnet-0048a611aaec65477"
      ],
      "securityGroups": ["sg-09d45005497daa123"],
      "assignPublicIp": "ENABLED"
    }
  },
  "deploymentController": {
    "type": "ECS"
  },
  "deploymentConfiguration": {
    "strategy": "BLUE_GREEN",
    "maximumPercent": 200,
    "minimumHealthyPercent": 100,
    "bakeTimeInMinutes": 2,
    "alarms": {
      "alarmNames": ["myAlarm"],
      "rollback": true,
      "enable": true
    },
    "lifecycleHooks": [
      {
        "hookTargetArn": "arn:aws:lambda:us-west-2:7123456789012:function:checkExample",
        "roleArn": "arn:aws:iam::123456789012:role/ECSLifecycleHookInvoke",
        "lifecycleStages": ["PRE_SCALE_UP"]
      }
    ]
  },
  "loadBalancers": [
    {
      "targetGroupArn": "arn:aws:elasticloadbalancing:us-west-2:123456789012:targetgroup/blue-target-group/54402ff563af1197",
      "containerName": "fargate-app",
      "containerPort": 80,
      "advancedConfiguration": {
        "alternateTargetGroupArn": "arn:aws:elasticloadbalancing:us-west-2:123456789012:targetgroup/green-target-group/cad10a56f5843199",
        "productionListenerRule": "arn:aws:elasticloadbalancing:us-west-2:123456789012:listener-rule/app/my-blue-green-demo/32e0e4f946c3c05b/9cfa8c482e204f7d/831dbaf72edb911",
        "roleArn": "arn:aws:iam::123456789012:role/LoadBalancerManagementforECS"
      }
    }
  ]
}
```

> **注**: 上記の JSON は公式ドキュメントの例です。実際の環境に合わせて以下の項目を編集する必要があります。

### 26-3. ローカル環境でのファイル編集

JSON ファイルは設定項目が多いため、以下の手順で作業します：

1. 上記の JSON テンプレートをお好みのテキストエディタにコピー
2. 自分の環境に合わせて必要な項目を編集（詳細は手順 27 で説明）
3. 完成したファイルを `service-definition.json` として保存
4. CloudShell にアップロード

> **ファイル名**: `service-definition.json`（公式ドキュメント準拠）

---

## 手順 27: サービス定義 JSON ファイルの編集

> **この手順について**: 上記の AWS 公式テンプレートを、今回作成したリソース（VPC、サブネット、セキュリティグループ、ロードバランサーなど）に合わせて編集します。

### 27-1. 基本設定

#### serviceName（サービス名）

```json
"serviceName": "my-app-frontend-service"
```

#### cluster（クラスター ARN）

クラスターの ARN を指定します。

1. ECS コンソールを開く
2. `my-app-cluster` をクリック
3. 「クラスターの概要」セクションに表示されている「**ARN**」をコピー
4. JSON ファイルの `cluster` 欄にペースト
   （例）

```json
"cluster": "arn:aws:ecs:us-west-2:123456789012:cluster/my-app-cluster"
```

#### taskDefinition（タスク定義）

```json
"taskDefinition": "my-app-frontend:1"
```

> **形式**: `タスク定義ファミリー名:リビジョン番号`  
> リビジョン `:1` は最初のバージョンを指定します。

#### desiredCount（必要なタスク数）

```json
"desiredCount": 1
```

> **説明**: 起動するコンテナ（タスク）の数。コスト削減のため `1` を指定します。

#### launchType（起動タイプ）

```json
"launchType": "FARGATE"
```

---

### 27-2. ネットワーク設定

#### networkConfiguration

**subnets（サブネット）**

パブリックサブネット 2 つの ID を指定します。

1. VPC コンソールを開く（新しいタブで）
2. 左側メニューから「**サブネット**」をクリック
3. 検索ボックスに「**my-workspace**」と入力
4. `my-workspace-subnet-public1-a` のサブネット ID をコピー
5. `my-workspace-subnet-public1-b` のサブネット ID をコピー

```json
"networkConfiguration": {
  "awsvpcConfiguration": {
    "subnets": [
      "subnet-0123456789abcdef0",
      "subnet-0123456789abcdef1"
    ],
```

> **重要**: パブリックサブネットのみを指定してください（プライベートサブネットは含めない）。

**securityGroups（セキュリティグループ）**

1. EC2 コンソールを開く（新しいタブで）
2. 左側メニューから「**セキュリティグループ**」をクリック
3. 検索ボックスに「**frontend**」と入力
4. `my-app-frontend-sg` のセキュリティグループ ID をコピー
   （例）

```json
    "securityGroups": [
      "sg-0123456789abcdef0"
    ],
```

**assignPublicIp（パブリック IP 割り当て）**

```json
    "assignPublicIp": "ENABLED"
  }
}
```

---

### 27-3. デプロイ設定

#### [deploymentController（デプロイコントローラー）](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DeploymentController.html)

```json
"deploymentController": {
  "type": "ECS"
}
```

> **デプロイコントローラーの種類**:
>
> - **ECS**: ローリングアップデートまたはブルー/グリーンデプロイ（今回使用）
> - **CODE_DEPLOY**: AWS CodeDeploy を使用したブルー/グリーンデプロイ
> - **EXTERNAL**: サードパーティのデプロイシステムを使用

#### deploymentConfiguration

> **注**: AWS 公式テンプレートでは `"strategy": "BLUE_GREEN"` と記載されていますが、最新の API 仕様では `"deploymentStrategy": "BLUE_GREEN"` も使用できます。両方とも有効です。今回は`"strategy": "BLUE_GREEN"`にする。

**deploymentCircuitBreaker（デプロイサーキットブレーカー）**

```json
"deploymentConfiguration": {
  "strategy": "BLUE_GREEN",
  "maximumPercent": 200,
  "minimumHealthyPercent": 100,
  "bakeTimeInMinutes": 2,
  "alarms": {
    "alarmNames": [
      "myAlarm"
    ],
    "rollback": true,
    "enable": true
  },
```

> **maximumPercent / minimumHealthyPercent**:
> これらのパラメータは主にローリングアップデートで使用されますが、ブルー/グリーンデプロイでも設定します。
>
> - `maximumPercent: 200`: 最大でタスク数の 200%まで起動可能
> - `minimumHealthyPercent: 100`: 最低でもタスク数の 100%を維持

**deploymentStrategy（デプロイ戦略）**

```json
  "deploymentStrategy": "BLUE_GREEN",
```

> **deploymentStrategy**: `BLUE_GREEN`を指定することで、ブルー/グリーンデプロイメントが有効になります。
>
> **AWS 公式テンプレートでの記載**: `"strategy": "BLUE_GREEN"`（どちらも有効）

**blueGreenDeployment（ブルー/グリーン設定）**

```json
  "blueGreenDeployment": {
    "terminationWaitTimeInMinutes": 2,
```

> **terminationWaitTimeInMinutes（ベイク時間/Bake Time)**:
> グリーン環境(新バージョン)へトラフィックを切り替えた後、ブルー環境(旧バージョン)を何分間保持するかを指定します。
>
> **AWS 公式テンプレートでの記載**: `"bakeTimeInMinutes": 2`（フィールド名の違いに注意）
>
> - AWS CLI では `terminationWaitTimeInMinutes` を使用
> - コンソールでは「Bake time」と表示
> - 両方とも同じ機能を指します
>
> **ベイク時間の動作**:
>
> 1. グリーン環境(新バージョン)が起動
> 2. 本番トラフィックがグリーン環境に切り替わる
> 3. ベイク時間中、両環境が稼働(ブルーとグリーンの両方)
> 4. 問題が発生した場合、手動でロールバック可能
> 5. ベイク時間経過後、ブルー環境(旧バージョン)が自動的に削除される
>
> 今回は検証用として `2` 分を指定しています（AWS 公式テンプレートと同じ値）。本番環境では 5〜15 分程度が推奨されます。

**alarms（アラーム）**

> **説明**: CloudWatch アラームを設定できますが、今回は使用しないため削除します。
>
> **AWS 公式テンプレートでの記載例**:
>
> ```json
> "alarms": {
>   "alarmNames": ["myAlarm"],
>   "rollback": true,
>   "enable": true
> }
> ```
>
> 本番環境では、デプロイ失敗時に自動ロールバックするためのアラームを設定することが推奨されます。

**lifecycleHooks（ライフサイクルフック）**

```json
    "lifecycleHooks": []
  }
}
```

> **説明**: デプロイのライフサイクル中に実行するカスタムアクションを設定できますが、今回は使用しないため空配列を指定します。
>
> **AWS 公式テンプレートでの記載例**:
>
> ```json
> "lifecycleHooks": [
>   {
>     "hookTargetArn": "arn:aws:lambda:us-west-2:123456789012:function:checkExample",
>     "roleArn": "arn:aws:iam::123456789012:role/ECSLifecycleHookInvoke",
>     "lifecycleStages": ["PRE_SCALE_UP"]
>   }
> ]
> ```
>
> Lambda 関数を使用して、デプロイの各段階（PRE_SCALE_UP、AFTER_SCALE_UP、TEST_TRAFFIC_SHIFT など）でカスタムチェックを実行できます。

---

### 27-4. ロードバランサー設定

#### loadBalancers 配列

**targetGroupArn（ターゲットグループ ARN - ブルー環境）**

最初に使用するターゲットグループ（tg-1）の ARN を指定します。

1. EC2 コンソールの左側メニューから「**ターゲットグループ**」をクリック
2. `my-app-frontend-tg-1` をクリック
3. ARN をコピー

```json
"loadBalancers": [
  {
    "targetGroupArn": "arn:aws:elasticloadbalancing:us-west-2:123456789012:targetgroup/my-app-frontend-tg-1/...",
    "containerName": "frontend",
    "containerPort": 80,
```

**containerName / containerPort**

- `containerName`: タスク定義で定義したコンテナ名 (`frontend`)
- `containerPort`: コンテナがリッスンするポート (`80`)

**advancedConfiguration（詳細設定 - ブルー/グリーンデプロイ用）**

> **重要**: ブルー/グリーンデプロイメントを使用する場合、`advancedConfiguration`セクションが必須です。このセクションには以下の 4 つの必須項目があります。

**alternateTargetGroupArn（代替ターゲットグループ - グリーン環境）**

新しく作成するグリーン環境用のターゲットグループ(tg-2)の ARN を指定します。

1. ターゲットグループ一覧で `my-app-frontend-tg-2` をクリック
2. ARN をコピー

```json
    "advancedConfiguration": {
      "alternateTargetGroupArn": "arn:aws:elasticloadbalancing:us-west-2:123456789012:targetgroup/my-app-frontend-tg-2/...",
```

> **解説**:
>
> - `targetGroupArn`がブルー環境(現行バージョン)で使用するターゲットグループ
> - `alternateTargetGroupArn`がグリーン環境(新バージョン)で使用するターゲットグループ
> - デプロイ時に自動的に切り替わります

**productionListenerRuleArn（本番リスナールール ARN）**

ポート 80 のリスナールールの ARN を指定します。

1. EC2 コンソールの「**ロードバランサー**」から `my-app-alb` をクリック
2. 「**リスナーとルール**」タブをクリック
3. **HTTP:80** の「**ルール**」列の「**1 のルール**」をクリック
4. 表示されたルール一覧で「**最後(デフォルト)**」のルールをクリック
5. 「**ルール ARN**」をコピーして **productionListenerRule**の値にペースト

```json
    "productionListenerRule": "arn:aws:elasticloadbalancing:us-west-2:123456789012:listener-rule/app/my-blue-green-demo/32e0e4f946c3c05b/9cfa8c482e204f7d/831dbaf72edb911",
```

**testListenerRuleArn（テストリスナールール ARN）**

ポート 9000 のリスナールールの ARN を指定します。

1. 「**リスナーとルール**」タブに戻る
2. **HTTP:9000** の「**ルール**」列の「**1 ルール**」をクリック
3. 表示されたルール一覧で「**default**」のルールをクリック
4. 「**ルール ARN**」をコピー

```json
      "testListenerRuleArn": "arn:aws:elasticloadbalancing:us-west-2:123456789012:listener-rule/app/my-app-alb/...",
```

**roleArn（IAM ロール ARN）**

手順 21〜25 で作成した ECS 用 IAM ロールの ARN を指定します。このロールにより、ECS がロードバランサーを操作する権限が付与されます。

**IAM ロール ARN の取得手順**:

1. **IAM コンソールを開く**

   - 新しいタブで AWS マネジメントコンソールを開く
   - サービス検索で「IAM」と入力して移動

2. **ロールを検索**

   - 左側メニューから「**ロール**」をクリック
   - 検索ボックスに「**ecsinfra**」と入力（または「**ecsInfrastructure**」）
   - 以前設定した `ecsInfrastructureRoleForLoadBalancers` が表示されます

3. **ARN をコピー**

   - `ecsInfrastructureRoleForLoadBalancers` をクリック
   - ロールの詳細ページが開きます
   - 上部に表示されている「**ARN**」をコピー
   - 形式: `arn:aws:iam::123456789012:role/ecsInfrastructureRoleForLoadBalancers`

4. **JSON ファイルにペースト**
   - コピーした ARN を JSON ファイルの `roleArn` フィールドにペースト

```json
      "roleArn": "arn:aws:iam::123456789012:role/ecsInfrastructureRoleForLoadBalancers"
    }
  }
]
```

> **重要**: この IAM ロールは、ECS サービスがブルー/グリーンデプロイ時にロードバランサーのターゲットグループを切り替えるために必要です。手順 25 で作成したロールを必ず指定してください。

---

### 27-5. 完成した JSON ファイルの例

以下は、AWS 公式テンプレートを今回の環境に合わせて編集した完成例です。**実際の値(ARN、ID など)は、自分の環境の値に置き換えてください。**

#### AWS 公式テンプレートとの主な違い

| 項目                     | AWS 公式テンプレート     | 本手順書での設定            | 理由                                   |
| ------------------------ | ------------------------ | --------------------------- | -------------------------------------- |
| `serviceName`            | `myBlueGreenService`     | `my-app-frontend-service`   | 今回作成するサービス名                 |
| `cluster`                | `sample-fargate-cluster` | `my-app-cluster`            | 手順 9 で作成したクラスター            |
| `taskDefinition`         | `sample-fargate:1`       | `my-app-frontend:1`         | 手順 10 で作成したタスク定義           |
| `desiredCount`           | `5`                      | `1`                         | コスト削減のため最小構成               |
| `containerName`          | `fargate-app`            | `frontend`                  | タスク定義で指定したコンテナ名         |
| `alarms`                 | 有効化（オブジェクト）   | 無効化（空配列）            | 今回はアラームを使用しない             |
| `lifecycleHooks`         | Lambda 関数指定あり      | 空配列                      | 今回はライフサイクルフックを使用しない |
| `productionListenerRule` | `productionListenerRule` | `productionListenerRuleArn` | フィールド名の違い（両方有効）         |

#### 完成 JSON（今回の環境用）

```json
{
  "serviceName": "my-app-frontend-service",
  "cluster": "arn:aws:ecs:us-west-2:123456789012:cluster/my-app-cluster",
  "taskDefinition": "my-app-frontend:1",
  "desiredCount": 1,
  "launchType": "FARGATE",
  "networkConfiguration": {
    "awsvpcConfiguration": {
      "subnets": ["subnet-0a1b2c3d4e5f6g7h8", "subnet-9i0j1k2l3m4n5o6p7"],
      "securityGroups": ["sg-0123456789abcdef0"],
      "assignPublicIp": "ENABLED"
    }
  },
  "deploymentController": {
    "type": "ECS"
  },
  "deploymentConfiguration": {
    "deploymentCircuitBreaker": {
      "enable": false,
      "rollback": false
    },
    "maximumPercent": 200,
    "minimumHealthyPercent": 100,
    "deploymentStrategy": "BLUE_GREEN",
    "blueGreenDeployment": {
      "terminationWaitTimeInMinutes": 2,
      "alarms": [],
      "lifecycleHooks": []
    }
  },
  "loadBalancers": [
    {
      "targetGroupArn": "arn:aws:elasticloadbalancing:us-west-2:123456789012:targetgroup/my-app-frontend-tg-1/1234567890abcdef",
      "containerName": "frontend",
      "containerPort": 80,
      "advancedConfiguration": {
        "alternateTargetGroupArn": "arn:aws:elasticloadbalancing:us-west-2:123456789012:targetgroup/my-app-frontend-tg-2/abcdef1234567890",
        "productionListenerRuleArn": "arn:aws:elasticloadbalancing:us-west-2:123456789012:listener-rule/app/my-app-alb/1a2b3c4d5e6f7g8h/9i0j1k2l3m4n5o6p/1234567890abcdef",
        "testListenerRuleArn": "arn:aws:elasticloadbalancing:us-west-2:123456789012:listener-rule/app/my-app-alb/1a2b3c4d5e6f7g8h/abcdef1234567890/fedcba0987654321",
        "roleArn": "arn:aws:iam::123456789012:role/ecsInfrastructureRoleForLoadBalancers"
      }
    }
  ]
}
```

> **参考**: AWS 公式テンプレート（手順 26-2 に記載）と比較することで、ブルー/グリーンデプロイの設定項目の理解が深まります。

> **チェックリスト**: 以下の項目が正しく設定されているか確認してください:
>
> - [ ] `serviceName`: サービス名を入力
> - [ ] `cluster`: ECS クラスターの ARN
> - [ ] `taskDefinition`: タスク定義(ファミリー名:リビジョン)
> - [ ] `subnets`: パブリックサブネット 2 つの ID
> - [ ] `securityGroups`: フロントエンド用セキュリティグループ ID
> - [ ] `targetGroupArn`: ターゲットグループ 1(ブルー環境)の ARN
> - [ ] `alternateTargetGroupArn`: ターゲットグループ 2(グリーン環境)の ARN
> - [ ] `productionListenerRuleArn`: ポート 80 リスナールールの ARN
> - [ ] `testListenerRuleArn`: ポート 9000 リスナールールの ARN
> - [ ] `roleArn`: ECS Infrastructure Role の ARN

---

### 27-6. ファイルの保存

1. 編集が完了したら、ファイルを保存します
2. ファイル名: `service-definition.json`
3. 保存場所: わかりやすい場所（デスクトップやドキュメントフォルダなど）

> **次のステップ**: この JSON ファイルを CloudShell にアップロードし、AWS CLI を使用して ECS サービスを作成します。

---

## 手順 28: CloudShell へのファイルアップロードとサービス作成

### 28-1. 参考ドキュメントの確認

AWS 公式ドキュメント：[Create an Amazon ECS blue/green deployment](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deploy-blue-green-service.html)

今回は、上記ドキュメントの「**CLI**」タブにある「**Step 2: Run the create-service command**」に従ってサービスを作成します。

### 28-2. CloudShell の起動

1. AWS マネジメントコンソールの任意のページを開く
2. 画面右上の検索バーの横にある「**CloudShell**」アイコン（ターミナルのアイコン）をクリック
3. CloudShell が起動するまで待つ（初回は数秒かかります）

> **CloudShell について**: AWS CLI がプリインストールされており、認証情報も自動設定されているため、すぐに AWS CLI コマンドを実行できます。

### 28-3. JSON ファイルのアップロード

1. CloudShell ウィンドウの右上にある「**アクション**」メニューをクリック
2. 「**ファイルをアップロード**」を選択
3. ファイル選択ダイアログが開くので、前回の手順で作成した `service-definition.json` ファイルを選択
4. ローカル環境の保存した場所から見つけて「**開く**」をクリック
5. アップロード完了のメッセージが表示されるまで待つ

### 28-4. アップロードの確認

CloudShell で以下のコマンドを実行し、ファイルが正しくアップロードされたか確認します：

```bash
ls
```

**期待される出力**:

```
service-definition.json
```

> **注**: 以前作成した他の JSON ファイル（例：`ecs-infrastructure-trust-policy.json`）も表示される場合があります。

### 28-5. JSON ファイルの内容確認（オプション）

念のため、アップロードされたファイルの中身を確認します：

```bash
cat service-definition.json
```

JSON 形式でファイルの内容が表示されることを確認してください。設定値が正しいか最終チェックを行います。

### 28-6. ECS サービスの作成

AWS 公式ドキュメントに記載されているコマンドを使用してサービスを作成します。

**実行するコマンド**:

```bash
aws ecs create-service --cli-input-json file://service-definition.json
```

> **コマンドの説明**:
>
> - `aws ecs create-service`: ECS サービスを作成する AWS CLI コマンド
> - `--cli-input-json file://service-definition.json`: JSON ファイルから設定を読み込む
> - `file://` プレフィックスは必須です（ローカルファイルを指定するため）

**コマンドの実行手順**:

1. 上記のコマンドをコピー
2. CloudShell にペースト
3. 警告が表示される場合がありますが、そのまま「ペースト」を選択
4. Enter キーを押してコマンドを実行

### 28-7. コマンド実行結果の確認

コマンドが成功すると、作成されたサービスの詳細情報が JSON 形式で大量に表示されます。

**表示される主な情報**:

- `serviceName`: 作成されたサービス名
- `status`: サービスのステータス（`ACTIVE`であることを確認）
- `desiredCount`: 必要なタスク数（`1`を指定した場合は`1`）
- `deploymentConfiguration`: デプロイ設定（`BLUE_GREEN`が含まれていることを確認）
- `loadBalancers`: ロードバランサー設定

**出力の終了方法**:

JSON の出力が長い場合、ページャー（`less`コマンド）で表示されます：

- キーボードの `q` キーを押すと出力を終了できます
- スペースキーで次のページに進めます

> **成功の確認**: JSON が表示され、エラーメッセージが出ていなければ、サービスの作成は成功です。

---

## 手順 29: サービス作成後の確認

### 29-1. ECS コンソールでサービスの確認

CLI の実行が完了したら、ECS コンソールでサービスが正しく作成されたか確認します。

1. ECS コンソールを開く（新しいタブで）
2. 左側メニューから「**クラスター**」をクリック
3. `my-app-cluster` をクリック
4. 「**サービス**」タブをクリック
5. `my-app-frontend-service` という新しいサービスが表示されることを確認

**確認項目**:

- **サービス名**: `my-app-frontend-service`
- **ステータス**: `ACTIVE`
- **必要なタスク数**: `1`
- **実行中のタスク数**: 起動直後は`0`、数分後に`1`になる

> **注**: このサービスが先ほどの CLI コマンドによって作成されたサービスです。

### 29-2. タスクの確認

1. サービス `my-app-frontend-service` をクリック
2. 「**タスク**」タブをクリック
3. 1 つのタスクが表示されることを確認

> **タスク数について**: JSON ファイルの`desiredCount`を`1`に設定したため、1 つのタスクが作成されます。この値を増やせば、それだけ多くのタスクが起動します。

### 29-3. タスクの詳細確認

1. 表示されているタスクをクリック
2. タスクの詳細ページが開く
3. 下にスクロールして「**ネットワーク**」セクションを確認

**確認項目**:

- **プライベート IP アドレス**: 例 `10.0.2.248`
- **パブリック IP アドレス**: 例 `54.123.45.67`（パブリック IP が割り当てられていることを確認）

### 29-4. パブリック IP での直接アクセス確認

1. タスク詳細ページで「**パブリック IP アドレス**」の横にある「**開く**」リンクをクリック（または IP アドレスをコピーしてブラウザで開く）
2. 新しいタブで `http://[パブリックIPアドレス]` が開く
3. **Welcome to nginx!** のページが表示されることを確認

> **確認できたこと**: タスク（コンテナ）が正しく起動し、NGINX が動作していることが確認できました。

### 29-5. ポート 9000 での直接アクセステスト（失敗例）

次に、ポート 9000 で直接アクセスを試してみます。

1. ブラウザのアドレスバーで、パブリック IP アドレスの末尾に `:9000` を追加
   - 例: `http://54.123.45.67:9000`
2. Enter キーを押す

**結果**: ページが読み込まれず、タイムアウトします（ずっとぐるぐる回ってアクセスできない）

**なぜアクセスできないのか**:

以前の手順で、ロードバランサー用のセキュリティグループ（`my-app-lb-sg`）に対して 9000 番ポートを開放しましたが、これはあくまで**ロードバランサーに対する設定**です。

今回、パブリック IP アドレスを使って直接アクセスした場合：

- **ロードバランサーを経由していない**
- **コンテナ（タスク）に直接アクセスしようとしている**
- コンテナのセキュリティグループ（`my-app-frontend-sg`）では 80 番ポートしか開放していない
- 9000 番ポートは開いていないため、アクセスが拒否される

> **重要な学び**: ポート 9000 にアクセスするには、必ず**ロードバランサーを経由**する必要があります。

---

## 手順 30: ロードバランサー経由でのアクセス確認

### 30-1. ロードバランサーの状態確認

1. ECS コンソールのサービス詳細ページに戻る（`my-app-frontend-service`）
2. 「**正常性とメトリクス**」タブをクリック
3. 「**ロードバランサーの正常性**」セクションに `my-app-alb` が表示されていることを確認
4. ロードバランサー名 `my-app-alb` をクリック

### 30-2. リスナーとターゲットグループの確認

ロードバランサーの詳細ページで、現在の設定を確認します。

1. 「**リスナーとルール**」タブをクリック
2. 2 つのリスナーが表示されることを確認：

**HTTP:9000（テスト用リスナー）**:

- デフォルトアクション: 2 つのターゲットグループが紐付いている
- トラフィックの分配: ターゲットグループ 2 に**100%**のトラフィックが流れている

**HTTP:80（本番用リスナー）**:

- デフォルトアクション: 2 つのターゲットグループが紐付いている
- トラフィックの分配: ターゲットグループ 2 に**100%**のトラフィックが流れている

> **現在の状態**: 2 つのターゲットグループが紐付いていますが、すべてのトラフィックは**ターゲットグループ 2**（`my-app-frontend-tg-2`）にルーティングされています。

### 30-3. ターゲットグループの中身を確認

ターゲットグループ 2 に何が登録されているか確認します。

1. EC2 コンソールを開く（新しいタブで）
2. 左側メニューから「**ターゲットグループ**」をクリック
3. `my-app-frontend-tg-2` をクリック
4. 「**ターゲット**」タブをクリック

**確認できること**:

- **登録済みのターゲット**: 1 つの IP アドレスが登録されている
- **IP アドレス**: 例 `10.0.2.248`（プライベート IP アドレス）
- **ポート**: `80`
- **ヘルスステータス**: `healthy`（数分後に正常になる）

### 30-4. IP アドレスの照合

この IP アドレスが、先ほど確認したタスクのプライベート IP アドレスと一致することを確認します。

1. ECS コンソールのタスク詳細ページに戻る
2. 「**ネットワーク**」セクションの「**プライベート IP アドレス**」を確認
   - 例: `10.0.2.248`
3. ターゲットグループに登録されている IP アドレスと一致することを確認

> **確認できたこと**: ターゲットグループ 2 に、今回デプロイしたタスクが紐づいています。

### 30-5. 現在の構成図

現在、以下のような状態になっています：

```
[インターネット]
    ↓
[Application Load Balancer (my-app-alb)]
    ↓
    ├─ リスナー HTTP:80 → ターゲットグループ2 (100%) → タスク (10.0.2.248)
    └─ リスナー HTTP:9000 → ターゲットグループ2 (100%) → タスク (10.0.2.248)
```

**重要なポイント**:

- ECS サービスを 0 から新しく作成したため、元々ブルー環境（古いコンテナ）は存在しない
- それでも、リスナーはターゲットグループ 2 にルーティングし、新しく起動したタスクと紐づいている
- ターゲットグループ 1（`my-app-frontend-tg-1`）には、まだ何も登録されていない

### 30-6. プライベート IP アドレスが使われる理由

**質問**: なぜパブリック IP アドレスではなく、プライベート IP アドレスがターゲットグループで使われているのか？

**答え**:

- ロードバランサーと ECS タスクは**同じ VPC 内**にデプロイされている
- 同じ VPC 内では、プライベート IP アドレスを使ってお互いに通信できる
- プライベート IP アドレスの方が安全で効率的
- パブリック IP アドレスは外部からの直接アクセス用

> **AWS 推奨**: VPC 内の通信にはプライベート IP アドレスを使用することが推奨されます。

---

## 手順 31: ロードバランサー経由でのポート 9000 アクセス

### 31-1. ロードバランサーの DNS 名を取得

1. EC2 コンソールのロードバランサー一覧に移動
2. `my-app-alb` を選択
3. 下部の詳細パネルで「**DNS 名**」をコピー
   - 例: `my-app-alb-1234567890.us-west-2.elb.amazonaws.com`

### 31-2. ポート 9000 でのアクセステスト

1. 新しいブラウザタブを開く
2. アドレスバーに以下の形式で入力：
   ```
   http://[ロードバランサーのDNS名]:9000
   ```
   - 例: `http://my-app-alb-1234567890.us-west-2.elb.amazonaws.com:9000`
3. Enter キーを押す

**結果**: **Welcome to nginx!** のページが表示される

> **成功！**: 今度はロードバランサーを経由してアクセスできました。

### 31-3. アクセス経路の確認

今回のアクセスは以下の経路をたどりました：

```
[あなたのブラウザ]
    ↓ HTTP リクエスト (ポート9000)
[ロードバランサー my-app-alb] (DNS名でアクセス)
    ↓ リスナー HTTP:9000
[ターゲットグループ my-app-frontend-tg-2]
    ↓ プライベートIPアドレス (10.0.2.248:80)
[ECSタスク (NGINXコンテナ)]
    ↓ レスポンス
[ブラウザにNGINXページが表示]
```

**ポイント**:

1. ロードバランサーは 9000 番ポートでリクエストを受け取る
2. ターゲットグループを通じてタスクの 80 番ポートに転送
3. NGINX からレスポンスが返される
4. ロードバランサーを経由してブラウザに表示

### 31-4. セキュリティ設定の確認

**9000 番ポートへのアクセス制限**:

手順 12 で設定したロードバランサーのセキュリティグループ（`my-app-lb-sg`）では：

- 9000 番ポートは**特定の IP アドレス**（開発者の IP アドレス）からのみ許可
- 一般のユーザーはアクセスできない

> **セキュリティのポイント**: テスト用の 9000 番ポートは、許可された特定の IP アドレスしかアクセスできないため、外部の無関係な人間がアクセスすることはできません。

### 31-5. ポート 80 での確認（オプション）

念のため、本番用のポート 80 でもアクセスできることを確認します。

1. ブラウザのアドレスバーで、`:9000` を削除
   ```
   http://my-app-alb-1234567890.us-west-2.elb.amazonaws.com
   ```
2. Enter キーを押す

**結果**: 同じように**Welcome to nginx!**のページが表示される

> **確認完了**: ポート 80（本番用）とポート 9000（テスト用）の両方でアクセスできることが確認できました。

---

## 手順 32: サービス作成完了の確認

### 32-1. 作成完了チェックリスト

以下がすべて確認できれば、ECS サービスの作成とブルー/グリーンデプロイ設定は成功です：

- [x] CloudShell で AWS CLI コマンドが正常に実行された
- [x] ECS コンソールで `my-app-frontend-service` が表示される
- [x] サービスのステータスが `ACTIVE`
- [x] タスクが 1 つ起動し、ステータスが `RUNNING`
- [x] タスクにパブリック IP アドレスとプライベート IP アドレスが割り当てられている
- [x] パブリック IP アドレスで直接 NGINX ページにアクセスできる（ポート 80 のみ）
- [x] ターゲットグループ 2 にタスクのプライベート IP が登録されている
- [x] ターゲットグループのヘルスステータスが `healthy`
- [x] ロードバランサー経由でポート 80 にアクセスできる
- [x] ロードバランサー経由でポート 9000 にアクセスできる

### 32-2. 現在の環境の理解

**今回作成した構成**:

- ECS サービス: ブルー/グリーンデプロイ対応
- タスク: NGINX コンテナが 1 つ稼働
- ロードバランサー: 2 つのリスナー（ポート 80 と 9000）
- ターゲットグループ: 2 つ（tg-1 と tg-2）
- 現在のトラフィック: すべてターゲットグループ 2 に流れている

**ブルー/グリーン環境について**:

- 今回は新規作成のため、古いバージョン（ブルー環境）は存在しない
- 新しく作成したタスクが自動的にグリーン環境として起動
- 次回のデプロイ時に、ブルー/グリーンの切り替えが発生する

---

# 参考: ブルー/グリーンデプロイのライフサイクルフック

## 概要

ライフサイクルフック（Lifecycle Hooks）は、**ECS が提供するブルー/グリーンデプロイ専用の機能**です。

> **重要**: この機能は CodeDeploy のブルー/グリーンデプロイには存在せず、**ECS ネイティブのブルー/グリーンデプロイメントコントローラーでのみ利用可能**です。

ライフサイクルフックを使用することで、デプロイメントの各ステージで Lambda 関数を実行し、以下のようなカスタム処理が可能になります：

- 自動テストの実行
- 手動承認フローの実装
- 外部監視システムとの連携
- カスタムヘルスチェック

**参考ドキュメント**: [Lifecycle hooks for Amazon ECS service deployments](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-lifecycle-hooks.html)

---

## ブルー/グリーンデプロイのライフサイクル全体像

以下の図は、ブルー/グリーンデプロイメントのライフサイクルステージの全体像を示しています。

![ブルー/グリーンデプロイのライフサイクル](image/blue_green.png)

この図では、デプロイメントが進行する際の各ステージ（PRE_SCALE_UP、POST_SCALE_UP、TEST_TRAFFIC_SHIFT、POST_TEST_TRAFFIC_SHIFT、PRODUCTION_TRAFFIC_SHIFT、POST_PRODUCTION_TRAFFIC_SHIFT）と、それぞれのステージでのトラフィックの流れやコンテナの状態が視覚的に表現されています。

---

## ライフサイクルフックで呼び出す Lambda 関数の作成

ライフサイクルフックによって呼び出される Lambda 関数を作成します。この関数は、ブルー/グリーンデプロイメントの各ステージで実行され、処理の制御を行います。

---

### 手順 1: Lambda サービスへの移動

1. AWS マネジメントコンソールの上部検索欄に「**Lambda**」と入力
2. 表示された「**Lambda**」をクリック

---

### 手順 2: Lambda 関数の作成

#### 2-1. 関数作成画面へ

1. 「**関数の作成**」ボタンをクリック

#### 2-2. 基本設定

| 項目           | 設定値                        |
| -------------- | ----------------------------- |
| 作成方法       | **一から作成**                |
| 関数名         | `my-app-lifecycle-hooks`      |
| ランタイム     | **Python 3.13**               |
| アーキテクチャ | **x86_64** (デフォルトのまま) |

#### 2-3. 実行ロールの設定

「**デフォルトの実行ロールの変更**」セクションで以下を設定：

| 項目       | 設定値                                               |
| ---------- | ---------------------------------------------------- |
| 実行ロール | **基本的な Lambda アクセス権限で新しいロールを作成** |

> **説明**: このロールは、Lambda 関数の実行時に必要な権限を管理します。既存の IAM ロールがあればそれを使用することもできますが、今回は新規作成します。

#### 2-4. 関数の作成実行

1. 設定内容を確認
2. 「**関数の作成**」ボタンをクリック
3. 作成完了を確認（関数名 `my-app-lifecycle-hooks` が表示される）

---

### 手順 3: Lambda 関数コードの実装

#### 3-1. コードエディタへ移動

1. 画面下部の「**コード**」タブが選択されていることを確認
2. コードエディタに `lambda_function.py` が表示されていることを確認
3. デフォルトで実装されている `lambda_handler` 関数が表示される

> **説明**: `lambda_handler` 関数が、ライフサイクルフックによって実際に実行される関数です。

#### 3-2. コードの実装

既存のコードをすべて削除し、以下のコードを入力します：

```python
import json
import logging

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

def lambda_handler(event, context):
    logger.info(f"Event:{json.dumps(event)}")
    logger.info(f"Context:{context}")
    return {
        'HookStatus': 'IN_PROGRESS'
    }
```

#### 3-3. コードの解説

**ロガーの設定**:

```python
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
```

- ログを記録するためのロガーを作成
- ログレベルを DEBUG に設定

**Lambda 関数本体**:

```python
def lambda_handler(event, context):
    logger.info(f"Event:{json.dumps(event)}")
    logger.info(f"Context:{context}")
```

- `json.dumps(event)` でイベント情報を JSON 文字列に変換してログに出力
- f-string（フォーマット済み文字列リテラル）を使用して読みやすく出力
- コンテキスト情報もログに出力
- デバッグや動作確認に有用

**戻り値**:

```python
return {
    'HookStatus': 'IN_PROGRESS'
}
```

- `HookStatus` に `IN_PROGRESS` を返すことで、デプロイメントを一時停止
- これにより、ポート 9000 経由で新しいコンテナにアクセスし、目視でアプリの状態を確認可能

**[HookStatus の値](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-lifecycle-hooks.html)**:

- `IN_PROGRESS`: デプロイメントを一時停止（現在のステージで待機）
- `SUCCEEDED`: 次のステージに進む
- `FAILED`: デプロイメントを終了（ロールバック）

> **今回の目的**: `POST_TEST_TRAFFIC_SHIFT` ステージで処理を一時停止し、ポート 9000 を使って新しいコンテナの状態を目視確認します。

---

### 手順 4: Lambda 関数のデプロイ

#### 4-1. デプロイの実行

1. コードエディタ上部の「**Deploy**」ボタンをクリック
2. 「**正常に更新されました**」というメッセージが表示されることを確認

> **重要**: コードを編集しただけでは有効になりません。必ずデプロイを実行してください。

---

### 手順 5: Lambda 関数のテスト実行

#### 5-1. テストタブへ移動

1. 画面上部の「**テスト**」タブをクリック

#### 5-2. テストの実行

1. 「**テストイベント**」セクション内の「**テスト**」ボタンをクリック
2. 実行結果が表示される

#### 5-3. 実行結果の確認

**実行ステータス**:

- 「**実行中の関数: 成功**」と表示されることを確認

**詳細の確認**:

1. 「**詳細**」セクションを展開
2. レスポンスに以下が含まれていることを確認：

```json
{
  "HookStatus": "IN_PROGRESS"
}
```

**ログ出力の確認**:

1. 「**ログ出力**」セクションを確認
2. 設定したログ（EVENT、CONTEXT）が出力されていることを確認

> **注意**: テスト実行時のイベント情報は、デフォルトのテストイベント JSON です。実際のブルー/グリーンデプロイ時には、ECS から異なるイベント情報が渡されます。

---

### 完了確認

以下が確認できれば、Lambda 関数の作成は成功です：

- [x] Lambda 関数 `my-app-lifecycle-hooks` が作成された
- [x] Python 3.13 ランタイムで実行される
- [x] 実行ロールが自動作成された
- [x] コードが正常にデプロイされた
- [x] テスト実行が成功し、`HookStatus: IN_PROGRESS` が返された
- [x] ログに Event と Context が出力された

---

次のステップでは、この Lambda 関数を ECS のブルー/グリーンデプロイメントのライフサイクルフックに登録し、実際のデプロイ時に呼び出されるように設定します。

---

## ライフサイクルフック用の IAM ロール作成

ECS からライフサイクルフック経由で Lambda 関数を実行するためには、**ECS に対して Lambda 関数を実行する権限を与える必要**があります。そのための IAM ロールを作成します。

> **参考ドキュメント**: [Permissions required for Amazon ECS blue/green deployments](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/blue-green-permissions.html)

---

### 手順 1: IAM サービスへの移動

1. AWS マネジメントコンソールの上部検索欄に「**IAM**」と入力
2. 表示された「**IAM**」をクリック

---

### 手順 2: IAM ロールの作成

#### 2-1. ロール作成画面へ

1. 左側メニューから「**ロール**」をクリック
2. 「**ロールを作成**」ボタンをクリック

#### 2-2. 信頼されたエンティティタイプの選択

1. 「**カスタム信頼ポリシー**」を選択

#### 2-3. カスタム信頼ポリシーの設定

以下の JSON ポリシーを入力します（[公式ドキュメント](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/blue-green-permissions.html)から引用）：

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": ["ecs.amazonaws.com"]
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```

> **説明**: この信頼ポリシー（Trust Policy）により、Amazon ECS サービスがこのロールを引き受ける（Assume）ことができるようになります。これにより、ECS はこのロールに付与された権限を使用して Lambda 関数を実行できます。

#### 2-4. 許可ポリシーの設定

1. 「**次へ**」ボタンをクリック
2. 許可ポリシーは後で追加するため、**何も選択せずに「次へ」**をクリック

#### 2-5. ロール名の設定

| 項目     | 設定値                                                                |
| -------- | --------------------------------------------------------------------- |
| ロール名 | `myAppEcsLifecycleHooks`                                              |
| 説明     | (任意) ECS ライフサイクルフックから Lambda 関数を実行するためのロール |

#### 2-6. ロールの作成実行

1. 設定内容を確認
2. 「**ロールを作成**」ボタンをクリック
3. 作成完了を確認

---

### 手順 3: インラインポリシーの追加

#### 3-1. 作成したロールの選択

1. ロール一覧から「**myAppEcsLifecycleHooks**」を検索
2. クリックして詳細画面を開く

#### 3-2. インラインポリシー作成画面へ

1. 「**許可**」タブを選択（デフォルトで選択されている）
2. 「**許可ポリシー**」セクション内の「**許可を追加**」をクリック
3. ドロップダウンから「**インラインポリシーを作成**」を選択

#### 3-3. ポリシーエディターの選択

1. ポリシーエディターで「**JSON**」タブを選択

#### 3-4. Lambda 実行権限ポリシーの設定

既存の JSON を削除し、以下のポリシーを入力します（[公式ドキュメント](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/blue-green-permissions.html)を参考にカスタマイズ）：

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": ["lambda:InvokeFunction"],
      "Resource": "arn:aws:lambda:*:*:function:my-app-lifecycle-hooks"
    },
    {
      "Effect": "Allow",
      "Action": ["iam:PassRole", "lambda:InvokeFunction"],
      "Resource": "arn:aws:lambda:*:*:function:my-app-lifecycle-hooks"
    }
  ]
}
```

> **重要**: `Resource` の値は、以下のように構成されています：
>
> - `us-west-2`: 使用しているリージョン
> - `*`: AWS アカウント ID（ワイルドカードでも可）
> - `my-app-lifecycle-hooks`: 作成した Lambda 関数名
>
> この設定により、指定した Lambda 関数のみを実行できるように制限されます。

**ポリシーの解説**:

- **Action**: `lambda:InvokeFunction` - Amazon ECS がデプロイメントライフサイクルの各ステージで、ライフサイクルフックとして設定された Lambda 関数を呼び出すことを許可します
- **Resource**: 実行を許可する Lambda 関数の ARN を指定
  - 形式: `arn:aws:lambda:<リージョン>:<アカウントID>:function:<関数名>`
  - 今回は特定の関数 `my-app-lifecycle-hooks` のみを指定してセキュリティを向上させています
  - ワイルドカードを使用する場合は `arn:aws:lambda:*:*:function:ecs-*` のように命名規則で制限することも可能です

#### 3-5. ポリシーの確認と作成

1. 「**次へ**」ボタンをクリック
2. ポリシー名を入力：`app-invoke-lambda-function`
3. 「**ポリシーの作成**」ボタンをクリック

---

### 手順 4: 設定の確認

#### 4-1. ロール詳細の確認

1. `myAppEcsLifecycleHooks` の詳細画面に戻る
2. 「**許可ポリシー**」に `app-invoke-lambda-function` が表示されていることを確認
3. 「**信頼関係**」タブをクリックし、ECS サービスが信頼されたエンティティとして設定されていることを確認

#### 4-2. ARN の取得（後で使用）

1. ロール詳細画面の上部にある「**ARN**」をコピー
2. 後のステップで使用するため、メモ帳などに保存しておく

ARN 形式の例:

```
arn:aws:iam::123456789012:role/myAppEcsLifecycleHooks
```

---

### 完了確認

以下が確認できれば、IAM ロールの作成は成功です：

- [x] IAM ロール `myAppEcsLifecycleHooks` が作成された
- [x] 信頼ポリシーで ECS サービスが `sts:AssumeRole` を実行できる
- [x] インラインポリシー `app-invoke-lambda-function` が追加された
- [x] Lambda 関数 `my-app-lifecycle-hooks` の実行権限が付与された
- [x] ロールの ARN が確認できた

---

## ECS サービスの更新（ライフサイクルフックの設定）

作成した Lambda 関数と IAM ロールを使用して、ECS サービスにライフサイクルフックを設定します。この設定により、ブルー/グリーンデプロイメントの特定のステージで Lambda 関数が自動的に呼び出されるようになります。

---

### 手順 1: デプロイ設定 JSON ファイルの準備

#### 1-1. 既存の JSON ファイルを開く

以前の手順 32「ECS サービスの作成（ブルー/グリーンデプロイ設定）」で使用した `service-definition.json` ファイルを開きます。

> **注意**: ファイルを紛失した場合でも問題ありません。必要な部分だけを新規作成すれば大丈夫です。

#### 1-2. deploymentConfiguration 部分を抽出

`service-definition.json` から、以下の `deploymentConfiguration` セクション全体をコピーします：

```json
{
  "deploymentConfiguration": {
    "deploymentCircuitBreaker": {
      "enable": true,
      "rollback": true
    },
    "maximumPercent": 200,
    "minimumHealthyPercent": 100,
    "alarms": {
      "alarmNames": [],
      "enable": false,
      "rollback": false
    },
    "strategy": "blueGreenDeployment",
    "blueGreenDeployment": {
      "terminationWaitTimeInMinutes": 5,
      "deploymentType": "EXTERNAL",
      "externalDeploymentController": {
        "strategy": "ECS"
      }
    },
    "lifecycleHooks": []
  }
}
```

#### 1-3. 新しいファイルを作成

1. 任意のテキストエディタを開く
2. コピーした内容を貼り付け
3. `update-service.json` という名前で保存

---

### 手順 2: ライフサイクルフックの設定

#### 2-1. lifecycleHooks 配列を編集

`lifecycleHooks` の空配列 `[]` を以下のように編集します：

```json
"lifecycleHooks": [
  {
    "hookTargetArn": "",
    "roleArn": "",
    "lifecycleStages": [
      "POST_TEST_TRAFFIC_SHIFT"
    ]
  }
]
```

#### 2-2. 設定項目の説明

| 項目              | 説明                                                | 設定値                    |
| ----------------- | --------------------------------------------------- | ------------------------- |
| `hookTargetArn`   | 実行する Lambda 関数の ARN                          | 後で入力                  |
| `roleArn`         | Lambda 関数を実行するための IAM ロールの ARN        | 後で入力                  |
| `lifecycleStages` | Lambda 関数を実行するライフサイクルステージ（配列） | `POST_TEST_TRAFFIC_SHIFT` |

**lifecycleStages の値**:

- `PRE_SCALE_UP`: スケールアップ前
- `POST_SCALE_UP`: スケールアップ後
- `TEST_TRAFFIC_SHIFT`: テストトラフィックシフト時
- `POST_TEST_TRAFFIC_SHIFT`: テストトラフィックシフト後
- `PRODUCTION_TRAFFIC_SHIFT`: 本番トラフィックシフト時
- `POST_PRODUCTION_TRAFFIC_SHIFT`: 本番トラフィックシフト後

> **今回の設定**: `POST_TEST_TRAFFIC_SHIFT` ステージで Lambda 関数を実行し、デプロイメントを一時停止します。これにより、ポート 9000 経由で新しいコンテナの状態を確認できます。

> **複数ステージの設定**: 配列なので、複数のステージを指定可能です。例: `["POST_SCALE_UP", "POST_TEST_TRAFFIC_SHIFT"]`

---

### 手順 3: ARN 情報の取得と設定

#### 3-1. Lambda 関数の ARN を取得

1. AWS マネジメントコンソールで「**Lambda**」を開く
2. `my-app-lifecycle-hooks` をクリック
3. 画面右上に表示されている「**関数 ARN**」をコピー

ARN 形式の例:

```
arn:aws:lambda:us-west-2:123456789012:function:my-app-lifecycle-hooks
```

4. `update-service.json` の `hookTargetArn` にペースト

#### 3-2. IAM ロールの ARN を取得

1. AWS マネジメントコンソールで「**IAM**」を開く
2. 左側メニューから「**ロール**」をクリック
3. `myAppEcsLifecycleHooks` を検索してクリック
4. 画面上部に表示されている「**ARN**」をコピー

ARN 形式の例:

```
arn:aws:iam::123456789012:role/myAppEcsLifecycleHooks
```

5. `update-service.json` の `roleArn` にペースト

#### 3-3. 完成した JSON ファイルの例

```json
{
  "deploymentConfiguration": {
    "deploymentCircuitBreaker": {
      "enable": true,
      "rollback": true
    },
    "maximumPercent": 200,
    "minimumHealthyPercent": 100,
    "alarms": {
      "alarmNames": [],
      "enable": false,
      "rollback": false
    },
    "strategy": "blueGreenDeployment",
    "blueGreenDeployment": {
      "terminationWaitTimeInMinutes": 5,
      "deploymentType": "EXTERNAL",
      "externalDeploymentController": {
        "strategy": "ECS"
      }
    },
    "lifecycleHooks": [
      {
        "hookTargetArn": "arn:aws:lambda:us-west-2:123456789012:function:my-app-lifecycle-hooks",
        "roleArn": "arn:aws:iam::123456789012:role/myAppEcsLifecycleHooks",
        "lifecycleStages": ["POST_TEST_TRAFFIC_SHIFT"]
      }
    ]
  }
}
```

> **重要**: 上記の例は参考です。**実際の ARN 値は、自分の環境の値に必ず置き換えてください。**

#### 3-4. ファイルの保存

編集が完了したら、`update-service.json` を保存します。

---

### 手順 4: CloudShell へのファイルアップロード

#### 4-1. CloudShell を開く

1. AWS マネジメントコンソールの右上にある「**CloudShell**」アイコンをクリック
2. CloudShell が起動するまで待機

#### 4-2. ファイルをアップロード

1. CloudShell 画面上部の「**アクション**」メニューをクリック
2. 「**ファイルのアップロード**」を選択
3. `update-service.json` を選択
4. アップロード完了を確認

#### 4-3. ファイルの確認

```bash
ls -la
```

`update-service.json` が表示されることを確認します。

---

### 手順 5: AWS CLI コマンドでサービスを更新

#### 5-1. 必要な情報の確認

以下の情報を確認します：

| 項目              | 値                        |
| ----------------- | ------------------------- |
| クラスター名      | `my-app-cluster`          |
| サービス名        | `my-app-frontend-service` |
| JSON 設定ファイル | `update-service.json`     |

#### 5-2. update-service コマンドの実行

CloudShell で以下のコマンドを実行します：

```bash
aws ecs update-service \
  --cluster my-app-cluster \
  --service my-app-frontend-service \
  --deployment-configuration file://update-service.json
```

**コマンドの説明**:

- `aws ecs update-service`: ECS サービスを更新するコマンド
- `--cluster`: 対象のクラスター名を指定
- `--service`: 更新するサービス名を指定
- `--deployment-configuration`: デプロイ設定を JSON ファイルから読み込む

#### 5-3. 実行結果の確認

コマンドが成功すると、大量の JSON 形式の出力が表示されます。これはサービスの更新された設定情報です。

出力を終了するには、キーボードで **`q`** を押します。

---

### 手順 6: ECS コンソールでの確認

#### 6-1. ECS サービスページへ移動

1. CloudShell を最小化または閉じる
2. AWS マネジメントコンソールで「**ECS**」を開く
3. 左側メニューから「**クラスター**」をクリック
4. `my-app-cluster` をクリック
5. 「**サービス**」タブをクリック
6. `my-app-frontend-service` をクリック

#### 6-2. デプロイ設定の確認

1. 「**デプロイ**」タブをクリック
2. 下にスクロールして「**デプロイ設定**」セクションを確認
3. 「**デプロイライフサイクルフック**」という項目が表示されていることを確認

**確認項目**:

- **デプロイステージ**: `テストトラフィック移行後` (POST_TEST_TRAFFIC_SHIFT)
- **Lambda 関数**: `my-app-lifecycle-hooks` の ARN
- **ロール**: `myAppEcsLifecycleHooks` の ARN

これらが表示されていれば、ライフサイクルフックの設定が正常に反映されています。

次のステップでは、カスタムコンテナイメージを作成し、実際にブルー/グリーンデプロイメントを実行してライフサイクルフックの動作を確認します。

---

# ECR リポジトリの作成とカスタムコンテナイメージの準備

## 概要

ブルー/グリーンデプロイメントを実際に動作させるため、カスタムコンテナイメージを作成します。現在稼働中の NGINX コンテナ（「Welcome to nginx!」ページ）を、独自の「Hello World」ページを表示するコンテナに置き換えます。

---

## 現在の環境と実施内容

### 現在の状態

現在、ECS サービスで稼働しているコンテナは、AWS が提供する公開 NGINX イメージをそのまま使用しています：

```
AWS公開ECRリポジトリ → NGINXイメージ → ECSタスク → "Welcome to nginx!" ページ
```

このイメージはカスタマイズされておらず、デフォルトの NGINX ページが表示されます。

### 実施する内容

独自の「Hello World」ページを表示するカスタムコンテナイメージを作成し、デプロイします：

```
自分のECRリポジトリ → カスタムNGINXイメージ → ECSタスク → "Hello World" ページ
```

### 作業の流れ

1. **ECR リポジトリの作成** - カスタムイメージを保存する場所を作成
2. **カスタムアプリの作成** - HTML と NGINX 設定ファイルを作成
3. **コンテナイメージのビルドとプッシュ** - Docker イメージを作成して ECR にアップロード

> **ECR とは**: Elastic Container Registry - Docker コンテナイメージを保存・管理するための AWS サービスです。詳細については、以前の講義「ECR とは？」を参照してください。

---

## 手順 1: ECR リポジトリの作成

### 1-1. ECR サービスへの移動

#### 方法 1: 検索から直接移動

1. AWS マネジメントコンソールの上部検索欄に「**ECR**」と入力
2. 「**機能**」セクションに表示される「**リポジトリ**」をクリック

#### 方法 2: ECS コンソール経由

1. AWS マネジメントコンソールの上部検索欄に「**ECS**」と入力
2. 「**Elastic Container Service**」をクリック
3. 左側メニューから「**Amazon ECR**」を展開
4. 「**リポジトリ**」をクリック

### 1-2. リージョンの確認

画面右上のリージョン選択で「**US West (Oregon) us-west-2**」が選択されていることを確認します。

### 1-3. リポジトリタイプの選択

リポジトリページに以下の 2 つのタブが表示されます：

| タイプ           | 説明                               | 用途                                     |
| ---------------- | ---------------------------------- | ---------------------------------------- |
| **プライベート** | 権限を持つユーザーのみアクセス可能 | 社内・チーム内で使用するアプリケーション |
| **パブリック**   | インターネット上で一般公開         | オープンソースプロジェクトなど           |

今回は「**プライベート**」タブを選択します。

> **推奨**: 業務で開発するアプリケーションは、通常プライベートリポジトリを使用します。パブリックに公開する必要がない限り、プライベートを選択してください。

### 1-4. リポジトリ作成画面へ

1. 「**リポジトリを作成**」ボタンをクリック

### 1-5. リポジトリ設定

#### 基本設定

| 項目         | 設定値            |
| ------------ | ----------------- |
| 可視性設定   | **プライベート**  |
| リポジトリ名 | `my-app-frontend` |

> **注意**: リポジトリ名は、後で Docker 操作で使用するため、正確に入力してください。

#### その他の設定（オプション）

以下の項目は、今回は**デフォルトのまま（設定なし）**で問題ありません：

| 項目                     | 説明                     | 今回の設定            |
| ------------------------ | ------------------------ | --------------------- |
| タグのイミュータビリティ | イメージタグの上書き防止 | 無効（デフォルト）    |
| イメージスキャン         | 脆弱性の自動スキャン     | 無効（デフォルト）    |
| 暗号化設定               | イメージの暗号化方法     | AES-256（デフォルト） |

> **補足**:
>
> - **イメージスキャン**: 本番環境では有効化を推奨しますが、今回のテスト環境では不要です
> - **暗号化設定**: セキュリティ要件に応じて KMS キーを使用することも可能です

### 1-6. リポジトリの作成実行

1. 設定内容を確認
2. 「**リポジトリを作成**」ボタンをクリック
3. 作成完了のメッセージが表示される

### 1-7. 作成されたリポジトリの確認

1. リポジトリ一覧に `my-app-frontend` が表示されることを確認
2. リポジトリ名をクリックして詳細画面を開く
3. 現時点では「**イメージがありません**」と表示される（これは正常です）

**リポジトリ URI**:

詳細画面に以下の形式の URI が表示されます（後で使用するためメモしておいてください）：

```
123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend
```

形式: `<アカウントID>.dkr.ecr.<リージョン>.amazonaws.com/<リポジトリ名>`

## カスタムアプリケーションの作成

ECR リポジトリにプッシュするカスタムコンテナイメージを作成します。「Hello World」ページを表示するシンプルな Web アプリケーションと、その Docker イメージを構築します。

---

### アプリケーション構造の理解

#### 現在のアプリケーション構造（アップデート前）

```
ECSタスク
└── NGINXコンテナ
    ├── NGINX（HTTPサーバー）
    └── デフォルトHTML（"Welcome to nginx!"）
```

**動作フロー**:

1. ブラウザから HTTP GET リクエスト（ポート 80）
2. タスクのポート 80 → コンテナのポート 80（ポートマッピング）
3. NGINX がリクエストを受信
4. デフォルト HTML ファイル（"Welcome to nginx!"）を返す

#### 新しいアプリケーション構造（アップデート後）

```
ECSタスク
└── カスタムNGINXコンテナ
    ├── NGINX（HTTPサーバー）
    └── カスタムHTML（"Hello World"）← 変更点
```

**変更内容**:

- NGINX が返す HTML ファイルを「Hello World」ページに変更
- 基本的なデータフローは同じ

#### 実装する内容

1. **HTML ファイルの作成** - 「Hello World」を表示する HTML ファイル
2. **NGINX 設定ファイルの作成** - カスタム HTML を返すように設定
3. **Dockerfile の作成** - コンテナイメージのビルド設定

---

### 手順 1: 作業ディレクトリの準備

#### 1-1. ローカル環境での作業

> **注意**: 以下の手順はローカルマシン（Windows または Mac）で実行します。Docker Desktop がインストールされている必要があります。

#### 1-2. ターミナルを開く

**Windows の場合**:

1. スタートメニューから「**PowerShell**」または「**コマンドプロンプト**」を検索
2. 起動する

#### 1-3. 作業ディレクトリの作成

任意の場所に作業用ディレクトリを作成します。以下はデスクトップに作成する例です：

```bash
cd /Desktop
mkdir -p ecs/blue-green-deploy
cd ecs/blue-green-deploy
```

### 手順 2: HTML ファイルの作成

#### 2-1. エディタで作業ディレクトリを開く

Visual Studio Code（VS Code）を使用します：

1. VS Code を起動
2. 「**ファイル**」→「**フォルダーを開く**」を選択
3. 先ほど作成した `ecs/blue-green-deploy` ディレクトリを選択
4. 「**開く**」をクリック

#### 2-2. HTML ディレクトリの作成

1. VS Code の左側のエクスプローラーで、フォルダーアイコン（新しいフォルダー）をクリック
2. フォルダー名に「**html**」と入力して Enter

#### 2-3. index.html ファイルの作成

1. 作成した `html` フォルダーを右クリック
2. 「**新しいファイル**」を選択
3. ファイル名に「**index.html**」と入力して Enter

#### 2-4. HTML コードの記述

`index.html` に以下のコードを入力します：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Hello World App</title>
  </head>
  <body>
    <h1>Hello World</h1>
  </body>
</html>
```

**コードの説明**:

- シンプルな HTML ファイル
- `<h1>Hello World</h1>` が画面に表示される
- NGINX がこのファイルを HTTP レスポンスとして返す

#### 2-5. ファイルの保存

`Ctrl + S`で保存します。

---

### 手順 3: NGINX 設定ファイルの作成

#### 3-1. nginx.conf ファイルの作成

1. `ecs/blue-green-deploy`（ルート）ディレクトリを右クリック
2. 「**新しいファイル**」を選択
3. ファイル名に「**nginx.conf**」と入力して Enter

> **注意**: `html` ディレクトリ内ではなく、ルートディレクトリに作成してください。

#### 3-2. NGINX 設定の記述

`nginx.conf` に以下の設定を入力します：

```nginx
server {
    listen 80;

    location / {
        root /var/www;
        index index.html index.htm;
    }
}
```

**設定の解説**:

| 行  | 設定項目                      | 説明                                                                     |
| --- | ----------------------------- | ------------------------------------------------------------------------ |
| 2   | `listen 80;`                  | ポート 80 で HTTP リクエストを待ち受ける（HTTP のデフォルトポート）      |
| 4   | `location /`                  | ルートパス（`/`）以下のすべてのリクエストに適用                          |
| 5   | `root /var/www;`              | `/var/www/` ディレクトリ配下のファイルを返す                             |
| 6   | `index index.html index.htm;` | ファイル名が指定されていない場合、`index.html` または `index.htm` を返す |

**動作例**:

リクエスト URL: `http://example.com/`

- ポート 80 へのリクエスト → `listen 80` に該当
- パス `/` → `location /` に該当
- 返されるファイル: `/var/www/index.html`

これにより、先ほど作成した `index.html` がブラウザに返されます。

#### 3-3. ファイルの保存

`Ctrl + S`（Windows）または `Cmd + S`（Mac）で保存します。

---

### 手順 4: Dockerfile の作成

#### 4-1. Dockerfile の作成

1. `ecs-blue-green-deploy`（ルート）ディレクトリを右クリック
2. 「**新しいファイル**」を選択
3. ファイル名に「**Dockerfile**」と入力して Enter

> **注意**:
>
> - ファイル名は正確に「**Dockerfile**」（拡張子なし）
> - 大文字小文字も正確に入力してください

#### 4-2. Dockerfile の記述

`Dockerfile` に以下の内容を入力します：

```dockerfile
FROM nginx:1.25.3

COPY /html /var/www
COPY nginx.conf /etc/nginx/conf.d/default.conf
```

**各行の説明**:

| 行  | コマンド                                         | 説明                                                              |
| --- | ------------------------------------------------ | ----------------------------------------------------------------- |
| 1   | `FROM nginx:1.25.3`                              | ベースイメージとして NGINX v1.25.3 を使用                         |
| 3   | `COPY /html /var/www`                            | ローカルの `html` ディレクトリをコンテナ内の `/var/www` にコピー  |
| 4   | `COPY nginx.conf /etc/nginx/conf.d/default.conf` | カスタム NGINX 設定ファイルをコンテナ内のデフォルト設定として配置 |

**なぜ `/var/www` にコピーするのか**:

- `nginx.conf` で `root /var/www;` と設定したため
- NGINX がこのディレクトリ配下のファイルを返すように設定されている

**なぜ `/etc/nginx/conf.d/default.conf` に配置するのか**:

- NGINX は `/etc/nginx/conf.d/` ディレクトリ内の `.conf` ファイルを自動的に読み込む
- `default.conf` として配置することで、デフォルト設定を上書きする

#### 4-3. ファイルの保存

`Ctrl + S`で保存します。

---

### 手順 5: ディレクトリ構造の確認

最終的なディレクトリ構造は以下のようになります：

```
ecs/blue-green-deploy/
├── Dockerfile
├── nginx.conf
└── html/
    └── index.html
```

VS Code の左側エクスプローラーで、この構造になっていることを確認してください。

---

### 手順 6: Docker イメージのビルド

#### 6-1. ターミナルで作業ディレクトリに移動

VS Code 内でターミナルを開きます：

1. VS Code のメニューから「**ターミナル**」→「**新しいターミナル**」を選択
2. 自動的に `ecs/blue-green-deploy` ディレクトリがカレントディレクトリになります

または、既存のターミナルで移動：

**Windows（PowerShell）**:

```powershell
cd $HOME\Desktop\ecs\blue-green-deploy
```

**Mac/Linux**:

```bash
cd ~/Desktop/ecs/blue-green-deploy
```

#### 6-2. ファイルの存在確認

```bash
ls
```

`Dockerfile`、`nginx.conf`、`html` ディレクトリが表示されることを確認します。

#### 6-3. Docker イメージのビルド

以下のコマンドで Docker イメージをビルドします：

```bash
docker image build .
```

**コマンドの説明**:

- `docker image build`: Docker イメージをビルドするコマンド
- `.`: カレントディレクトリ（`.`）内の `Dockerfile` を使用

**実行結果**:

成功すると、以下のような出力が表示されます：

```
[+] Building 2.3s (8/8) FINISHED
...
=> => writing image sha256:abc123def456...
```

#### 6-4. イメージ ID のコピー

出力の最後に表示される `sha256:` の後の文字列（イメージ ID）をコピーします。

例: `abc123def456789...`（実際には長い文字列）

---

### 手順 7: ローカルでの動作確認

#### 7-1. コンテナの起動

コピーしたイメージ ID を使用して、コンテナを起動します：

```bash
docker container run -p 8080:80 <イメージID>
```

**コマンドの説明**:

- `docker container run`: コンテナを起動
- `-p 8080:80`: ポートマッピング（ローカルの 8080 番ポート ↔ コンテナの 80 番ポート）
- `<イメージID>`: 先ほどコピーしたイメージ ID

**実行例**:

```bash
docker container run -p 8080:80 abc123def456789
```

**実行結果**:

NGINX が起動すると、以下のようなログが表示されます：

```
/docker-entrypoint.sh: Configuration complete; ready for start up
...
start worker process 31
```

> **注意**: このターミナルはコンテナを起動し続けるため、閉じないでください。

#### 7-2. ブラウザでアクセス

新しいブラウザタブを開き、以下の URL にアクセスします：

```
http://localhost:8080
```

#### 7-3. 動作確認

ブラウザに「**Hello World**」と表示されれば OK です。

これで、ローカル環境でカスタムコンテナイメージが正しく動作することが確認できました。

#### 7-4. コンテナの停止

確認が完了したら、ターミナルで `Ctrl + C` を押してコンテナを停止します。

---

### 完了確認

以下が確認できれば、カスタムアプリケーションの作成は成功です:

- [x] `ecs-blue-green-deploy` ディレクトリが作成された
- [x] `html/index.html` ファイルが作成された
- [x] `nginx.conf` ファイルが作成された
- [x] `Dockerfile` が作成された
- [x] Docker イメージのビルドが成功した
- [x] ローカルでコンテナが起動した
- [x] `http://localhost:8080` で「Hello World」が表示された

---

次のステップでは、AWS CLI をインストールし、IAM ユーザーを作成して、ECR へのアクセス権限を設定します。

---

## AWS CLI のインストールと IAM ユーザー設定

ECR リポジトリに Docker イメージをプッシュするため、AWS CLI をインストールし、ECR へのアクセス権限を持つ IAM ユーザーを作成します。

---

### 前提条件と概要

#### 実施する内容

これまでは AWS リソースの操作をブラウザのマネジメントコンソール（UI）から行ってきましたが、今回はコマンドラインから AWS を操作するツール「**AWS CLI**」を使用します。

#### 必要な設定

1. **AWS CLI のインストール** - ローカルマシンに CLI ツールをインストール
2. **IAM ユーザーの作成** - ECR 操作用の専用ユーザーを作成
3. **アクセスキーの発行** - ユーザーの認証情報を取得
4. **CLI の設定** - ローカルマシンにアクセスキーを設定

#### 権限とセキュリティ

**現在の状態**:

```
ローカルPC → AWS CLIインストール済み → ECRアクセス権限なし ❌
```

**設定後の状態**:

```
ローカルPC → AWS CLI → IAMユーザー（ECR権限あり）→ ECRリポジトリ ✅
```

プライベートリポジトリのため、適切な権限を持つ IAM ユーザーの認証情報が必要です。

> **既に AWS CLI 環境が整っている方**: この手順をスキップして、次の「ECR へのイメージプッシュ」に進んでください。

---

### 手順 1: AWS CLI のインストール

#### 1-1. AWS CLI 公式ドキュメントへのアクセス

1. ブラウザで「**AWS CLI インストール**」と検索
2. 「**AWS CLI の最新バージョンを使用してインストールまたは更新を行う**」をクリック

または、以下の URL に直接アクセス:

```
https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html
```

#### 1-2. OS に応じたインストール手順の選択

ページ内で、使用している OS を選択します：

- **Linux**
- **macOS**
- **Windows**

#### 1-3. インストール方法の選択（macOS/Linux の場合）

macOS/Linux では、以下のインストール方法から選択できます：

| 方法                                           | 説明                             | 推奨       |
| ---------------------------------------------- | -------------------------------- | ---------- |
| GUI インストーラー                             | グラフィカルインストーラーを使用 | 初心者向け |
| コマンドラインインストーラー（全ユーザー）     | すべてのユーザーで使用可能       | ✅ 推奨    |
| コマンドラインインストーラー（現在のユーザー） | 現在のユーザーのみ               | 個人利用   |

今回は「**コマンドラインインストーラー - すべてのユーザー**」を使用します。

> **全ユーザー vs 現在のユーザー**: macOS/Linux は複数ユーザーをサポートしています。「全ユーザー」は PC 上のすべてのユーザーが AWS CLI を使用できます。

---

### 手順 2: AWS CLI のインストール実行

#### 2-1. インストール前の確認

ターミナルを開き、AWS CLI がインストールされていないことを確認します：

```bash
aws --version
```

**未インストールの場合**:

- macOS/Linux: `command not found: aws`
- Windows: `'aws' は、内部コマンドまたは外部コマンド...として認識されていません。`

#### 2-2. インストールコマンドの実行

**macOS（コマンドライン - 全ユーザー）**:

```bash
# 1. インストーラーをダウンロード
curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"

# 2. インストーラーを実行（管理者権限が必要）
sudo installer -pkg AWSCLIV2.pkg -target /

# パスワードを求められたら、macOSのログインパスワードを入力

# 3. ダウンロードしたファイルを削除
rm AWSCLIV2.pkg
```

**Windows**:

1. AWS CLI インストーラー（MSI）をダウンロード
2. ダウンロードした MSI ファイルを実行
3. インストールウィザードの指示に従う

**Linux**:

```bash
# 1. インストーラーをダウンロードして解凍
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip

# 2. インストーラーを実行
sudo ./aws/install

# 3. ダウンロードしたファイルを削除
rm -rf awscliv2.zip aws
```

#### 2-3. インストールの確認

```bash
aws --version
```

**成功例**:

```
aws-cli/2.15.8 Python/3.11.6 Darwin/23.0.0 exe/x86_64
```

バージョン番号が表示されればインストール成功です。

> **注意**: バージョン番号はインストール時期により異なります。

#### 2-4. インストール場所の確認（オプション）

**macOS/Linux**:

```bash
which aws
```

**出力例**:

```
/usr/local/bin/aws
```

このパスは、システムの PATH 環境変数に含まれているため、どのディレクトリからでも `aws` コマンドを実行できます。

---

### 手順 3: IAM ユーザーの作成

#### 3-1. IAM コンソールへの移動

1. AWS マネジメントコンソールの上部検索欄に「**IAM**」と入力
2. 「**IAM**」をクリック

#### 3-2. ユーザー作成画面へ

1. 左側メニューから「**ユーザー**」をクリック
2. 「**ユーザーを作成**」ボタンをクリック

#### 3-3. ユーザー詳細の設定

| 項目                                                 | 設定値           |
| ---------------------------------------------------- | ---------------- |
| ユーザー名                                           | `local-user`     |
| マネジメントコンソールへのユーザーアクセスを提供する | **チェックなし** |

> **説明**:
>
> - このユーザーは AWS CLI でのみ使用するため、マネジメントコンソール（UI）へのアクセスは不要です
> - チェックを外すことで、よりセキュアな設定になります

「**次へ**」をクリックします。

#### 3-4. 許可の設定

「**許可のオプション**」画面では、**何も選択せずに「次へ」**をクリックします。

> **理由**: 権限は後でインラインポリシーとして個別に設定します。

#### 3-5. 確認と作成

1. 設定内容を確認
2. 「**ユーザーを作成**」ボタンをクリック
3. 作成完了を確認

---

### 手順 4: ECR アクセス用のポリシー作成

#### 4-1. ユーザー詳細画面へ移動

1. ユーザー一覧から「**local-user**」をクリック
2. ユーザー詳細画面が開く

#### 4-2. インラインポリシー作成画面へ

1. 「**許可を追加**」をクリック
2. ドロップダウンから「**インラインポリシーを作成**」を選択

#### 4-3. ポリシーエディターの選択

1. ポリシーエディターで「**JSON**」タブを選択

#### 4-4. ECR アクセスポリシーの設定

既存の JSON を削除し、以下のポリシーを入力します：

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "Statement1",
      "Effect": "Allow",
      "Action": [
        "ecr:GetDownloadUrlForLayer",
        "ecr:BatchGetImage",
        "ecr:BatchCheckLayerAvailability",
        "ecr:PutImage",
        "ecr:InitiateLayerUpload",
        "ecr:UploadLayerPart",
        "ecr:CompleteLayerUpload",
        "ecr:GetAuthorizationToken"
      ],
      "Resource": "*"
    }
  ]
}
```

**ポリシーの解説**:

| 項目            | 説明                                                   |
| --------------- | ------------------------------------------------------ |
| `Effect: Allow` | 以下のアクションを許可する                             |
| `Action`        | ECR に対して実行できる操作のリスト（8 つのアクション） |
| `Resource: *`   | すべての ECR リポジトリに対して適用                    |

**含まれるアクション**:

| アクション                        | 説明                                    |
| --------------------------------- | --------------------------------------- |
| `ecr:GetDownloadUrlForLayer`      | イメージレイヤーのダウンロード URL 取得 |
| `ecr:BatchGetImage`               | イメージの一括取得                      |
| `ecr:BatchCheckLayerAvailability` | レイヤーの存在確認                      |
| `ecr:PutImage`                    | イメージのプッシュ（アップロード）      |
| `ecr:InitiateLayerUpload`         | レイヤーアップロードの開始              |
| `ecr:UploadLayerPart`             | レイヤーの部分アップロード              |
| `ecr:CompleteLayerUpload`         | レイヤーアップロードの完了              |
| `ecr:GetAuthorizationToken`       | ECR 認証トークンの取得                  |

> **セキュリティ補足**:
>
> - `Resource: "*"` はすべてのリポジトリへのアクセスを許可します
> - 特定のリポジトリのみに制限する場合は、リポジトリ ARN を指定できます
> - 今回は学習用途のため、`*` を使用しています

#### 4-5. ビジュアルエディタでの確認（オプション）

「**ビジュアル**」タブをクリックすると、8 つのアクションが許可されていることを視覚的に確認できます。

#### 4-6. ポリシーの作成

1. 「**次へ**」をクリック
2. ポリシー名を入力：`ecr-push-pull-image`
3. 「**ポリシーの作成**」をクリック

#### 4-7. ポリシーの確認

ユーザー詳細画面に戻り、「**許可ポリシー**」セクションに `ecr-push-pull-image` が表示されていることを確認します。

---

### 手順 5: アクセスキーの作成

#### 5-1. セキュリティ認証情報タブへ移動

1. `local-user` の詳細画面で「**セキュリティ認証情報**」タブをクリック

#### 5-2. アクセスキー作成画面へ

1. 「**アクセスキー**」セクションまでスクロール
2. 「**アクセスキーを作成**」ボタンをクリック

#### 5-3. ユースケースの選択

1. 「**コマンドラインインターフェイス (CLI)**」を選択

#### 5-4. 推奨される代替案の確認

以下のような推奨メッセージが表示されますが、今回は無視します：

- CloudShell の使用
- IAM Identity Center の使用

> **注意**: 本番環境では、これらの代替案の使用を推奨しますが、学習目的のため、今回はアクセスキーを使用します。

1. 「**上記のレコメンデーションを理解し、アクセスキーを作成します。**」にチェック
2. 「**次へ**」をクリック

#### 5-5. 説明タグの設定（オプション）

タグは任意のため、そのまま「**アクセスキーを作成**」をクリックします。

#### 5-6. アクセスキーの保存

**重要**: この画面で表示される情報は、**この時しか確認できません**。

1. **アクセスキー**をコピーしてメモ
2. **シークレットアクセスキー**の「**表示**」をクリック
3. **シークレットアクセスキー**をコピーしてメモ

または

1. 「**.csv ファイルをダウンロード**」をクリックして保存

**セキュリティ警告** ⚠️:

この 2 つの情報は、AWS アカウントへのアクセス権限を持つ機密情報です：

- ❌ 他人と共有しない
- ❌ GitHub などの公開リポジトリにコミットしない
- ❌ Web サイトやドキュメントに公開しない
- ✅ ローカルマシンに安全に保管
- ✅ 使用後は無効化または削除を検討

> **注意**: 今回作成したユーザーは ECR 操作のみに権限が制限されているため、被害は限定的ですが、それでも流出は避けてください。

#### 5-7. 完了

「**完了**」をクリックしてウィンドウを閉じます。

---

### 手順 6: AWS CLI の設定

#### 6-1. AWS CLI の設定コマンド実行

ターミナルで以下のコマンドを実行します：

```bash
aws configure
```

#### 6-2. アクセスキーの入力

以下の項目を順番に入力します：

```
AWS Access Key ID [None]: <コピーしたアクセスキーID>
AWS Secret Access Key [None]: <コピーしたシークレットアクセスキー>
Default region name [None]: us-west-2
Default output format [None]: json
```

**各項目の説明**:

| 項目                  | 入力値                   | 説明                               |
| --------------------- | ------------------------ | ---------------------------------- |
| AWS Access Key ID     | アクセスキー ID          | 先ほど作成したアクセスキー         |
| AWS Secret Access Key | シークレットアクセスキー | 先ほど作成したシークレットキー     |
| Default region name   | `us-west-2`              | 使用しているリージョン（オレゴン） |
| Default output format | `json`                   | CLI の出力形式                     |

> **リージョンの確認**: マネジメントコンソール右上で確認できます。「US West (Oregon)」= `us-west-2`

#### 6-3. 設定ファイルの確認

設定した情報は、以下のファイルに保存されます：

**Windows**:

```
C:\Users\<ユーザー名>\.aws\config
C:\Users\<ユーザー名>\.aws\credentials
```

**macOS/Linux**:

```
~/.aws/config
~/.aws/credentials
```

**設定内容の確認（オプション）**:

**macOS/Linux**:

```bash
cd ~/.aws
ls
cat config
cat credentials
```

**Windows（PowerShell）**:

```powershell
cd $HOME\.aws
Get-ChildItem
Get-Content config
Get-Content credentials
```

**config ファイルの内容**:

```ini
[default]
region = us-west-2
output = json
```

**credentials ファイルの内容**:

```ini
[default]
aws_access_key_id = AKIAIOSFODNN7EXAMPLE
aws_secret_access_key = wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
```

> **[default] の意味**: プロファイル名です。AWS CLI は複数のプロファイルを持つことができ、`[default]` は何も指定しない場合に使用されます。

## ECR への Docker イメージのプッシュ

AWS CLI と IAM ユーザーの設定が完了したので、作成した Docker イメージを ECR リポジトリにプッシュ（アップロード）します。

---

### 概要

ECR リポジトリには、イメージをプッシュするための手順が AWS CLI コマンドとして用意されています。これらのコマンドをコピーして実行するだけで、簡単にプッシュできます。

**実施する内容**:

1. ECR にログイン（認証）
2. Docker イメージのビルド（タグ付き）
3. イメージの再タグ付け
4. ECR へのプッシュ
5. 動作確認

---

### 手順 1: プッシュコマンドの表示

#### 1-1. ECR リポジトリページへ移動

1. AWS マネジメントコンソールの上部検索欄に「**ECR**」と入力
2. 「**機能**」セクションの「**リポジトリ**」をクリック
3. 「**プライベート**」タブを選択
4. `my-app-frontend` リポジトリをクリック

#### 1-2. プッシュコマンドの表示

1. リポジトリ詳細画面の右上にある「**プッシュコマンドの表示**」ボタンをクリック
2. ポップアップウィンドウが開き、4 つのステップが表示される

#### 1-3. OS の選択

ポップアップ上部で、使用している OS のタブを選択します：

- **macOS / Linux**
- **Windows**

> **注意**: 以降の手順は、選択した OS に応じたコマンドを使用してください。

---

### 手順 2: 作業ディレクトリへの移動

プッシュコマンドを実行する前に、Dockerfile があるディレクトリに移動します。

#### 2-1. ターミナルを開く

VS Code 内のターミナル、または別のターミナルウィンドウを開きます。

#### 2-2. ディレクトリへ移動

**Windows（PowerShell）**:

```powershell
cd $HOME\Desktop\ecs-blue-green-deploy
```

**Mac/Linux**:

```bash
cd ~/Desktop/ecs-blue-green-deploy
```

#### 2-3. ディレクトリの確認

```bash
ls
```

`Dockerfile`、`nginx.conf`、`html` ディレクトリが表示されることを確認します。

---

### 手順 3: ECR へのログイン（認証）

#### 3-1. ログインコマンドの実行

「**プッシュコマンドの表示**」ウィンドウの **ステップ 1** に表示されているコマンドをコピーして実行します。

**コマンド例（macOS/Linux）**:

```bash
aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 123456789012.dkr.ecr.us-west-2.amazonaws.com
```

**コマンド例（Windows - PowerShell）**:

```powershell
(Get-ECRLoginCommand -Region us-west-2).Password | docker login --username AWS --password-stdin 123456789012.dkr.ecr.us-west-2.amazonaws.com
```

> **重要**: 上記は例です。必ず「プッシュコマンドの表示」に表示されている実際のコマンドをコピーして実行してください。

**成功時の出力**:

```
Login Succeeded
```

このメッセージが表示されれば、ECR への認証が成功しています。

**コマンドの説明**:

- `aws ecr get-login-password`: ECR ログイン用のパスワードを取得
- `docker login`: Docker レジストリにログイン
- `--username AWS`: ECR のデフォルトユーザー名
- `--password-stdin`: パスワードを標準入力から受け取る

---

### 手順 4: Docker イメージのビルド（タグ付き）

#### 4-1. ビルドコマンドの実行

「**プッシュコマンドの表示**」ウィンドウの **ステップ 2** に表示されているコマンドをコピーして実行します。

**コマンド例**:

```bash
docker build -t my-app-frontend .
```

**実行結果**:

ビルドプロセスが開始され、以下のような出力が表示されます：

```
[+] Building 2.3s (8/8) FINISHED
...
=> => writing image sha256:abc123def456...
=> => naming to docker.io/library/my-app-frontend
```

**コマンドの説明**:

- `docker build`: Docker イメージをビルド
- `-t my-app-frontend`: イメージに `my-app-frontend` というタグ（名前）を付ける
- `.`: カレントディレクトリの Dockerfile を使用

---

### 手順 5: イメージの再タグ付け

ECR にプッシュするため、イメージに ECR リポジトリの URI を含むタグを付けます。

#### 5-1. タグ付けコマンドの実行

「**プッシュコマンドの表示**」ウィンドウの **ステップ 3** に表示されているコマンドをコピーして実行します。

**コマンド例**:

```bash
docker tag my-app-frontend:latest 123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest
```

> **重要**: 上記は例です。必ず「プッシュコマンドの表示」に表示されている実際のコマンドを使用してください。

**コマンドの説明**:

- `docker tag`: 既存のイメージに新しいタグを付ける
- `my-app-frontend:latest`: 元のイメージ名とタグ
- `123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest`: ECR リポジトリのフルパス

このコマンドは出力を返しませんが、正常に実行されれば成功です。

---

### 手順 6: ECR へのプッシュ

#### 6-1. プッシュコマンドの実行

「**プッシュコマンドの表示**」ウィンドウの **ステップ 4** に表示されているコマンドをコピーして実行します。

**コマンド例**:

```bash
docker push 123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest
```

> **重要**: 上記は例です。必ず「プッシュコマンドの表示」に表示されている実際のコマンドを使用してください。

**実行結果**:

プッシュプロセスが開始され、以下のような出力が表示されます：

```
The push refers to repository [123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend]
abc123def456: Pushed
def456ghi789: Pushed
...
latest: digest: sha256:abc123... size: 1234
```

**プッシュ完了の確認**:

最後に `latest: digest: sha256:...` という行が表示されれば、プッシュ成功です。

---

### 手順 7: ECR コンソールでの確認

#### 7-1. イメージ一覧の更新

1. ECR リポジトリの詳細画面に戻る
2. 画面右上の「**更新**」ボタン（🔄 アイコン）をクリック

#### 7-2. プッシュされたイメージの確認

イメージ一覧に、以下の情報を持つイメージが表示されます：

| 項目                 | 内容                         |
| -------------------- | ---------------------------- |
| イメージタグ         | `latest`                     |
| イメージのサイズ     | 約 80-100 MB（NGINX ベース） |
| プッシュ日時         | 現在の日時                   |
| イメージダイジェスト | `sha256:...`                 |

これが表示されていれば、ECR へのプッシュが正常に完了しています。

---

### 手順 8: プッシュしたイメージの動作確認（オプション）

ECR からイメージをプル（ダウンロード）して、正しく動作するか確認します。

#### 8-1. 既存コンテナの削除

以前の動作確認で起動したコンテナがあれば、削除します。

**コンテナの確認**:

```bash
docker container ls -a
```

**コンテナの強制削除**:

```bash
docker container rm -f <コンテナ名またはID>
```

例:

```bash
docker container rm -f keen_darwin
```

#### 8-2. ECR イメージ URI の取得

ECR リポジトリ詳細画面で、プッシュしたイメージの URI をコピーします：

1. イメージタグ `latest` の行を選択
2. 「**URI をコピー**」ボタンをクリック

コピーされる URI 例:

```
123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest
```

#### 8-3. ECR からイメージをプルして起動

コピーした URI を使用して、コンテナを起動します：

```bash
docker container run -p 8080:80 123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest
```

**コマンドの説明**:

- `-p 8080:80`: ローカルの 8080 番ポートをコンテナの 80 番ポートにマッピング
- ECR のフル URI を指定することで、自動的にイメージがプルされて起動する

**実行結果**:

初回実行時は、イメージのダウンロードが行われます：

```
Unable to find image '123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest' locally
latest: Pulling from my-app-frontend
...
Status: Downloaded newer image for 123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest
...
start worker process 31
```

#### 8-4. ブラウザでアクセス

ブラウザで以下の URL にアクセスします：

```
http://localhost:8080
```

#### 8-5. 表示確認

「**Hello World**」と表示されることを確認します。

> **キャッシュのクリア**: ブラウザのキャッシュが残っている場合は、`Shift + 更新ボタン`（または `Ctrl + Shift + R` / `Cmd + Shift + R`）で強制リロードしてください。

#### 8-6. コンテナの停止

確認が完了したら、ターミナルで `Ctrl + C` を押してコンテナを停止します。

## ECS タスク定義の更新とブルー/グリーンデプロイメントの実行

ECR にカスタムイメージをプッシュしたので、ECS タスク定義を更新してブルー/グリーンデプロイメントを実行します。

---

### 概要と現在の状態

#### 現在の環境

```
ECSクラスター
└── タスク（実行中）
    └── NGINXコンテナ
        └── イメージ: AWS公開NGINX（"Welcome to nginx!"）
```

**アクセスフロー**:

```
ブラウザ → ロードバランサー（ALB） → ターゲットグループ2 → ECSタスク → "Welcome to nginx!"
```

#### ブルー/グリーン環境の理解

| 環境                  | 説明                         | 今回のケース                                     |
| --------------------- | ---------------------------- | ------------------------------------------------ |
| **ブルー（Blue）**    | 現在稼働中の古いバージョン   | AWS 公開 NGINX イメージ<br>「Welcome to nginx!」 |
| **グリーン（Green）** | 新しくデプロイするバージョン | カスタム NGINX イメージ<br>「Hello World」       |

#### 実施する内容

1. **現在の状態確認** - ロードバランサー経由でアクセス確認
2. **タスク定義の更新** - カスタムイメージを使用する新リビジョン作成
3. **ブルー/グリーンデプロイのトリガー** - サービス更新でデプロイ開始

> **重要**: タスク定義は上書きできません。新しいリビジョン（バージョン番号）を作成して管理します。

---

### 手順 1: 現在の状態確認

#### 1-1. ロードバランサーの DNS 名取得

1. AWS マネジメントコンソールの上部検索欄に「**EC2**」と入力
2. 「**EC2**」をクリック
3. 左側メニューから「**ロードバランサー**」をクリック
4. `my-app-alb` を選択

#### 1-2. DNS 名のコピー

DNS 名をコピー

DNS 名の例:

```
my-app-alb-1234567890.us-west-2.elb.amazonaws.com
```

#### 1-3. ブラウザでアクセス確認

新しいブラウザタブを開き、以下の形式でアクセスします：

```
http://<DNS名>
```

例:

```
http://my-app-alb-1234567890.us-west-2.elb.amazonaws.com
```

#### 1-4. 現在の表示確認

「**Welcome to nginx!**」ページが表示されることを確認します。

これが現在のブルー環境（旧バージョン）です。

---

### 手順 2: ECS タスク定義の更新

#### 2-1. タスク定義ページへ移動

1. AWS マネジメントコンソールの上部検索欄に「**ECS**」と入力
2. 「**Elastic Container Service**」をクリック
3. 左側メニューから「**タスク定義**」をクリック

#### 2-2. 既存タスク定義の選択

1. タスク定義ファミリー一覧から「**my-app-frontend**」をクリック
2. タスク定義のリビジョン一覧が表示される
3. 「**my-app-frontend:1**」（現在のリビジョン）が表示されていることを確認

#### 2-3. 新しいリビジョンの作成開始

1. 「**my-app-frontend:1**」を選択（チェックボックスにチェック）
2. 画面右上の「**新しいリビジョンの作成**」ボタンをクリック

> **説明**: タスク定義は編集できないため、新しいリビジョンとして作成します。これにより、バージョン管理とロールバックが可能になります。

#### 2-4. コンテナ設定の編集

「**新しいリビジョンの作成**」画面が開きます。

1. 「**コンテナ - 1**」セクションまでスクロール
2. コンテナ名の右側にある「**編集**」アイコン（鉛筆マーク）をクリック

> **注意**: ほとんどの設定は変更不要です。変更するのは **イメージ URI のみ** です。

#### 2-5. ECR イメージ URI の取得

**新しいタブで以下を実行**（タスク定義編集画面は残しておく）:

1. AWS マネジメントコンソールで「**ECR**」と検索
2. 「**リポジトリ**」をクリック
3. 「**プライベート**」タブを選択
4. `my-app-frontend` リポジトリをクリック
5. イメージタグ `latest` の行で「**URI をコピー**」をクリック

コピーされる URI 例:

```
123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest
```

#### 2-6. イメージ URI の置き換え

タスク定義編集画面に戻ります：

1. 「**イメージ URI**」フィールドの現在の値を確認
   - 現在: `public.ecr.aws/nginx/nginx:1.25.3-alpine-slim`（AWS 公開 NGINX）
2. この値を削除
3. コピーした ECR のイメージ URI を貼り付け
   - 新しい値: `123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest`

**変更前**:

```
public.ecr.aws/nginx/nginx:1.25.3-alpine-slim
```

**変更後**:

```
123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app-frontend:latest
```

> **重要**: URI 全体（アカウント ID、リージョン、リポジトリ名、タグ）が正しいことを確認してください。

#### 2-7. その他の設定確認

他の設定は変更不要です。以下が維持されていることを確認：

| 項目             | 値                                      |
| ---------------- | --------------------------------------- |
| コンテナ名       | `my-app-frontend-container`             |
| ポートマッピング | コンテナポート: `80`、プロトコル: `TCP` |
| CPU              | 256                                     |
| メモリ           | 512                                     |

#### 2-8. コンテナ設定の保存

1. 画面下部の「**更新**」ボタンをクリック
2. コンテナ編集ウィンドウが閉じる

#### 2-9. タスク定義リビジョンの作成

1. 「**新しいリビジョンの作成**」画面の最下部までスクロール
2. 「**作成**」ボタンをクリック
3. 「**正常に作成されました**」というメッセージが表示される

#### 2-10. 新しいリビジョンの確認

1. タスク定義の詳細画面が開く
2. 画面上部のリビジョン番号を確認
   - 「**my-app-frontend:2**」と表示される
3. 「**コンテナ - 1**」セクションで、イメージ URI が更新されていることを確認

#### 2-11. リビジョン一覧の確認

1. 画面上部の「**my-app-frontend**」（ファミリー名）をクリック
2. リビジョン一覧に戻る
3. 以下の 2 つのリビジョンが表示されることを確認：
   - `my-app-frontend:1`（旧バージョン - AWS 公開 NGINX）
   - `my-app-frontend:2`（新バージョン - カスタム NGINX）

---

## ステップ 9: ブルー/グリーンデプロイの実行

### 概要

新しく作成したタスク定義リビジョン 2 を使用して、ECS サービスを更新し、ブルー/グリーンデプロイをトリガーします。デプロイは以下の流れで実行されます：

1. サービス更新でデプロイをトリガー
2. 新しいタスク（グリーン）が起動
3. テストリスナー（ポート 9000）経由で新バージョンを確認
4. ライフサイクルフックが実行され、POST_TEST_TRAFFIC_SHIFT ステージで一時停止
5. 開発者が動作確認を実施

---

### 手順 1: デプロイのトリガー（UI 版）

#### 1-1. サービス更新画面への移動

1. AWS マネジメントコンソールで「**ECS**」を開く
2. 左側メニューから「**クラスター**」をクリック
3. クラスター一覧から「**my-app-cluster**」をクリック
4. 「**サービス**」タブをクリック
5. 「**my-app-frontend-service**」のリンクをクリック
6. 画面右上の「**サービスの更新**」ボタンをクリック

#### 1-2. タスク定義の変更

1. 「**デプロイ設定**」セクションを見つける
2. 「**ファミリー**」のドロップダウンで「**my-app-frontend**」が選択されていることを確認
3. 「**リビジョン**」のドロップダウンをクリック
4. 「**2 (最新)**」を選択
5. 「**新しいデプロイの強制**」にチェックを入れる

> **説明**：「新しいデプロイの強制」により、タスク定義の変更がなくても強制的に新しいデプロイが実行されます。

#### 1-3. サービスの更新実行

1. 画面最下部の「**更新**」ボタンをクリック
2. 「**サービスが正常に更新されました**」というメッセージが表示される
3. デプロイが開始される

> **注意**：UI は頻繁に変更される可能性がありますが、基本的な手順は同様です。

---

### 手順 2: デプロイのトリガー（CLI 版）

#### 2-1. CloudShell の起動

1. AWS マネジメントコンソール右上の CloudShell アイコン（>\_）をクリック
2. CloudShell ターミナルが起動するまで待つ

#### 2-2. update-service コマンドのオプション確認

まず、`update-service`コマンドのヘルプを確認します：

```bash
aws ecs update-service help
```

#### 2-3. ヘルプの操作方法

- **下にスクロール**：`j`キーを押す
- **上にスクロール**：`k`キーを押す
- **検索**：`/`を押して検索キーワードを入力して Enter
  - 例：`/task-definition`と入力して Enter
- **次の検索結果**：`n`キーを押す
- **ヘルプを終了**：`q`キーを押す

#### 2-4. task-definition オプションの確認

1. ヘルプ画面で`/task-definition`と入力して検索
2. `n`キーで該当箇所を探す
3. 以下の説明を確認：

```
--task-definition (string)
  The family and revision (family:revision) or full ARN of the task
  definition to run in your service.
```

> **説明**：タスク定義は`family:revision`形式で指定します（例：`my-app-frontend:2`）。

#### 2-5. force-new-deployment オプションの確認

1. ヘルプ画面で`/force-new-deployment`と入力して検索
2. 以下のオプションを確認：

```
--force-new-deployment | --no-force-new-deployment (boolean)
```

> **説明**：このオプションにより、強制的に新しいデプロイを実行します。

#### 2-6. サービス更新コマンドの実行

ヘルプを終了（`q`キー）して、以下のコマンドを実行します：

```bash
aws ecs update-service \
  --cluster my-app-cluster \
  --service my-app-frontend-service \
  --task-definition my-app-frontend:2 \
  --force-new-deployment
```

**コマンド説明**：

- `--cluster`：クラスター名を指定
- `--service`：サービス名を指定
- `--task-definition`：使用するタスク定義（ファミリー:リビジョン）
- `--force-new-deployment`：新しいデプロイを強制実行

#### 2-7. コマンド実行結果の確認

コマンドが成功すると、JSON 形式でサービス情報が返されます：

```json
{
    "service": {
        "serviceArn": "arn:aws:ecs:us-west-2:xxxxxxxxxxxx:service/my-app-cluster/my-app-frontend-service",
        "serviceName": "my-app-frontend-service",
        "clusterArn": "arn:aws:ecs:us-west-2:xxxxxxxxxxxx:cluster/my-app-cluster",
        "taskDefinition": "arn:aws:ecs:us-west-2:xxxxxxxxxxxx:task-definition/my-app-frontend:2",
        ...
    }
}
```

> **確認ポイント**：`taskDefinition`に`my-app-frontend:2`が指定されていることを確認します。

---

### 手順 3: デプロイ状態の確認

#### 3-1. サービス詳細画面での確認

1. AWS マネジメントコンソールで ECS サービス詳細画面を開く
   - **ECS** → **クラスター** → **my-app-cluster** → **サービス** → **my-app-frontend-service**
2. 「**デプロイとイベント**」タブをクリック

#### 3-2. デプロイステータスの確認

「**デプロイ**」セクションで以下を確認：

| 項目               | 確認内容                                                                                 |
| ------------------ | ---------------------------------------------------------------------------------------- |
| ステータス         | **進行中**と表示される                                                                   |
| サービスリビジョン | 2 つのリビジョンが表示される：<br>- リビジョン 1（ブルー）<br>- リビジョン 2（グリーン） |
| 現在のデプロイ段階 | **テストトラフィック移行後**と表示される                                                 |

> **説明**：「テストトラフィック移行後」は英語で`POST_TEST_TRAFFIC_SHIFT`ステージに該当します。

#### 3-3. デプロイ詳細の確認

「**サービスデプロイ**」セクションを展開：

1. 進行中のデプロイが 1 つ表示される
2. 作成日時が直近（数分以内）であることを確認
3. デプロイ ID が表示される

#### 3-4. イベントログの確認

画面を下にスクロールして「**イベント**」セクションを確認：

以下のようなイベントが表示されます：

```
- タスクを起動しました：task/xxxxxxxx
- ターゲットグループに変更がありました
- デプロイが開始されました
```

> **説明**：イベントログでデプロイの進行状況を時系列で確認できます。

---

### 手順 4: ロードバランサー状態の詳細確認

ブルー/グリーンデプロイの現在の状態を詳しく確認するため、ロードバランサーのリスナー設定を確認します。

#### 4-1. ロードバランサーページへの移動

1. ECS サービス詳細画面で「**正常性とメトリクス**」タブをクリック
2. 「**ロードバランサーの正常性**」セクションを見つける
3. ロードバランサー名「**my-app-alb**」のリンクをクリック
4. ロードバランサーの詳細画面が開く

#### 4-2. リスナー設定の確認

1. 「**リスナーとルール**」タブをクリック
2. 2 つのリスナーが表示されることを確認：

**リスナー 1：HTTP ポート 80（本番リスナー）**

| 項目                 | 値                          |
| -------------------- | --------------------------- |
| プロトコル           | HTTP                        |
| ポート               | 80                          |
| デフォルトアクション | **my-app-tg-2**へフォワード |

> **説明**：ポート 80 は一般ユーザー向けの本番リスナーです。現時点では**ブルー環境（旧バージョン）**にルーティングされています。

**リスナー 2：HTTP ポート 9000（テストリスナー）**

| 項目                 | 値                          |
| -------------------- | --------------------------- |
| プロトコル           | HTTP                        |
| ポート               | 9000                        |
| デフォルトアクション | **my-app-tg-1**へフォワード |

> **説明**：ポート 9000 はテストリスナーです。現時点では**グリーン環境（新バージョン）**にルーティングされています。

#### 4-3. 現在の状態の理解

現在のトラフィックフロー：

```
【ブルー環境（旧バージョン）】
ALB:80 → my-app-tg-2 → 旧タスク（NGINX デフォルト）
                          ↓
                    "Welcome to nginx!"

【グリーン環境（新バージョン）】
ALB:9000 → my-app-tg-1 → 新タスク（カスタムNGINX）
                           ↓
                     "Hello World"
```

この状態は、ブルー/グリーンデプロイのライフサイクルにおける**POST_TEST_TRAFFIC_SHIFT**ステージに対応します。

---

### 手順 5: ライフサイクルフックの動作確認

#### 5-1. デプロイ停止の理由

現在、デプロイは**POST_TEST_TRAFFIC_SHIFT**ステージで停止しています。これは以下の理由によるものです：

1. ライフサイクルフック設定でこのステージに Lambda 関数を紐付けた
2. Lambda 関数が常に`{'HookStatus': 'IN_PROGRESS'}`を返す
3. `IN_PROGRESS`が返される限り、デプロイは次のステージに進まない

> **設計意図**：この停止により、開発者は新バージョンを事前に検証できます。一般ユーザーには影響がありません。

#### 5-2. Lambda 関数の実行確認

1. AWS マネジメントコンソールで「**Lambda**」を開く
2. 関数一覧から「**my-app-lifecycle-hooks**」をクリック
3. 「**モニタリング**」タブをクリック

#### 5-3. メトリクスの確認

1. 時間範囲を「**1 時間**」に設定
2. 「**呼び出し**」（Invocations）グラフを確認
3. 直近に複数の実行が記録されていることを確認

**メトリクスの読み方**：

```
グラフの目盛り：1分間隔
表示される値：1分あたり2回の実行

→ 30秒ごとに1回実行されている
```

> **説明**：`IN_PROGRESS`が返されると、ECS は約 30 秒後に再度 Lambda 関数を実行します。この動作が繰り返されています。

#### 5-4. CloudWatch Logs の確認

1. Lambda 関数の「**モニタリング**」タブで「**CloudWatch のログを表示**」ボタンをクリック
2. 「**ログストリーム**」が表示される
3. 最新のログストリーム（一番上）をクリック

#### 5-5. ログ内容の確認

1. 「**ローカルタイムゾーン**」トグルを ON にする
2. ログエントリを確認

**ログの例**：

```json
Event:{
  "ExecutionDetails": {
    "ServiceArn": "arn:aws:ecs:us-west-2:xxxxxxxxxxxx:service/my-app-cluster/my-app-frontend-service",
    "ExecutionId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
    "LifecycleStage": "POST_TEST_TRAFFIC_SHIFT"
  },
  ...
}
```

**確認ポイント**：

| 項目           | 確認内容                                |
| -------------- | --------------------------------------- |
| ServiceArn     | 作成した ECS サービスの ARN             |
| ExecutionId    | 実行ごとに一意の ID                     |
| LifecycleStage | **POST_TEST_TRAFFIC_SHIFT**と表示される |
| ログの頻度     | 約 30 秒ごとに新しいログが追加される    |

> **確認**：Lambda 関数が期待通りに動作し、デプロイを POST_TEST_TRAFFIC_SHIFT ステージで停止させていることが確認できました。

---

### 手順 6: 新バージョン（グリーン環境）の事前確認

デプロイが停止している間に、テストリスナー（ポート 9000）を使用して新バージョンの動作を確認します。

#### 6-1. ロードバランサーの DNS 名取得

1. AWS マネジメントコンソールで「**EC2**」を開く
2. 左側メニューから「**ロードバランサー**」をクリック
3. 「**my-app-alb**」を選択
4. 「**DNS 名**」の値をコピー
   - 例：`my-app-alb-1234567890.us-west-2.elb.amazonaws.com`

#### 6-2. 本番環境（ブルー）の確認

新しいブラウザタブを開いて、以下の URL にアクセス：

```
http://my-app-alb-1234567890.us-west-2.elb.amazonaws.com
```

**表示される内容**：

```
Welcome to nginx!

If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.
```

> **確認**：ポート 80（デフォルト）では、まだ旧バージョン（ブルー環境）が動作しています。これは一般ユーザーが見ている画面と同じです。

#### 6-3. テスト環境（グリーン）の確認

同じブラウザで、URL の末尾にポート番号`:9000`を追加してアクセス：

```
http://my-app-alb-1234567890.us-west-2.elb.amazonaws.com:9000
```

**表示される内容**：

```
Hello World
```

> **確認**：ポート 9000 では、新バージョン（グリーン環境）が動作しています。これは開発者のみがアクセスできる事前確認用の画面です。

#### 6-4. 現在の状態の整理

| アクセス先      | ポート | 環境           | 表示内容          | アクセス可能者 |
| --------------- | ------ | -------------- | ----------------- | -------------- |
| ALB DNS 名      | 80     | ブルー（旧）   | Welcome to nginx! | 一般ユーザー   |
| ALB DNS 名:9000 | 9000   | グリーン（新） | Hello World       | 開発者のみ     |

**デプロイのライフサイクル位置**：

```
[現在地]
  ↓
POST_TEST_TRAFFIC_SHIFT （停止中）
  ↓
BEFORE_PRODUCTION_TRAFFIC_SHIFT
  ↓
PRODUCTION_TRAFFIC_SHIFT
```

この状態で、開発者は新バージョンに問題がないかを十分に検証できます。

---

### まとめ

この手順では以下を実施しました：

1. ✅ ECS サービスを更新し、タスク定義リビジョン 2 を使用するデプロイをトリガー
2. ✅ デプロイが POST_TEST_TRAFFIC_SHIFT ステージで停止していることを確認
3. ✅ ロードバランサーのリスナー設定を確認し、ブルー/グリーン環境の分離を理解
4. ✅ Lambda 関数が 30 秒ごとに実行され、IN_PROGRESS を返していることを確認
5. ✅ テストリスナー（ポート 9000）経由で新バージョン（Hello World）にアクセス成功

**現在の状態**：

- 一般ユーザー（ポート 80）：旧バージョン（Welcome to nginx!）にアクセス
- 開発者（ポート 9000）：新バージョン（Hello World）を事前確認可能
- デプロイ：POST_TEST_TRAFFIC_SHIFT ステージで安全に停止中

---

## ステップ 10: デプロイの継続とブルー/グリーンデプロイの完了

### 概要

現在、デプロイは POST_TEST_TRAFFIC_SHIFT ステージで停止しています。このままでは意味がないため、以下の 2 つの選択肢から選ぶ必要があります：

1. **デプロイを継続**：新バージョンに問題がなければ、本番トラフィックを新バージョンに切り替える
2. **ロールバック**：新バージョンに問題があれば、デプロイを失敗扱いにして旧バージョンに戻す

このステップでは、新バージョンの検証が成功したと仮定し、デプロイを継続する手順を説明します。

---

### 手順 1: Lambda 関数の修正（SUCCEEDED を返すように変更）

#### 1-1. Lambda 関数の編集画面を開く

1. AWS マネジメントコンソールで「**Lambda**」を開く
2. 関数一覧から「**my-app-lifecycle-hooks**」をクリック
3. 「**コード**」タブが表示される

#### 1-2. 関数コードの修正

現在のコードは`IN_PROGRESS`を返すようになっています。これを`SUCCEEDED`に変更します。

**修正前のコード**：

```python
import json
import logging

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

def lambda_handler(event, context):
    logger.info(f"Event:{json.dumps(event)}")
    logger.info(f"Context:{context}")
    return {
        'HookStatus': 'IN_PROGRESS'
    }
```

**修正後のコード**：

```python
import json
import logging

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

def lambda_handler(event, context):
    logger.info(f"Event:{json.dumps(event)}")
    logger.info(f"Context:{context}")
    return {
        'HookStatus': 'SUCCEEDED'
    }
```

**変更箇所**：

- 10 行目：`'IN_PROGRESS'` → `'SUCCEEDED'`に変更

#### 1-3. 変更の保存とデプロイ

1. コード編集エリアで上記の変更を適用
2. 画面右上の「**Deploy**」ボタンをクリック
3. 「**正常に更新されました**」というメッセージが表示される

> **説明**：Lambda 関数が`SUCCEEDED`を返すことで、ECS はデプロイを次のステージに進めます。

---

### 手順 2: デプロイの進行状況の確認

#### 2-1. ECS サービスページへの移動

1. AWS マネジメントコンソールで「**ECS**」を開く
2. **クラスター** → **my-app-cluster** → **サービス** → **my-app-frontend-service**
3. 「**デプロイ**」タブをクリック

#### 2-2. デプロイステージの変化を確認

Lambda 関数の変更後、約 30 秒待ってから画面を更新します（Lambda 関数は 30 秒ごとに実行されるため）。

**デプロイステージの変遷**：

1. **テストトラフィック移行後**（POST_TEST_TRAFFIC_SHIFT）← 現在ここで停止中
2. ↓（Lambda 関数が SUCCEEDED を返すと進行）
3. **本番トラフィック移行**（PRODUCTION_TRAFFIC_SHIFT）← 次のステージ
4. ↓
5. **ベイク時間**（POST_PRODUCTION_TRAFFIC_SHIFT）← ベイク時間中
6. ↓
7. **クリーンアップ**← 古いタスクを削除中
8. ↓
9. **成功**← デプロイ完了

#### 2-3. 「本番トラフィック移行」ステージの確認

1. ブラウザでページを数回更新（F5 キー）
2. 「**現在のデプロイ段階**」が「**本番トラフィック移行**」に変更されたことを確認

> **説明**：このステージでは、本番トラフィック（ポート 80）が新バージョン（グリーン環境）に切り替わります。

#### 2-4. 「ベイク時間」ステージの確認

さらに数回ページを更新すると、「**現在のデプロイ段階**」が「**ベイク時間**」に変更されます。

> **説明**：BEFORE_PRODUCTION_TRAFFIC_SHIFT ステージは非常に短いため、画面更新のタイミングによっては見えない場合があります。

---

### 手順 3: 本番環境（ポート 80）での新バージョン確認

#### 3-1. ロードバランサーの DNS 名を使用してアクセス

1. ブラウザで以下の URL にアクセス：

```
http://my-app-alb-1234567890.us-west-2.elb.amazonaws.com
```

**初回アクセス時の表示**：

```
Welcome to nginx!
```

> **注意**：ブラウザのキャッシュにより、旧バージョンが表示される場合があります。

#### 3-2. キャッシュをクリアして再確認

1. キーボードの「**Shift**」キーを押しながら、ブラウザの更新ボタンをクリック
   - または、「**Ctrl + Shift + R**」（Windows/Linux）
   - または、「**Cmd + Shift + R**」（Mac）

**更新後の表示**：

```
Hello World
```

> **確認**：一般ユーザー向けの本番トラフィック（ポート 80）も、新バージョン（グリーン環境）にルーティングされるようになりました。

---

### 手順 4: ベイク時間とロールバック可能期間

#### 4-1. ベイク時間の役割

現在「**ベイク時間**」ステージにあります。このステージでは：

- **本番トラフィック**：すべて新バージョン（グリーン）に流れている
- **旧タスク**（ブルー）：まだ削除されずに残っている
- **ロールバック**：まだ可能

**ベイク時間の設定値**：

- 今回の設定：**2 分間**（デプロイ設定で指定）

> **重要**：ベイク時間中は、問題が発生した場合でも即座に旧バージョンにロールバックできます。ベイク時間終了後は、旧タスクが削除されるためロールバック不可能になります。

#### 4-2. デプロイステージの進行確認

ベイク時間（2 分間）が経過すると、自動的に次のステージに進みます：

1. ブラウザで ECS サービスのページを定期的に更新
2. 「**現在のデプロイ段階**」が「**クリーンアップ**」に変更されることを確認

---

### 手順 5: クリーンアップステージの確認

#### 5-1. タスクの状態確認

1. ECS サービス詳細画面で「**タスク**」タブをクリック
2. タスク一覧を確認

**表示される内容**：

| タスク ID     | ステータス       | 必要なステータス | 説明                           |
| ------------- | ---------------- | ---------------- | ------------------------------ |
| task/xxxxxxxx | 実行中           | RUNNING          | 新バージョン（グリーン）       |
| task/yyyyyyyy | 非アクティブ化中 | STOPPED          | 旧バージョン（ブルー）- 削除中 |

> **説明**：「非アクティブ化中」は、ECS が古いタスクを停止・削除している最中であることを示します。

#### 5-2. デプロイ完了の確認

1. 「**デプロイとイベント**」タブに戻る
2. 数分待ってページを更新
3. 「**デプロイステータス**」が「**成功**」に変更されたことを確認

> **確認**：これでブルー/グリーンデプロイが完全に完了しました。

#### 5-3. 完了後の状態

| 項目               | 状態                               |
| ------------------ | ---------------------------------- |
| デプロイステータス | 成功                               |
| 実行中のタスク     | 新バージョンのみ（グリーン）       |
| 旧タスク           | 削除済み（ブルー）                 |
| ロールバック       | 不可能（旧タスクが存在しないため） |

---

### 手順 6: ロードバランサーとターゲットグループの最終状態確認

#### 6-1. リスナー設定の確認

1. AWS マネジメントコンソールで「**EC2**」→「**ロードバランサー**」
2. 「**my-app-alb**」を選択
3. 「**リスナーとルール**」タブをクリック
4. ブラウザでページを更新

**最終的なリスナー設定**：

| リスナー   | プロトコル:ポート | デフォルトアクション     |
| ---------- | ----------------- | ------------------------ |
| リスナー 1 | HTTP:80           | my-app-tg-1 へフォワード |
| リスナー 2 | HTTP:9000         | my-app-tg-1 へフォワード |

> **確認**：両方のリスナーが同じターゲットグループ（my-app-tg-1）にルーティングしています。

#### 6-2. ターゲットグループの状態確認

**ターゲットグループ 1（my-app-tg-1）**：

1. 左側メニューから「**ターゲットグループ**」をクリック
2. 「**my-app-tg-1**」を選択
3. 「**ターゲット**」タブをクリック

| ターゲット ID | ステータス | 説明                                   |
| ------------- | ---------- | -------------------------------------- |
| タスクの ENI  | healthy    | 新バージョン（グリーン）のタスクが接続 |

**ターゲットグループ 2（my-app-tg-2）**：

1. 「**my-app-tg-2**」を選択
2. 「**ターゲット**」タブをクリック

| ターゲット ID | ステータス | 説明                                        |
| ------------- | ---------- | ------------------------------------------- |
| タスクの ENI  | draining   | 旧バージョン（ブルー）のタスク - 削除処理中 |

> **説明**：「draining」ステータスは、ターゲットへの新規接続を停止し、既存の接続が完了するのを待っている状態です。しばらくするとターゲットが完全に削除されます。

#### 6-3. 最終的なトラフィックフロー

デプロイ完了後の状態：

```
【現在の状態】
一般ユーザー → ALB:80 → my-app-tg-1 → 新タスク（Hello World）
開発者       → ALB:9000 → my-app-tg-1 → 新タスク（Hello World）

【削除済み】
旧タスク（Welcome to nginx!）← 完全に削除された
```

---

### 手順 7: ブルー/グリーンの役割交代の理解

#### 7-1. ブルー/グリーンは相対的な概念

「ブルー」と「グリーン」は絶対的な名前ではなく、相対的なニックネームです：

**今回のデプロイでの役割**：

| 環境     | タスク定義        | 役割         | 最終的な状態 |
| -------- | ----------------- | ------------ | ------------ |
| ブルー   | my-app-frontend:1 | 旧バージョン | 削除済み     |
| グリーン | my-app-frontend:2 | 新バージョン | 稼働中       |

**次回のデプロイでの役割**：

| 環境     | タスク定義        | 役割                           | 状態         |
| -------- | ----------------- | ------------------------------ | ------------ |
| ブルー   | my-app-frontend:2 | 旧バージョン（前回のグリーン） | 稼働中       |
| グリーン | my-app-frontend:3 | 新バージョン（新規作成）       | これから起動 |

> **ポイント**：今回「グリーン」だったタスクは、次回のデプロイでは「ブルー」の扱いになります。

#### 7-2. ターゲットグループのローテーション

ターゲットグループも同様に役割が交代します：

**現在の状態（デプロイ完了後）**：

| ターゲットグループ | 接続先   | 役割                       |
| ------------------ | -------- | -------------------------- |
| my-app-tg-1        | 新タスク | グリーン（現在の本番環境） |
| my-app-tg-2        | なし     | 空（旧タスク削除済み）     |

**次回デプロイ時の状態**：

| ターゲットグループ | 接続先                   | 役割                     |
| ------------------ | ------------------------ | ------------------------ |
| my-app-tg-1        | my-app-frontend:2 タスク | ブルー（旧バージョン）   |
| my-app-tg-2        | my-app-frontend:3 タスク | グリーン（新バージョン） |

**次回デプロイ完了後の状態**：

| ターゲットグループ | 接続先                   | 役割                       |
| ------------------ | ------------------------ | -------------------------- |
| my-app-tg-1        | なし                     | 空（旧タスク削除済み）     |
| my-app-tg-2        | my-app-frontend:3 タスク | グリーン（現在の本番環境） |

#### 7-3. ブルー/グリーンのローテーションパターン

デプロイを繰り返すと、以下のパターンで循環します：

```
【1回目のデプロイ】
tg-1: リビジョン1（ブルー） → リビジョン2（グリーン）✓
tg-2: 空

【2回目のデプロイ】
tg-1: リビジョン2（ブルー） → 空
tg-2: リビジョン3（グリーン）✓

【3回目のデプロイ】
tg-1: リビジョン4（グリーン）✓
tg-2: リビジョン3（ブルー） → 空

【4回目のデプロイ】
tg-1: リビジョン4（ブルー） → 空
tg-2: リビジョン5（グリーン）✓
```

> **理解のポイント**：2 つのターゲットグループが交互に本番環境とテスト環境の役割を果たし、継続的にデプロイを実施できます。

---

### まとめ

この手順では以下を実施しました：

1. ✅ Lambda 関数を修正し、`SUCCEEDED`を返すように変更
2. ✅ デプロイが POST_TEST_TRAFFIC_SHIFT から PRODUCTION_TRAFFIC_SHIFT ステージに進行
3. ✅ 本番トラフィック（ポート 80）が新バージョン（Hello World）に切り替わったことを確認
4. ✅ ベイク時間（2 分間）中にロールバック可能な期間があることを理解
5. ✅ クリーンアップステージで旧タスク（ブルー）が削除されることを確認
6. ✅ デプロイが「成功」ステータスで完了
7. ✅ ロードバランサーとターゲットグループの最終状態を確認
8. ✅ ブルー/グリーンの役割が次回デプロイで交代することを理解

**ブルー/グリーンデプロイのライフサイクル完全図**：

```
1. 新タスク起動（グリーン）
2. TEST_TRAFFIC_SHIFT
   └→ テストリスナー（9000）をグリーンに接続
3. POST_TEST_TRAFFIC_SHIFT ← Lambda実行（検証のため停止）
4. BEFORE_PRODUCTION_TRAFFIC_SHIFT
5. PRODUCTION_TRAFFIC_SHIFT
   └→ 本番リスナー（80）をグリーンに切り替え
6. POST_PRODUCTION_TRAFFIC_SHIFT（ベイク時間:2分）
   └→ ロールバック可能な最後のチャンス
7. クリーンアップ
   └→ 旧タスク（ブルー）を削除
8. 完了
   └→ ロールバック不可能
```

**最終的な状態**：

- 新バージョン（Hello World）が本番環境で稼働中
- 旧バージョン（Welcome to nginx!）は完全に削除
- 次回デプロイ時は、現在の新バージョンが「ブルー」の役割となり、さらに新しいバージョンが「グリーン」として展開される

これで ECS ブルー/グリーンデプロイメントとライフサイクルフックを使用した安全なデプロイ手順が完了しました。

---

## ステップ 11: ブルー/グリーンデプロイのロールバック

### 概要

ブルー/グリーンデプロイの大きなメリットの一つは、**ロールバック機能**です。新バージョン（グリーン）に問題が見つかった場合、旧バージョン（ブルー）が残っている間は即座に元の状態に戻すことができます。

このステップでは、実際にロールバックのデモを行います。そのため、もう一度ブルー/グリーンデプロイを実行し、ロールバック可能な状態を作り出します。

---

### 現状の確認と次のデプロイ計画

#### 現在の状態

前回のデプロイ完了後、以下の状態になっています：

| 環境           | タスク定義        | 表示内容          | 状態         |
| -------------- | ----------------- | ----------------- | ------------ |
| ブルー（旧）   | my-app-frontend:1 | Welcome to nginx! | **削除済み** |
| グリーン（新） | my-app-frontend:2 | Hello World       | **稼働中**   |

> **問題点**：ブルー環境が削除されたため、このままではロールバックのデモができません。

#### 次のデプロイ計画

ロールバックをデモするため、もう一度ブルー/グリーンデプロイを実行します：

**デプロイ後の役割**：

| 環境           | タスク定義        | 表示内容          | 役割                          |
| -------------- | ----------------- | ----------------- | ----------------------------- |
| ブルー（旧）   | my-app-frontend:2 | Hello World       | 現在稼働中 → ブルーとして扱う |
| グリーン（新） | my-app-frontend:1 | Welcome to nginx! | 新規起動 → グリーンとして扱う |

> **重要な理解**：リビジョン番号は関係ありません。ブルー/グリーンにおいて重要なのは「現在稼働中（ブルー）」と「新しく置き換えるもの（グリーン）」という相対的な関係です。

---

### 手順 1: Lambda 関数を IN_PROGRESS に戻す

ロールバックを実行するための猶予を作るため、Lambda 関数を再度`IN_PROGRESS`を返すように変更します。

#### 1-1. Lambda 関数の編集

1. AWS マネジメントコンソールで「**Lambda**」を開く
2. 関数一覧から「**my-app-lifecycle-hooks**」をクリック
3. 「**コード**」タブで以下のように変更：

**変更内容**：

```python
import json
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    logger.info(f"Event:{json.dumps(event)}")

    return {
        'HookStatus': 'IN_PROGRESS'  # SUCCEEDEDから変更
    }
```

**変更箇所**：

- 10 行目：`'SUCCEEDED'` → `'IN_PROGRESS'`に戻す

#### 1-2. デプロイ

1. 画面右上の「**Deploy**」ボタンをクリック
2. 「**正常に更新されました**」と表示される

> **説明**：`IN_PROGRESS`を返すことで、POST_TEST_TRAFFIC_SHIFT ステージでデプロイが停止し、ロールバックを試す時間が得られます。

---

### 手順 2: タスク定義リビジョン 1 を使用してデプロイ

#### 2-1. CloudShell の起動

1. AWS マネジメントコンソール右上の CloudShell アイコン（>\_）をクリック
2. CloudShell が起動するまで待つ

#### 2-2. サービス更新コマンドの実行

以前使用したコマンドのタスク定義リビジョンを変更します：

```bash
aws ecs update-service \
  --cluster my-app-cluster \
  --service my-app-frontend-service \
  --task-definition my-app-frontend:1 \
  --force-new-deployment
```

**変更点**：

- `--task-definition my-app-frontend:2` → `my-app-frontend:1`に変更

> **説明**：リビジョン 1（Welcome to nginx!）を使用して、新しいデプロイを開始します。

#### 2-3. コマンド実行結果の確認

JSON 形式でサービス情報が返されることを確認：

```json
{
    "service": {
        "taskDefinition": "arn:aws:ecs:us-west-2:xxxxxxxxxxxx:task-definition/my-app-frontend:1",
        ...
    }
}
```

---

### 手順 3: デプロイ進行状況の確認

#### 3-1. サービス詳細画面を開く

1. AWS マネジメントコンソールで「**ECS**」を開く
2. **クラスター** → **my-app-cluster** → **サービス** → **my-app-frontend-service**
3. 「**デプロイとイベント**」タブをクリック

#### 3-2. デプロイステータスの確認

ページを更新（F5 キー）して、以下を確認：

| 項目               | 値                      |
| ------------------ | ----------------------- |
| デプロイステータス | **進行中**              |
| ロールバックボタン | **表示される** ← 重要！ |

> **重要**：デプロイが進行中の間、「**ロールバック**」ボタンが表示されます。このボタンで UI 経由のロールバックが可能です。

#### 3-3. POST_TEST_TRAFFIC_SHIFT ステージまで待機

ページを数回更新しながら、「**現在のデプロイ段階**」が「**テストトラフィック移行後**」になるまで待ちます。

**確認ポイント**：

- 現在のデプロイ段階：**テストトラフィック移行後**（POST_TEST_TRAFFIC_SHIFT）
- ステータス：**進行中**（Lambda 関数が IN_PROGRESS を返すため停止）

---

### 手順 4: ロードバランサーの状態確認

#### 4-1. リスナー設定の確認

1. 「**正常性とメトリクス**」タブをクリック
2. ロードバランサー「**my-app-alb**」のリンクをクリック
3. 「**リスナーとルール**」タブをクリック
4. ページを更新

**現在のリスナー設定**：

| リスナー   | プロトコル:ポート | ターゲットグループ | 環境                          |
| ---------- | ----------------- | ------------------ | ----------------------------- |
| リスナー 1 | HTTP:80           | my-app-tg-1        | ブルー（Hello World）         |
| リスナー 2 | HTTP:9000         | my-app-tg-2        | グリーン（Welcome to nginx!） |

> **説明**：
>
> - ポート 80（本番）：まだブルー環境（Hello World）にルーティング
> - ポート 9000（テスト）：新しいグリーン環境（Welcome to nginx!）にルーティング

#### 4-2. タスクの状態確認

ECS サービス詳細画面で「**タスク**」タブをクリック：

**表示されるタスク**：

| タスク ID     | タスク定義        | ステータス | 役割                     |
| ------------- | ----------------- | ---------- | ------------------------ |
| task/xxxxxxxx | my-app-frontend:2 | 実行中     | ブルー（現在の本番）     |
| task/yyyyyyyy | my-app-frontend:1 | 実行中     | グリーン（新バージョン） |

> **確認**：2 つのタスクが同時に実行されています。これがブルー/グリーンデプロイの状態です。

---

### 手順 5: 新バージョンの検証とロールバック判断

#### 5-1. テストリスナー（ポート 9000）での確認

新バージョンをテストリスナー経由で確認します：

```
http://my-app-alb-1234567890.us-west-2.elb.amazonaws.com:9000
```

**表示される内容**：

```
Welcome to nginx!

If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.
```

> **仮定**：目視チェックの結果、期待した動作ではないと判断したとします（今回はデモのため）。

#### 5-2. ロールバックの判断

新バージョンに問題があると判断した場合、以下の 2 つの方法でロールバックできます：

**方法 1：Lambda 関数で`FAILED`を返す**

- Lambda 関数のコードを修正し、`'HookStatus': 'FAILED'`を返す
- 次回の Lambda 実行時（約 30 秒後）に自動的にロールバックが開始される

**方法 2：UI 上の「ロールバック」ボタンをクリック**

- ECS サービス画面の「ロールバック」ボタンを押す
- 即座にロールバックが開始される

今回は**方法 2（UI ボタン）**を使用します。

---

### 手順 6: ロールバックの実行

#### 6-1. ロールバックボタンのクリック

1. ECS サービス詳細画面の「**デプロイとイベント**」タブを開く
2. 画面右上の「**ロールバック**」ボタンをクリック
3. 確認ダイアログが表示されたら「**ロールバック**」をクリック

#### 6-2. ロールバック開始の確認

ボタンをクリックすると、表示が以下のように変わります：

```
ロールバックがリクエストされました
```

> **説明**：ロールバック処理が開始され、新しいデプロイ（グリーン）がキャンセルされます。

---

### 手順 7: ロールバック進行状況の確認

#### 7-1. タスクの変化を監視

「**タスク**」タブを定期的に更新して、タスクの状態を確認します：

**ロールバック開始直後**：

| タスク ID     | タスク定義        | ステータス | 作成時刻 |
| ------------- | ----------------- | ---------- | -------- |
| task/xxxxxxxx | my-app-frontend:2 | 実行中     | 古い     |
| task/yyyyyyyy | my-app-frontend:1 | 実行中     | 新しい   |

**数分後**：

| タスク ID     | タスク定義        | ステータス           | 作成時刻 | 説明               |
| ------------- | ----------------- | -------------------- | -------- | ------------------ |
| task/xxxxxxxx | my-app-frontend:2 | 実行中               | 古い     | ブルー（維持）     |
| task/yyyyyyyy | my-app-frontend:1 | **非アクティブ化中** | 新しい   | グリーン（削除中） |

> **確認**：新しく作成されたタスク（my-app-frontend:1）が「非アクティブ化中」になり、削除されつつあります。作成時刻を見ると、新しい方のタスクが削除対象であることが分かります。

#### 7-2. ロードバランサーの状態確認

1. 「**正常性とメトリクス**」タブをクリック
2. ロードバランサー「**my-app-alb**」を開く
3. 「**リスナーとルール**」タブを開いてページを更新

**ロールバック後のリスナー設定**：

| リスナー   | プロトコル:ポート | ターゲットグループ | 変化                   |
| ---------- | ----------------- | ------------------ | ---------------------- |
| リスナー 1 | HTTP:80           | my-app-tg-1        | 変更なし（元々ブルー） |
| リスナー 2 | HTTP:9000         | my-app-tg-1        | **tg-2 から戻った**    |

> **確認**：ポート 9000 のルーティング先が`my-app-tg-2`から`my-app-tg-1`に戻りました。これはロールバックが正常に進行していることを示します。

#### 7-3. トラフィックフローの理解

ロールバック後のトラフィックフロー：

```
【ロールバック前（POST_TEST_TRAFFIC_SHIFT停止中）】
一般ユーザー → ALB:80   → my-app-tg-1 → ブルー（Hello World）
開発者       → ALB:9000 → my-app-tg-2 → グリーン（Welcome to nginx!）

【ロールバック後】
一般ユーザー → ALB:80   → my-app-tg-1 → ブルー（Hello World）
開発者       → ALB:9000 → my-app-tg-1 → ブルー（Hello World）

【削除中】
グリーン環境（my-app-frontend:1）← 削除処理中
```

> **結果**：新しいデプロイ（グリーン）がキャンセルされ、旧バージョン（ブルー）に完全に戻りました。

---

## ステップ 12: AWS リソースのクリーンアップ

### 概要

このステップでは、今回使用した AWS リソースを削除し、不要な課金を防ぎます。AWS では使用していないリソースでも課金されるものがあるため、適切にクリーンアップすることが重要です。

**削除対象リソース**：

1. Application Load Balancer（ALB）← 最も高コスト
2. ECS サービス（CloudFormation 経由）
3. ECR イメージ

**残すリソース**：

- ECS クラスター（後続のセクションで使用）
- ECR リポジトリ（後続のセクションで使用）
- ターゲットグループ（課金なし）

---

### 手順 1: Application Load Balancer（ALB）の削除

Application Load Balancer は最も高コストなリソースの一つです。まずこれを削除します。

#### 1-1. EC2 サービスへの移動

1. AWS マネジメントコンソールの上部検索欄に「**EC2**」と入力
2. 「**EC2**」をクリック

#### 1-2. ロードバランサー画面へ

1. 左側メニューから「**ロードバランサー**」をクリック
2. ロードバランサー一覧が表示される

#### 1-3. ロードバランサーの選択

1. 「**my-app-alb**」のチェックボックスにチェックを入れる
2. 画面上部の「**アクション**」ボタンをクリック
3. ドロップダウンから「**ロードバランサーの削除**」を選択

#### 1-4. 削除の確認と実行

1. 削除確認ダイアログが表示される
2. テキストボックスに「**confirm**」と入力
3. 「**削除**」ボタンをクリック
4. 「**正常に削除されました**」というメッセージが表示される

> **確認**：ロードバランサー一覧から`my-app-alb`が削除されたことを確認してください。

#### 1-5. ターゲットグループの扱い

1. 左側メニューから「**ターゲットグループ**」をクリック
2. `my-app-tg-1`と`my-app-tg-2`が残っていることを確認

> **注意**：ターゲットグループ自体は課金されないため、削除しなくても問題ありません。残しておくと後で再利用できます。削除したい場合は、各ターゲットグループを選択して「アクション」→「削除」で削除できます。

---

### 手順 2: ECS サービスの削除（CloudFormation 経由）

ECS サービスは CloudFormation スタックを通じて管理されているため、CloudFormation 経由で削除するのが最もクリーンです。

#### 2-1. CloudFormation とは

**CloudFormation**は、コード（JSON または YAML）で AWS リソースを管理するサービスです：

- インフラをコードとして定義（Infrastructure as Code）
- リソースの作成・更新・削除を一括管理
- ECS コンソールからクラスターやサービスを作成すると、自動的に CloudFormation スタックが作成される

#### 2-2. CloudFormation サービスへの移動

1. AWS マネジメントコンソールの上部検索欄に「**CloudFormation**」と入力
2. 「**CloudFormation**」をクリック

#### 2-3. スタックの確認

「**スタック**」画面に 2 つのスタックが表示されます：

| スタック名                                         | 説明                       | 用途               |
| -------------------------------------------------- | -------------------------- | ------------------ |
| ECS-Console-V2-Cluster-my-app-cluster-...          | クラスター作成時に自動生成 | ECS クラスター管理 |
| ECS-Console-V2-Service-my-app-frontend-service-... | サービス作成時に自動生成   | ECS サービス管理   |

**スタックの見分け方**：

- スタック名に「**Cluster**」が含まれる → クラスター用
- スタック名に「**Service**」が含まれる → サービス用

#### 2-4. サービス用スタックの選択

1. スタック一覧から、スタック名に「**Service**」と「**my-app-frontend-service**」が含まれるスタックを見つける
2. そのスタック名をクリック

#### 2-5. スタックの削除

1. 画面右上の「**削除**」ボタンをクリック
2. 削除確認ダイアログが表示される：
   ```
   スタックを削除すると、全てのスタックリソースが削除されます
   ```
3. 「**削除**」ボタンをクリック

> **説明**：CloudFormation スタックを削除すると、そのスタックで作成されたすべてのリソース（ECS サービス、タスク定義など）が自動的に削除されます。これを「ロールバック」と呼びます。

#### 2-6. 削除の進行状況確認

1. スタック一覧画面に戻る
2. 削除中のスタックのステータスが「**DELETE_IN_PROGRESS**」になっていることを確認
3. 数分待つ

#### 2-7. ECS サービスの削除確認

1. 上部検索欄で「**ECS**」と入力して ECS サービスを開く
2. 左側メニューから「**クラスター**」をクリック
3. 「**my-app-cluster**」をクリック
4. 「**サービス**」タブをクリック
5. サービス一覧から「**my-app-frontend-service**」が削除されていることを確認

> **確認**：サービス一覧が空になっているはずです。

#### 2-8. CloudFormation スタックの削除完了確認

1. CloudFormation サービスに戻る
2. 削除したスタックが一覧から完全に消えていることを確認
3. もしまだ表示されている場合は、数分待ってページを更新

> **注意**：削除には数分かかる場合があります。ステータスが「**DELETE_COMPLETE**」になった後、一覧から自動的に消えます。

---

### 手順 3: ECS クラスターの扱い

#### 3-1. クラスターの確認

1. ECS サービスで「**クラスター**」を開く
2. 「**my-app-cluster**」が残っていることを確認

#### 3-2. クラスターを残す理由

**クラスターは削除しないでください**：

- **課金なし**：ECS クラスター自体は課金されません（実行中のタスクやサービスがなければ）
- **後続セクションで使用**：今後の講義で同じクラスターを使用します
- **削除は不要**：リソースがアタッチされていない空のクラスターは無害です

> **重要**：`my-app-cluster`は**そのまま残しておいてください**。

---

### 手順 4: ECR イメージの削除

ECR（Elastic Container Registry）では、保存するイメージのサイズに応じて課金されます。

#### 4-1. ECR サービスへの移動

1. AWS マネジメントコンソールの上部検索欄に「**ECR**」と入力
2. 「**Elastic Container Registry**」をクリック

#### 4-2. リポジトリの確認

1. 左側メニューから「**プライベートリポジトリ**」をクリック
2. 「**my-app-frontend**」リポジトリが表示される

> **注意**：リポジトリ自体は削除しないでください。後続の講義で使用します。

#### 4-3. リポジトリ内のイメージ確認

1. 「**my-app-frontend**」リポジトリ名をクリック
2. リポジトリ内のイメージ一覧が表示される

**表示される情報**：

| 列                   | 説明                         |
| -------------------- | ---------------------------- |
| イメージタグ         | latest など                  |
| プッシュ日時         | イメージがプッシュされた日時 |
| サイズ               | イメージのサイズ（MB/GB）    |
| イメージダイジェスト | イメージの一意識別子         |

#### 4-4. イメージの削除

1. 削除したいイメージのチェックボックスにチェックを入れる
   - 複数選択可能
   - すべてのイメージを選択する場合は、ヘッダーのチェックボックスをクリック
2. 画面上部の「**削除**」ボタンをクリック
3. 削除確認ダイアログが表示される
4. テキストボックスに「**delete**」と入力
5. 「**削除**」ボタンをクリック

#### 4-5. 削除の確認

1. イメージ一覧が空になったことを確認
2. 「**正常に削除されました**」というメッセージが表示される

> **結果**：ECR に保存されているイメージが削除され、ストレージ課金がなくなります。

#### 4-6. リポジトリを残す理由

**リポジトリは削除しないでください**：

- **課金なし**：イメージが入っていない空のリポジトリは課金されません
- **後続セクションで使用**：今後の講義で同じリポジトリを使用します

---

### クリーンアップの確認チェックリスト

以下のリソースが正しく処理されていることを確認してください：

| リソース                  | 状態        | 課金     | 確認方法                        |
| ------------------------- | ----------- | -------- | ------------------------------- |
| Application Load Balancer | ✅ 削除済み | なし     | EC2 → ロードバランサー一覧      |
| ECS サービス              | ✅ 削除済み | なし     | ECS → クラスター → サービス一覧 |
| ECS タスク                | ✅ 自動削除 | なし     | サービス削除で自動的に停止      |
| ECR イメージ              | ✅ 削除済み | なし     | ECR → リポジトリ内を確認        |
| ECS クラスター            | ⚠️ 残す     | なし     | 後続セクションで使用            |
| ECR リポジトリ            | ⚠️ 残す     | なし     | 後続セクションで使用            |
| ターゲットグループ        | ⚠️ 任意     | なし     | 削除しても残しても可            |
| Lambda 関数               | ⚠️ 残す     | ほぼなし | 後続セクションで使用可能        |
| IAM ロール                | ⚠️ 残す     | なし     | 再利用可能                      |

---

### 課金を防ぐためのポイント

#### 高コストリソース

以下のリソースは必ず削除してください：

1. **Application Load Balancer**：時間単位で課金（約$0.0225/時間）
2. **実行中の ECS タスク**：EC2 起動タイプの場合、実行時間で課金
3. **ECR イメージ**：ストレージ容量で課金（$0.10/GB/月）

#### 無料または低コストリソース

以下は残しても問題ありません：

1. **ECS クラスター**：課金なし
2. **ECR リポジトリ（空）**：課金なし
3. **Lambda 関数**：実行しなければほぼ課金なし
4. **IAM ロール**：課金なし
5. **ターゲットグループ**：課金なし

---

### トラブルシューティング

#### Q1: CloudFormation スタックが削除できない

**原因**：依存リソースが残っている可能性があります。

**解決方法**：

1. スタックの「イベント」タブで失敗理由を確認
2. 依存リソースを手動で削除してから再試行
3. 最終手段：ECS コンソールから直接サービスを削除

#### Q2: ロードバランサーが削除できない

**原因**：削除保護が有効になっている可能性があります。

**解決方法**：

1. ロードバランサーを選択
2. 「属性」タブで「削除保護」を無効化
3. 再度削除を試行

#### Q3: ECR イメージが削除できない

**原因**：イメージがタスク定義から参照されている可能性があります。

**解決方法**：

1. ECS サービスとタスクを先に削除
2. しばらく待ってから ECR イメージを削除

---

### まとめ

このステップでは以下を実施しました：

1. ✅ Application Load Balancer（ALB）を削除し、高額な課金を停止
2. ✅ CloudFormation 経由で ECS サービスをクリーンに削除
3. ✅ ECR イメージを削除し、ストレージ課金を停止
4. ✅ 後続セクションで使用するリソース（クラスター、リポジトリ）を保持

**削除したリソース**：

- my-app-alb（Application Load Balancer）
- my-app-frontend-service（ECS サービス）
- ECR 内の Docker イメージ

**保持したリソース**：

- my-app-cluster（ECS クラスター）
- my-app-frontend（ECR リポジトリ）
- その他のリソース（Lambda、IAM ロールなど）

これで不要な課金を防ぎつつ、今後の学習に必要なリソースは保持した状態になりました。
